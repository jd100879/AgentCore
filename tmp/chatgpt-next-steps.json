{
  "ok": true,
  "raw_text": "Yes — implement Guard #8. Your latest run proves the happy path is solid; Guard #8 is what makes it operationally safe when the UI/model inevitably misbehaves.\n\nBelow is the priority order and what I’d do for each question.\n\nPriority Order\n\nGuard #8: strict JSON enforcement + retry loop (short, high leverage)\n\nFull end-to-end integration test (prove routing + mail semantics)\n\nDefine parse-fail behavior + escalation policy (deterministic ops)\n\nProduction readiness checklist (only after 1–3)\n\n1) Guard #8 — should you implement it?\n\nYes. Stability detection prevents “partial DOM reads.” It does not prevent:\n\nthe model emitting placeholders (..., [...])\n\nthe model outputting a non-JSON message\n\n“Continue generating” truncation behavior\n\ntwo JSON blocks where only one is valid\n\nChatGPT refusing “JSON only” occasionally\n\nGuard #8 is cheap insurance and it keeps failures self-healing.\n\nMinimal Guard #8 spec (keep it simple)\n\nAttempts: 3 total\n\nRetry triggers:\n\nJSON parse fails\n\nextracted JSON contains placeholder markers:\n\n... or …\n\n\"[...]\" / [...]\n\n// comments inside JSON block\n\nTRUNCATED, omitted, placeholder\n\nEscalation prompt on retry 2 and 3:\n\n“CRITICAL: Return ONLY one ```json block containing STRICT JSON. NO placeholders (...), NO comments, NO prose.”\n\nImportant: keep idempotency semantics\n\nIf you retry, do not create a new idempotency marker until you succeed, or include attempt number in the marker filename so retries are allowed for the same request.\n\n2) Integration testing — should you test full E2E?\n\nYes, immediately after Guard #8.\n\nYou’ve proven extraction. Now prove the system:\n\nE2E test cases (in order):\n\nHappy path: BATCH_PLAN → post → extract → reply to requester\n\nIdempotency: same request re-sent → skipped\n\nRetry path: force failure (use a prompt that intentionally asks for placeholders) → confirm retry triggers → success\n\nLogin failure path: simulate expired session → helper returns LOGIN_REQUIRED → bridge alerts operator → no further actions taken\n\nMail archive behavior: ensure the request is archived only after successful processing (or after final failure with error reply)\n\nIf these pass, you’re basically ready.\n\n3) Error handling — what happens when parsing fails?\n\nYour current behavior (“error object + raw_text”) is good, but tighten it into a deterministic policy:\n\nRecommended failure contract from helper → bridge\n\nReturn one of:\n\nok: true, result: <parsed_json>\n\nok: false, error_code: \"PARSE_FAILED\", raw_text: \"...\", attempts: 3\n\nok: false, error_code: \"LOGIN_REQUIRED\", href: \"...\"\n\nok: false, error_code: \"NON_COMPLIANT_RESPONSE\", raw_text: \"...\"\n\nok: false, error_code: \"TIMEOUT_WAITING_FOR_COMPLETION\"\n\nBridge behavior by error_code\n\nPARSE_FAILED / NON_COMPLIANT_RESPONSE:\n\nReply back to the requesting agent with the error + raw_text (so a human/Claude can salvage)\n\nArchive the request (otherwise it loops forever)\n\nWrite failure marker .flywheel/bridge/sent/<request_id>.fail.json\n\nLOGIN_REQUIRED:\n\nSend urgent operator alert (agent-mail to you)\n\nDo not archive the request (optional) — but I’d archive it and re-queue later; otherwise you can get stuck repeating failures. Best: archive + notify + require resend after refresh.\n\nTIMEOUT:\n\nRetry once if safe; otherwise fail with raw_text and archive\n\n4) Production readiness — what else to validate?\n\nHere’s the short checklist that actually matters:\n\nA) Reliability\n\n20–50 runs of batch planning with mixed bead sizes\n\nconfirm retry loop is rarely used but works when needed\n\nB) Correctness\n\nschema validation for the planned JSON shape (even lightweight)\n\n“bead_id must match requested bead_id” check\n\nC) Ops / Observability\n\nstructured logs with:\n\nrequest_id\n\nattempt #\n\nextracted length\n\nparse_ok\n\nerror_code\n\nkeep screenshots disabled by default; only on DEBUG=1\n\nD) Safety valves\n\nhard cap response size (to avoid insane outputs)\n\ntimeouts on “wait for completion”\n\nkill Chromium on exit (no zombies)\n\nAnswer Summary\n\nGuard #8: Implement it. It’s not about this last test; it’s about the inevitable bad day.\n\nIntegration test: Yes, do it next — extraction alone isn’t the system.\n\nParse fail policy: Keep returning raw_text, but add error_code-driven behavior and failure markers.\n\nProduction readiness: Run a small reliability suite + add structured logs + safety valves.\n\nIf you paste your current post-and-extract.mjs return envelope shape, I’ll give you the exact error_code taxonomy + retry decision matrix that fits your current code with minimal edits.",
  "parse_ok": false,
  "extracted_json": null,
  "error": "JSON_PARSE_ERROR: Unexpected token '.', \"[...]\" is not valid JSON"
}
