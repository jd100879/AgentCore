{
  "ok": true,
  "raw_text": "JSON\n[\n  {\n    \"id\": \"bd-test-1\",\n    \"code\": \"pXa-01\",\n    \"title\": \"Restore bead info loading and surface root cause\",\n    \"priority\": \"P0\",\n    \"depends_on\": [],\n    \"how_to_think\": \"This is a debugging and reliability bead focused on why bead metadata is failing to load. Preserve idempotency: do not create, duplicate, or mutate bead records as part of read/retry behavior. Preserve transaction boundaries: reads should remain read-only, and any repairs (if needed) must be explicit and separately gated. Keep changes additive and low-risk—prefer better error classification, correlation IDs, and guarded fallbacks over refactors. Stop and escalate if the failure is due to missing upstream dependencies (bead store offline/corrupt), permission/secrets issues, or schema/API contract changes; in that case produce a minimal diagnostic report and propose the next smallest bead(s).\",\n    \"acceptance_criteria\": [\n      \"Bead id bd-test-1 loads successfully via the primary bead read path (title/description/status resolved; no 'Failed to load')\",\n      \"On bead-load failures, the system returns a structured error with an error_code and correlation_id, and logs include the underlying exception/status and the bead id\"\n    ],\n    \"files_to_create\": [\n      \"docs/debug/bead-load-failure-bd-test-1.md\"\n    ],\n    \"files_to_modify\": [\n      \"scripts/agent-mail-helper.sh\",\n      \"scripts/bridge/bridge-agent-loop.sh\"\n    ],\n    \"verification\": [\n      \"Docker-first: bring up the same stack used in normal runs (e.g., docker compose up -d). Trigger the bead read operation for bd-test-1 using the exact CLI/script the system uses (e.g., ./scripts/<bead-read>.sh bd-test-1) or the UI path that loads bead metadata.\",\n      \"Expected: bead metadata resolves (non-empty title/description/status). If you intentionally break the backend to simulate failure, you see error_code + correlation_id returned and logs show bead id + root exception/status.\"\n    ]\n  },\n  {\n    \"id\": \"bd-test-2\",\n    \"code\": \"pXa-01\",\n    \"title\": \"Add retry-safe fallback and regression test for bead loads\",\n    \"priority\": \"P1\",\n    \"depends_on\": [\"bd-test-1\"],\n    \"how_to_think\": \"This bead is about hardening and preventing recurrence after the root cause for bd-test-1 is understood. Preserve idempotency on retries: repeated load attempts must not cause duplicate side effects (no duplicate mail sends, no duplicate bead creation). Keep changes additive: add a small fallback path and a regression test rather than refactoring core logic. Stop and escalate if the only viable fix requires changing the bead schema, rewriting the storage layer, or altering cross-module contracts; in that case propose a separate design bead first.\",\n    \"acceptance_criteria\": [\n      \"If a bead load fails transiently, the system retries safely (no duplicate state writes) and either succeeds or returns a structured failure with clear next steps\",\n      \"A regression test covers the bd-test-2 failure mode and passes in CI/local runs\"\n    ],\n    \"files_to_create\": [\n      \"tests/integration/bead-load-regression.test.mjs\"\n    ],\n    \"files_to_modify\": [\n      \"scripts/agent-mail-helper.sh\",\n      \"scripts/bridge/bridge-agent-loop.sh\"\n    ],\n    \"verification\": [\n      \"Docker-first: run the integration test against a local stack (e.g., docker compose up -d && node tests/integration/bead-load-regression.test.mjs). If you have a test runner, wire it into npm test and run npm test -- bead-load-regression.\",\n      \"Expected: test passes, retry behavior is bounded and idempotent, and when failure is forced the returned object includes error_code + correlation_id with no duplicate side effects (confirmed by logs and/or idempotency markers).\"\n    ]\n  }\n]",
  "parse_ok": true,
  "extracted_json": [
    {
      "id": "bd-test-1",
      "code": "pXa-01",
      "title": "Restore bead info loading and surface root cause",
      "priority": "P0",
      "depends_on": [],
      "how_to_think": "This is a debugging and reliability bead focused on why bead metadata is failing to load. Preserve idempotency: do not create, duplicate, or mutate bead records as part of read/retry behavior. Preserve transaction boundaries: reads should remain read-only, and any repairs (if needed) must be explicit and separately gated. Keep changes additive and low-risk—prefer better error classification, correlation IDs, and guarded fallbacks over refactors. Stop and escalate if the failure is due to missing upstream dependencies (bead store offline/corrupt), permission/secrets issues, or schema/API contract changes; in that case produce a minimal diagnostic report and propose the next smallest bead(s).",
      "acceptance_criteria": [
        "Bead id bd-test-1 loads successfully via the primary bead read path (title/description/status resolved; no 'Failed to load')",
        "On bead-load failures, the system returns a structured error with an error_code and correlation_id, and logs include the underlying exception/status and the bead id"
      ],
      "files_to_create": [
        "docs/debug/bead-load-failure-bd-test-1.md"
      ],
      "files_to_modify": [
        "scripts/agent-mail-helper.sh",
        "scripts/bridge/bridge-agent-loop.sh"
      ],
      "verification": [
        "Docker-first: bring up the same stack used in normal runs (e.g., docker compose up -d). Trigger the bead read operation for bd-test-1 using the exact CLI/script the system uses (e.g., ./scripts/<bead-read>.sh bd-test-1) or the UI path that loads bead metadata.",
        "Expected: bead metadata resolves (non-empty title/description/status). If you intentionally break the backend to simulate failure, you see error_code + correlation_id returned and logs show bead id + root exception/status."
      ]
    },
    {
      "id": "bd-test-2",
      "code": "pXa-01",
      "title": "Add retry-safe fallback and regression test for bead loads",
      "priority": "P1",
      "depends_on": [
        "bd-test-1"
      ],
      "how_to_think": "This bead is about hardening and preventing recurrence after the root cause for bd-test-1 is understood. Preserve idempotency on retries: repeated load attempts must not cause duplicate side effects (no duplicate mail sends, no duplicate bead creation). Keep changes additive: add a small fallback path and a regression test rather than refactoring core logic. Stop and escalate if the only viable fix requires changing the bead schema, rewriting the storage layer, or altering cross-module contracts; in that case propose a separate design bead first.",
      "acceptance_criteria": [
        "If a bead load fails transiently, the system retries safely (no duplicate state writes) and either succeeds or returns a structured failure with clear next steps",
        "A regression test covers the bd-test-2 failure mode and passes in CI/local runs"
      ],
      "files_to_create": [
        "tests/integration/bead-load-regression.test.mjs"
      ],
      "files_to_modify": [
        "scripts/agent-mail-helper.sh",
        "scripts/bridge/bridge-agent-loop.sh"
      ],
      "verification": [
        "Docker-first: run the integration test against a local stack (e.g., docker compose up -d && node tests/integration/bead-load-regression.test.mjs). If you have a test runner, wire it into npm test and run npm test -- bead-load-regression.",
        "Expected: test passes, retry behavior is bounded and idempotent, and when failure is forced the returned object includes error_code + correlation_id with no duplicate side effects (confirmed by logs and/or idempotency markers)."
      ]
    }
  ],
  "error": null
}
