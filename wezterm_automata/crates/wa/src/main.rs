//! WezTerm Automata CLI
//!
//! Terminal hypervisor for AI agent swarms running in WezTerm.

#![forbid(unsafe_code)]

use std::collections::{HashSet, VecDeque};
use std::fs;
use std::io::{IsTerminal, Write};
use std::path::{Path, PathBuf};
use std::sync::{Arc, LazyLock};
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};

use clap::{Parser, Subcommand, ValueEnum};
use wa_core::logging::{LogConfig, LogError, init_logging};
use wa_core::storage::{MigrationPlan, MigrationStatusReport};

/// Build metadata captured at compile time.
mod build_meta {
    pub const GIT_HASH: &str = env!("WA_GIT_HASH");
    pub const GIT_DIRTY: &str = env!("WA_GIT_DIRTY");
    pub const BUILD_TS: &str = env!("WA_BUILD_TS");
    pub const RUSTC_VERSION: &str = env!("WA_RUSTC_VERSION");
    pub const TARGET: &str = env!("WA_TARGET");
    pub const FEATURES: &str = env!("WA_FEATURES");

    /// Short version line: `0.1.0 (abc123def)`
    pub fn short_version() -> String {
        format!("{} ({}{})", wa_core::VERSION, GIT_HASH, GIT_DIRTY)
    }

    /// Verbose multi-line version block.
    pub fn verbose_version() -> String {
        format!(
            "\
wa {}
commit:   {}{}
built:    {}
rustc:    {}
target:   {}
features: {}",
            wa_core::VERSION,
            GIT_HASH,
            GIT_DIRTY,
            BUILD_TS,
            RUSTC_VERSION,
            TARGET,
            FEATURES,
        )
    }
}

#[cfg(feature = "mcp")]
mod mcp;

static CLAP_VERSION: LazyLock<String> = LazyLock::new(build_meta::short_version);

/// WezTerm Automata - Terminal hypervisor for AI agents
#[derive(Parser)]
#[command(name = "wa")]
#[command(author, version = CLAP_VERSION.as_str(), about, long_about = None)]
struct Cli {
    /// Increase verbosity (-v for verbose, -vv for debug)
    #[arg(short, long, global = true, action = clap::ArgAction::Count)]
    verbose: u8,

    /// Configuration file path
    #[arg(short, long, global = true)]
    config: Option<String>,

    /// Workspace root (overrides WA_WORKSPACE)
    #[arg(long, global = true, env = "WA_WORKSPACE")]
    workspace: Option<String>,

    #[command(subcommand)]
    command: Option<Box<Commands>>,
}

#[derive(Subcommand)]
enum Commands {
    /// Start the watcher daemon
    #[command(after_help = r#"EXAMPLES:
    wa watch                          Start daemon (backgrounds by default)
    wa watch --foreground             Stay in foreground for debugging
    wa watch --auto-handle            Enable automatic workflow execution
    wa watch --poll-interval 2000     Poll WezTerm every 2 seconds

SEE ALSO:
    wa stop       Stop the running watcher
    wa status     Show watcher and pane overview
    wa doctor     Check environment prerequisites"#)]
    Watch {
        /// Enable automatic workflow handling
        #[arg(long)]
        auto_handle: bool,

        /// Run in foreground (don't daemonize)
        #[arg(long)]
        foreground: bool,

        /// Discovery poll interval in milliseconds
        #[arg(long, default_value = "5000")]
        poll_interval: u64,

        /// Disable pattern detection
        #[arg(long)]
        no_patterns: bool,

        /// Run in notify-only mode (no workflows, notifications only)
        #[arg(long)]
        notify_only: bool,

        /// Notification filter (comma-separated rule_id globs)
        #[arg(long, value_delimiter = ',')]
        notify_filter: Vec<String>,

        /// Notification channels to use (comma-separated)
        #[arg(long, value_delimiter = ',', value_enum)]
        notify_via: Vec<NotifyChannel>,

        /// Enable Prometheus metrics endpoint
        #[arg(long)]
        metrics: bool,

        /// Metrics bind address (overrides config)
        #[arg(long)]
        metrics_bind: Option<String>,

        /// Metrics prefix for exported metrics
        #[arg(long)]
        metrics_prefix: Option<String>,

        /// Disable single-instance lock (DANGEROUS: may corrupt data)
        #[arg(long)]
        dangerous_disable_lock: bool,

        /// Allow metrics endpoint to bind on non-localhost addresses (DANGEROUS)
        #[arg(long)]
        dangerous_bind_any: bool,
    },

    /// Show version and build metadata
    #[command(after_help = r#"EXAMPLES:
    wa version                        Short version line
    wa version --verbose              Detailed build metadata

SEE ALSO:
    wa doctor     Check environment prerequisites"#)]
    Version {
        /// Show detailed build metadata (commit, rustc, target, features)
        #[arg(long)]
        full: bool,
    },

    /// Robot mode commands (machine-readable I/O)
    #[command(after_help = r#"EXAMPLES:
    wa robot state                    Get all panes as JSON
    wa robot get-text 3               Get pane text (machine-readable)
    wa robot send 3 "ls"              Send text via robot interface
    wa robot events --unhandled       Unhandled events as JSON
    wa robot -f json state            Force JSON output format

SEE ALSO:
    wa list       Human-readable pane listing
    wa send       Human-readable send command"#)]
    Robot {
        /// Output format for robot responses
        #[arg(long, short = 'f', value_enum)]
        format: Option<RobotOutputFormat>,

        /// Show token statistics on stderr (JSON vs TOON)
        #[arg(long)]
        stats: bool,

        #[command(subcommand)]
        command: Option<RobotCommands>,
    },

    /// Search captured output (FTS query)
    #[command(
        alias = "query",
        subcommand_precedence_over_arg = true,
        after_help = r#"EXAMPLES:
    wa search "error"                 Find lines containing "error"
    wa search "error" --pane 3        Search in specific pane
    wa search "error OR warning"      FTS5 boolean query
    wa search "error" --bookmark build
                                     Search in pane aliased as "build"
    wa search "error" -f json         Machine-readable output
    wa search fts verify              Verify FTS index health
    wa search fts rebuild             Rebuild FTS index
    wa search save errors "error OR warning"
    wa search saved list
    wa search saved run errors
    wa search saved delete errors

SEE ALSO:
    wa list       List available panes
    wa events     View detected events"#
    )]
    Search {
        #[command(subcommand)]
        command: Option<SearchCommands>,

        /// Search query (FTS5 syntax)
        #[arg(required = false)]
        query: Option<String>,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,

        /// Limit results
        #[arg(short, long, default_value = "10")]
        limit: usize,

        /// Filter by pane ID
        #[arg(long, short = 'p')]
        pane: Option<u64>,

        /// Filter by bookmark alias
        #[arg(long)]
        bookmark: Option<String>,

        /// Filter by bookmark tag
        #[arg(long = "bookmark-tag")]
        bookmark_tag: Option<String>,

        /// Only return results since this timestamp (epoch ms or ISO8601)
        #[arg(long, short = 's')]
        since: Option<i64>,

        /// Return query completion suggestions instead of running the search
        #[arg(long)]
        suggest: bool,
    },

    /// List panes and their status
    #[command(after_help = r#"EXAMPLES:
    wa list                           Show all observed and ignored panes
    wa list --json                    Machine-readable pane listing

SEE ALSO:
    wa show       Show detailed pane information
    wa status     Pane and system overview"#)]
    List {
        /// Output as JSON
        #[arg(long)]
        json: bool,
    },

    /// Pane management commands
    #[command(after_help = r#"EXAMPLES:
    wa panes priority 3 --weight 10         Prefer pane 3 during capture scheduling
    wa panes priority 3 --weight 10 --ttl-secs 600
    wa panes priority 3 --clear
    wa panes bookmark add 3 --alias build   Bookmark pane 3 as "build"
    wa panes bookmark list                  List all bookmarks
    wa panes bookmark remove build          Remove a bookmark

NOTES:
  - Lower numbers indicate higher priority (consistent with config `ingest.priorities`)
  - Priority overrides are runtime-only (stored in the watcher process)
  - Bookmarks persist across restarts (stored in the DB)"#)]
    Panes {
        #[command(subcommand)]
        command: PanesCommands,
    },

    /// Show detailed pane information
    #[command(after_help = r#"EXAMPLES:
    wa show 3                         Show details for pane 3
    wa show 3 --output                Include recent output text

SEE ALSO:
    wa list       List all panes
    wa search     Search pane output"#)]
    Show {
        /// Pane ID to show
        pane_id: u64,

        /// Include recent output
        #[arg(long)]
        output: bool,
    },

    /// Send text to a pane
    #[command(after_help = r#"EXAMPLES:
    wa send 3 "hello"                 Send text to pane 3
    wa send 3 "ls" --wait-for "\\$"   Send and wait for prompt
    wa send 3 "exit" --dry-run        Preview without executing
    wa send 3 "cmd" --no-newline      Send without trailing newline

SEE ALSO:
    wa approve    Approve a denied action
    wa why        Explain send denials"#)]
    Send {
        /// Target pane ID
        pane_id: u64,

        /// Text to send
        text: String,

        /// Send character by character (no paste mode)
        #[arg(long)]
        no_paste: bool,

        /// Do not append a trailing newline
        #[arg(long)]
        no_newline: bool,

        /// Preview what would happen without executing
        #[arg(long)]
        dry_run: bool,

        /// Verify by waiting for a pattern after sending
        #[arg(long)]
        wait_for: Option<String>,

        /// Timeout for wait-for verification (seconds)
        #[arg(long, default_value = "30")]
        timeout_secs: u64,

        /// Treat wait-for pattern as regex
        #[arg(long)]
        wait_for_regex: bool,
    },

    /// Get text from a pane
    #[command(after_help = r#"EXAMPLES:
    wa get-text 3                     Get recent text from pane 3
    wa get-text 3 --escapes           Include ANSI escape sequences

SEE ALSO:
    wa search     Search across all panes
    wa show       Show pane details"#)]
    GetText {
        /// Target pane ID
        pane_id: u64,

        /// Include escape sequences
        #[arg(long)]
        escapes: bool,
    },

    /// Workflow commands
    #[command(after_help = r#"EXAMPLES:
    wa workflow list                  List workflow executions
    wa workflow status <id>           Show specific execution details
    wa workflow run <name>            Manually trigger a workflow

SEE ALSO:
    wa events     Detection events that trigger workflows
    wa audit      Audit trail of workflow actions"#)]
    Workflow {
        #[command(subcommand)]
        command: WorkflowCommands,
    },

    /// Show system status and pane overview
    #[command(after_help = r#"EXAMPLES:
    wa status                         System and pane overview
    wa status -f json                 Machine-readable status
    wa status --pane-id 3             Status for specific pane
    wa status --bookmark build        Status for pane aliased as "build"
    wa status --health                Health check only

SEE ALSO:
    wa list       Detailed pane listing
    wa doctor     Environment diagnostics"#)]
    Status {
        /// Output health check only (JSON)
        #[arg(long)]
        health: bool,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,

        /// Filter by domain (glob pattern)
        #[arg(long, short = 'd')]
        domain: Option<String>,

        /// Filter by agent type
        #[arg(long, short = 'a')]
        agent: Option<String>,

        /// Filter by pane ID
        #[arg(long, short = 'p')]
        pane_id: Option<u64>,

        /// Filter by bookmark alias
        #[arg(long)]
        bookmark: Option<String>,

        /// Filter by bookmark tag
        #[arg(long = "bookmark-tag")]
        bookmark_tag: Option<String>,
    },

    /// Show recent detection events
    #[command(after_help = r#"EXAMPLES:
    wa events                         Recent events (last 20)
    wa events --pane-id 3             Events for specific pane
    wa events --unhandled             Only unhandled events
    wa events --rule-id codex.usage   Filter by detection rule
    wa events annotate 123 --note "Investigating"
    wa events triage 123 --state investigating
    wa events label 123 --add urgent

SEE ALSO:
    wa why        Explain event decisions
    wa rules      List detection rules"#)]
    Events {
        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,

        /// Maximum number of events to return
        #[arg(long, short = 'l', default_value = "20")]
        limit: usize,

        /// Filter by pane ID
        #[arg(long, short = 'p')]
        pane_id: Option<u64>,

        /// Filter by rule ID (exact match)
        #[arg(long, short = 'r')]
        rule_id: Option<String>,

        /// Filter by event type (e.g., "compaction_warning")
        #[arg(long, short = 't')]
        event_type: Option<String>,

        /// Only return unhandled events
        #[arg(long, short = 'u')]
        unhandled: bool,

        #[command(subcommand)]
        command: Option<EventsCommands>,
    },

    /// Ingest external events (e.g., WezTerm user-var signals from shell hooks)
    ///
    /// Note: --from-status was removed in v0.2.0 (Lua performance optimization).
    /// Alt-screen detection is now handled via escape sequence parsing.
    #[command(after_help = r#"EXAMPLES:
    wa event --from-uservar --pane 3 --name wa_event --value <base64>
                                      Ingest a user-var signal from pane 3

SEE ALSO:
    wa events     View detected events
    wa watch      Start the watcher daemon"#)]
    Event {
        /// Event source is a WezTerm user-var change (currently the only supported source)
        #[arg(long)]
        from_uservar: bool,

        /// Pane ID that emitted the event
        #[arg(long)]
        pane: u64,

        /// User-var name (e.g., "wa_event") - required for --from-uservar
        #[arg(long, required_if_eq("from_uservar", "true"))]
        name: Option<String>,

        /// Raw user-var value (typically base64-encoded JSON) - required for --from-uservar
        #[arg(long, required_if_eq("from_uservar", "true"))]
        value: Option<String>,
    },

    /// Explain decisions and workflows using built-in templates or recent audit trail
    #[command(after_help = r#"EXAMPLES:
    wa why deny.alt_screen            Explain alt-screen denial
    wa why --list                     List all explanation templates
    wa why --recent                   Show recent deny decisions
    wa why --recent --pane 3          Recent denials for pane 3
    wa why --recent -f json           Machine-readable decision log

SEE ALSO:
    wa audit      Full audit trail
    wa rules      Detection rule definitions
    wa approve    Approve denied actions"#)]
    Why {
        /// Template ID to explain (e.g., "deny.alt_screen"), or decision type
        /// when --recent is used (e.g., "denied", "require_approval")
        template_id: Option<String>,

        /// Filter templates by category prefix (deny/workflow/event)
        #[arg(long)]
        category: Option<String>,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,

        /// List available templates
        #[arg(long)]
        list: bool,

        /// Query recent actual decisions from the audit trail
        #[arg(long)]
        recent: bool,

        /// Filter by pane ID (used with --recent)
        #[arg(long)]
        pane: Option<u64>,

        /// Show a specific audit decision by record ID (used with --recent)
        #[arg(long)]
        decision_id: Option<i64>,

        /// Maximum number of recent decisions to show (default: 5)
        #[arg(long, default_value = "5")]
        limit: usize,
    },

    /// Stop a running watcher in the current workspace
    #[command(after_help = r#"EXAMPLES:
    wa stop                           Graceful shutdown (SIGTERM)
    wa stop --force                   SIGKILL after timeout
    wa stop --timeout 10              Wait 10s before giving up

SEE ALSO:
    wa watch      Start the watcher daemon
    wa status     Check if watcher is running"#)]
    Stop {
        /// Force kill with SIGKILL if graceful shutdown times out
        #[arg(long)]
        force: bool,

        /// Timeout in seconds for graceful shutdown before giving up (or escalating with --force)
        #[arg(long, default_value = "5")]
        timeout: u64,
    },

    /// Prepare an action plan preview for commit
    #[command(after_help = r#"EXAMPLES:
    wa prepare send --pane-id 3 "ls"
    wa prepare workflow run handle_compaction --pane-id 3

SEE ALSO:
    wa commit     Execute a prepared plan
    wa approve    Approve denied actions"#)]
    Prepare {
        #[command(subcommand)]
        command: PrepareCommands,
    },

    /// Commit a previously prepared plan
    #[command(after_help = r#"EXAMPLES:
    wa commit plan:abcd1234 --text "ls"
    wa commit plan:abcd1234 --approval-code ABC12345 --text "rm -rf /tmp/test"

SEE ALSO:
    wa prepare    Prepare plan preview
    wa approve    Approve denied actions"#)]
    Commit {
        /// Plan ID (from wa prepare)
        plan_id: String,

        /// Action text (required for send_text plans)
        #[arg(long)]
        text: Option<String>,

        /// Read action text from a file (required for send_text plans)
        #[arg(long)]
        text_file: Option<PathBuf>,

        /// Approval code to consume during commit (if required)
        #[arg(long)]
        approval_code: Option<String>,
    },

    /// Submit an approval code for a pending action
    #[command(after_help = r#"EXAMPLES:
    wa approve AB12CD34              Submit an approval code
    wa approve AB12CD34 --pane 3     Validate against specific pane
    wa approve AB12CD34 --dry-run    Check status without consuming

SEE ALSO:
    wa why        Explain why an action was denied
    wa audit      Review action history"#)]
    Approve {
        /// The approval code (8-character alphanumeric)
        code: String,

        /// Target pane ID for fingerprint validation (optional)
        #[arg(long)]
        pane: Option<u64>,

        /// Expected action fingerprint (optional)
        #[arg(long)]
        fingerprint: Option<String>,

        /// Check approval status without consuming
        #[arg(long)]
        dry_run: bool,
    },

    /// Show audit trail (recent actions, policy decisions)
    #[command(after_help = r#"EXAMPLES:
    wa audit                          Recent audit records (last 20)
    wa audit -l 50                    Show more records
    wa audit -p 3                     Filter by pane
    wa audit -d deny                  Only denied decisions
    wa audit -k send_text             Only send_text actions
    wa audit -f json                  Machine-readable output
    wa audit tail --follow            Stream audit records as JSONL

SEE ALSO:
    wa why        Explain specific decisions
    wa events     Detection events
    wa approve    Approve denied actions"#)]
    Audit {
        #[command(subcommand)]
        command: Option<AuditCommands>,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,

        /// Maximum number of records to return
        #[arg(long, short = 'l', default_value = "20", global = true)]
        limit: usize,

        /// Filter by pane ID
        #[arg(long = "pane", short = 'p', global = true, visible_alias = "pane-id")]
        pane_id: Option<u64>,

        /// Filter by actor kind (human, robot, mcp, workflow)
        #[arg(long, short = 'a', global = true)]
        actor: Option<String>,

        /// Filter by correlation id (plan hash for prepare/commit chains)
        #[arg(long, visible_alias = "plan-hash", global = true)]
        correlation_id: Option<String>,

        /// Filter by action kind (send_text, workflow_run, approve_allow_once, etc.)
        #[arg(long, short = 'k', global = true)]
        action: Option<String>,

        /// Filter by policy decision (allow, deny, require_approval)
        #[arg(long, short = 'd', global = true)]
        decision: Option<String>,

        /// Filter by result (success, denied, failed, timeout)
        #[arg(long, short = 'r', global = true)]
        result: Option<String>,

        /// Only show records since this timestamp (epoch ms)
        #[arg(long, short = 's', global = true)]
        since: Option<i64>,
    },

    /// Review action history (audit + undo + workflow context)
    #[command(after_help = r#"EXAMPLES:
    wa history
    wa history --pane 0 --limit 20
    wa history --workflow wf-abc123
    wa history --undoable
    wa history --since "1 hour ago"
    wa history --since "2026-01-18T12:00:00" --until "2026-01-18T14:00:00"
    wa history --export json > history.json
    wa history --export csv > history.csv

SEE ALSO:
    wa audit      Audit trail (policy decisions)
    wa workflow   Workflow status and controls"#)]
    History {
        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,

        /// Export format: json or csv (overrides --format)
        #[arg(long)]
        export: Option<String>,

        /// Maximum number of records to return
        #[arg(long, short = 'l', default_value = "50", global = true)]
        limit: usize,

        /// Filter by pane ID
        #[arg(long = "pane", short = 'p', global = true, visible_alias = "pane-id")]
        pane_id: Option<u64>,

        /// Filter by actor kind (human, robot, mcp, workflow)
        #[arg(long, short = 'a', global = true)]
        actor: Option<String>,

        /// Filter by workflow execution ID (tree view)
        #[arg(long)]
        workflow: Option<String>,

        /// Filter by action kind (send_text, workflow_step, workflow_start, etc.)
        #[arg(long, short = 'k', global = true)]
        action: Option<String>,

        /// Filter by policy decision (allow, deny, require_approval)
        #[arg(long, short = 'd', global = true)]
        decision: Option<String>,

        /// Filter by result (success, denied, failed, timeout)
        #[arg(long, short = 'r', global = true)]
        result: Option<String>,

        /// Only show undoable actions
        #[arg(long)]
        undoable: bool,

        /// Only show records since this timestamp (epoch ms, RFC3339, or "1 hour ago")
        #[arg(long)]
        since: Option<String>,

        /// Only show records until this timestamp (epoch ms, RFC3339, or "1 hour ago")
        #[arg(long)]
        until: Option<String>,
    },

    /// Undo supported actions with confirmation
    #[command(after_help = r#"EXAMPLES:
    wa undo --list
    wa undo 1234
    wa undo --all-in-workflow wf-abc123 --yes
    wa undo 1234 --format json --yes

SEE ALSO:
    wa history     Review undoable actions and workflow context
    wa workflow    Workflow status and controls"#)]
    Undo {
        /// Action ID to undo
        action_id: Option<i64>,

        /// List currently undoable actions
        #[arg(long)]
        list: bool,

        /// Undo all currently undoable actions in a workflow execution
        #[arg(long)]
        all_in_workflow: Option<String>,

        /// Skip confirmation prompt
        #[arg(long)]
        yes: bool,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,

        /// Maximum number of actions returned by --list
        #[arg(long, short = 'l', default_value = "50")]
        limit: usize,
    },

    /// Notification utilities (test channels)
    #[command(after_help = r#"EXAMPLES:
    wa notify test --channel desktop
    wa notify test --channel ops --format json

SEE ALSO:
    wa events     Detection events
    wa config     Configuration management"#)]
    Notify {
        #[command(subcommand)]
        command: NotifyCommands,
    },

    /// Mute/unmute noisy events
    #[command(after_help = r#"EXAMPLES:
    wa mute add evt:abc --for 1h       Mute event key for 1 hour
    wa mute add evt:abc                Mute permanently
    wa mute remove evt:abc             Unmute an event key
    wa mute list                       List active mutes
    wa mute list --format json         Machine-readable output

SEE ALSO:
    wa events     View detected events
    wa notify     Notification management"#)]
    Mute {
        #[command(subcommand)]
        command: MuteCommands,
    },

    /// Secret scanning utilities
    #[command(after_help = r#"EXAMPLES:
    wa secrets scan                    Scan stored output and store a report
    wa secrets scan --pane 3           Scope scan to a single pane
    wa secrets report                  Show latest report for scope
    wa secrets report --format json    Machine-readable output

SEE ALSO:
    wa export     Export redacted data
    wa audit      Review action history"#)]
    Secrets {
        #[command(subcommand)]
        command: SecretsCommands,
    },

    /// Run diagnostics
    #[command(after_help = r#"EXAMPLES:
    wa doctor                         Run all environment checks
    wa doctor --json                  Output as JSON (for automation)
    wa doctor --circuits              Show circuit breaker status

SEE ALSO:
    wa status     System and pane overview
    wa config     Configuration management"#)]
    Doctor {
        /// Show circuit breaker status
        #[arg(long)]
        circuits: bool,
        /// Output as JSON (for automation)
        #[arg(long)]
        json: bool,
    },

    /// Generate a diagnostic bundle for bug reports
    #[command(after_help = r#"EXAMPLES:
    wa diag bundle                        Generate diagnostic bundle
    wa diag bundle --output /tmp/diag     Write bundle to specific directory
    wa diag bundle --force                Overwrite existing output directory
    wa diag bundle --events 200           Include more recent events

SEE ALSO:
    wa doctor     Run diagnostics
    wa status     System and pane overview"#)]
    Diag {
        #[command(subcommand)]
        command: DiagCommands,
    },

    /// Export or replay incident bundles
    #[command(after_help = r#"EXAMPLES:
    wa reproduce export                      Export latest crash as incident bundle
    wa reproduce export --kind manual        Export a manual incident bundle
    wa reproduce export --out /tmp/bundle    Export to specific directory
    wa reproduce replay /path/to/bundle      Replay a bundle for deterministic analysis
    wa reproduce replay /path/to/bundle --mode policy   Re-run policy evaluation
    wa reproduce replay /path/to/bundle --mode rules    Re-run rule/pattern matching

SEE ALSO:
    wa doctor     Run diagnostics
    wa status     System and pane overview"#)]
    Reproduce {
        #[command(subcommand)]
        command: ReproduceCommands,
    },

    /// Setup helpers
    #[command(after_help = r#"EXAMPLES:
    wa setup --list-hosts             List SSH hosts from ~/.ssh/config
    wa setup shell-hooks              Install shell integration hooks
    wa setup shell-hooks --apply      Apply hook changes
    wa setup lua-domain               Generate WezTerm SSH domain Lua
    wa setup --dry-run                Preview all setup changes

SEE ALSO:
    wa config     Configuration management
    wa doctor     Environment diagnostics"#)]
    Setup {
        /// List SSH hosts from ~/.ssh/config
        #[arg(long = "list-hosts")]
        list_hosts: bool,

        /// Apply setup changes automatically (non-destructive)
        #[arg(long, global = true)]
        apply: bool,

        /// Show what would change without modifying files
        #[arg(long, global = true)]
        dry_run: bool,

        #[command(subcommand)]
        command: Option<SetupCommands>,
    },

    /// Configuration management commands
    #[command(after_help = r#"EXAMPLES:
    wa config show                    Show current configuration
    wa config show --effective --json Machine-readable effective config
    wa config init                    Create default config file
    wa config validate                Check config for errors
    wa config profile diff incident   Preview profile changes
    wa config profile apply incident  Apply a profile overlay
    wa config profile list            List available profiles
    wa config profile create incident --from current

SEE ALSO:
    wa setup      Setup helpers
    wa doctor     Environment diagnostics"#)]
    Config {
        #[command(subcommand)]
        command: ConfigCommands,
    },

    /// Interactive tutorial and learning system
    #[command(after_help = r#"EXAMPLES:
    wa learn                          Show track selection / resume
    wa learn basics                   Start or resume the Basics track
    wa learn basics --complete        Mark current exercise as done
    wa learn basics --skip            Skip current exercise
    wa learn --status                 Show completion summary
    wa learn --achievements           Show achievement collection
    wa learn --reset                  Clear all progress

SEE ALSO:
    wa doctor     Check environment prerequisites
    wa status     View system status"#)]
    Learn {
        /// Track to start or resume (basics, events, workflows)
        track: Option<String>,

        /// Show completion summary
        #[arg(long)]
        status: bool,

        /// Show achievement collection
        #[arg(long)]
        achievements: bool,

        /// Clear all progress
        #[arg(long)]
        reset: bool,

        /// Mark current exercise as completed
        #[arg(long)]
        complete: bool,

        /// Skip current exercise
        #[arg(long)]
        skip: bool,

        /// Output as JSON
        #[arg(long)]
        json: bool,
    },

    /// Database maintenance commands
    #[command(after_help = r#"EXAMPLES:
    wa db stats                       Show database size and record counts
    wa db migrate                     Run pending migrations
    wa db migrate --status            Check migration status

SEE ALSO:
    wa backup     Backup and restore
    wa doctor     Environment diagnostics"#)]
    Db {
        #[command(subcommand)]
        command: DbCommands,
    },

    /// Backup and restore commands
    #[command(after_help = r#"EXAMPLES:
    wa backup create                  Create a database backup
    wa backup list                    List available backups
    wa backup restore <path>          Restore from a backup file

SEE ALSO:
    wa db         Database maintenance
    wa config     Configuration management"#)]
    Backup {
        #[command(subcommand)]
        command: BackupCommands,
    },

    /// Sync commands (feature-gated)
    #[cfg(feature = "sync")]
    #[command(after_help = r#"EXAMPLES:
    wa sync status                    Show sync targets and defaults
    wa sync push --dry-run            Preview a push plan
    wa sync pull --apply --yes        Apply a pull plan (confirmation required)

SEE ALSO:
    wa config     Configuration management
    wa backup     Export snapshots for sync"#)]
    Sync {
        #[command(subcommand)]
        command: SyncCommands,
    },

    /// Pattern detection rules (list, test, show)
    #[command(after_help = r#"EXAMPLES:
    wa rules list                     List all detection rules
    wa rules show codex.usage         Show a specific rule
    wa rules test "Usage limit"       Test text against rules
    wa rules profile list             List ruleset profiles
    wa rules profile apply incident   Apply a ruleset profile

SEE ALSO:
    wa events     Detection events
    wa why        Explain rule decisions"#)]
    Rules {
        #[command(subcommand)]
        command: RulesCommands,
    },

    /// Extension management (list, install, remove, validate, info)
    #[command(after_help = r#"EXAMPLES:
    wa ext list                       List all extensions
    wa ext install ./my-patterns.toml Install from local file
    wa ext remove my-patterns         Remove an extension
    wa ext validate ./pack.toml       Validate extension file
    wa ext info codex                 Show extension details

SEE ALSO:
    wa rules      Pattern detection rules
    wa config     Configuration"#)]
    Ext {
        #[command(subcommand)]
        command: ExtCommands,
    },

    /// Export session recordings to Asciinema or HTML
    #[command(after_help = r#"EXAMPLES:
    wa record export session.war                        Export to Asciinema cast
    wa record export session.war --format html -o out.html  Export to HTML player
    wa record export session.war --no-redact            Keep secrets in output
    wa record export session.war --title "Demo Session" Set recording title
    wa record export session.war --redact-pattern "TOKEN_\w+" Add custom redaction

SEE ALSO:
    wa reproduce    Incident bundles
    wa export       Data export to JSONL"#)]
    Record {
        #[command(subcommand)]
        command: RecordCommands,
    },

    /// Replay a session recording
    #[command(after_help = r#"EXAMPLES:
    wa replay session.war                       Replay at normal speed
    wa replay session.war --speed 4             Replay at 4x speed
    wa replay session.war --from 1m30s          Start from 1m30s
    wa replay session.war --events-only         Show only event annotations

SEE ALSO:
    wa record list      List available recordings
    wa record export    Export to HTML or Asciinema"#)]
    Replay {
        /// Path to the .war recording file
        file: PathBuf,

        /// Playback speed multiplier (0.5, 1, 2, 4)
        #[arg(long, default_value = "1")]
        speed: f64,

        /// Start playback from this timestamp (e.g., "1m30s", "90s", "5000" for ms)
        #[arg(long)]
        from: Option<String>,

        /// Show only event annotations (skip terminal output)
        #[arg(long)]
        events_only: bool,

        /// Output as JSON (events and metadata)
        #[arg(long)]
        json: bool,
    },

    /// Reserve a pane for exclusive use
    #[command(after_help = r#"EXAMPLES:
    wa reserve 3 --owner-id agent-1   Reserve pane 3 for agent-1
    wa reserve 3 --ttl 3600           Reserve for 1 hour
    wa reserve 3 --reason "migration" Add a reason

SEE ALSO:
    wa reservations   List active reservations
    wa status         Show pane overview"#)]
    Reserve {
        /// Pane ID to reserve
        pane_id: u64,

        /// TTL in seconds (default: 1800 = 30 minutes)
        #[arg(long, default_value = "1800")]
        ttl: u64,

        /// Owner kind (workflow, agent, manual)
        #[arg(long, default_value = "manual")]
        owner_kind: String,

        /// Owner identifier
        #[arg(long, default_value = "cli-user")]
        owner_id: String,

        /// Reason for reservation
        #[arg(long)]
        reason: Option<String>,

        /// Output as JSON
        #[arg(long)]
        json: bool,
    },

    /// List active pane reservations
    #[command(after_help = r#"EXAMPLES:
    wa reservations               Show active reservations
    wa reservations --json        Output as JSON

SEE ALSO:
    wa reserve    Reserve a pane
    wa status     Show pane overview"#)]
    Reservations {
        /// Output as JSON
        #[arg(long)]
        json: bool,
    },

    /// Browser authentication testing and profile management
    #[command(after_help = r#"EXAMPLES:
    wa auth test openai --account work      Test OpenAI device auth
    wa auth test openai --headful           Debug mode (visible browser)
    wa auth status openai                   Check profile health

SEE ALSO:
    wa doctor     System diagnostics
    wa status     Pane overview"#)]
    Auth {
        #[command(subcommand)]
        command: AuthCommands,
    },

    /// View and manage API accounts (usage, selection, refresh)
    #[command(after_help = r#"EXAMPLES:
    wa accounts                           List accounts (default: openai)
    wa accounts --service openai          List OpenAI accounts
    wa accounts --pick                    Show which account would be selected next
    wa accounts -f json                   Machine-readable output
    wa accounts refresh                   Refresh usage data from caut

SEE ALSO:
    wa auth       Browser authentication
    wa doctor     System diagnostics"#)]
    Accounts {
        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,

        /// Service filter (default: "openai")
        #[arg(long, default_value = "openai")]
        service: String,

        /// Show pick preview (which account would be selected next)
        #[arg(long)]
        pick: bool,

        #[command(subcommand)]
        command: Option<AccountsCommands>,
    },

    /// Export data to JSONL/NDJSON (segments, events, workflows, etc.)
    #[command(after_help = r#"EXAMPLES:
    wa export segments                    Export all output segments
    wa export events --pane-id 3          Export events for pane 3
    wa export audit --since 1706000000   Export audit since timestamp
    wa export audit --actor workflow      Export workflow-initiated audit actions
    wa export audit --action auth_required Export auth-related audit entries
    wa export workflows --limit 50        Export last 50 workflows
    wa export sessions --no-redact        Export sessions without redaction (WARNING)
    wa export reservations --pretty       Pretty-print JSON output

SUPPORTED KINDS:
    segments      Output capture segments (text + metadata)
    gaps          Output discontinuities
    events        Pattern detections
    workflows     Workflow executions + step logs
    sessions      Agent session records
    audit         Audit trail (policy decisions)
    reservations  Pane reservations (active + historical)

SAFETY:
    Redaction is ON by default.  All text that matches secret patterns
    (API keys, tokens, passwords) is replaced with [REDACTED].
    Use --no-redact to export raw data (a warning is printed to stderr).

SEE ALSO:
    wa events     Human-readable event listing
    wa audit      Human-readable audit trail
    wa search     Full-text search"#)]
    Export {
        /// Data kind to export
        kind: String,

        /// Filter by pane ID
        #[arg(long)]
        pane_id: Option<u64>,

        /// Filter: only records since this timestamp (epoch ms)
        #[arg(long)]
        since: Option<i64>,

        /// Filter: only records until this timestamp (epoch ms)
        #[arg(long)]
        until: Option<i64>,

        /// Maximum number of records to export (default: 10000)
        #[arg(long, short = 'l')]
        limit: Option<usize>,

        /// Filter by actor kind (audit export only, e.g. "workflow", "operator")
        #[arg(long)]
        actor: Option<String>,

        /// Filter by action kind (audit export only, e.g. "auth_required", "send_text")
        #[arg(long)]
        action: Option<String>,

        /// Disable secret redaction (WARNING: may expose sensitive data)
        #[arg(long)]
        no_redact: bool,

        /// Pretty-print JSON (multi-line, indented)
        #[arg(long)]
        pretty: bool,

        /// Write output to file instead of stdout
        #[arg(long, short = 'o')]
        output: Option<String>,
    },

    /// Show prioritized issues needing attention
    #[command(after_help = r#"EXAMPLES:
    wa triage                         Prioritized triage overview
    wa triage -f json                 Machine-readable output
    wa triage --severity error        Only show errors
    wa triage --only events           Only unhandled events

SEE ALSO:
    wa doctor     System health diagnostics
    wa events     Raw event listing
    wa status     Pane and system overview"#)]
    Triage {
        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,

        /// Minimum severity to show (error, warning, info)
        #[arg(long)]
        severity: Option<String>,

        /// Only show a specific section (health, crashes, events, workflows)
        #[arg(long)]
        only: Option<String>,

        /// Show additional detail for each item
        #[arg(long = "details")]
        details: bool,
    },

    /// Start the web server (requires --features web)
    #[cfg(feature = "web")]
    #[command(after_help = r#"EXAMPLES:
    wa web                            Start web server on 127.0.0.1:8000
    wa web --port 0                   Bind to an ephemeral port (tests)

SEE ALSO:
    wa status     CLI status overview
    wa triage     Operator dashboard"#)]
    Web {
        /// Port to bind on localhost (0 for ephemeral)
        #[arg(long, default_value = "8000")]
        port: u16,
    },

    /// Launch the interactive TUI (requires --features tui or --features ftui)
    #[cfg(any(feature = "tui", feature = "ftui"))]
    #[command(after_help = r#"EXAMPLES:
    wa tui                            Launch interactive dashboard
    wa tui --debug                    Enable debug overlay
    wa tui --refresh 2                Refresh every 2 seconds

SEE ALSO:
    wa status     CLI status overview
    wa list       List panes"#)]
    Tui {
        /// Enable debug mode
        #[arg(long)]
        debug: bool,

        /// Refresh interval in seconds
        #[arg(long, default_value = "5")]
        refresh: u64,
    },

    /// MCP server commands (Model Context Protocol)
    #[cfg(feature = "mcp")]
    #[command(after_help = r#"EXAMPLES:
    wa mcp serve                      Start MCP server over stdio

SEE ALSO:
    wa robot     Machine-readable CLI surface (parity target)"#)]
    Mcp {
        #[command(subcommand)]
        command: McpCommands,
    },

    /// Usage analytics: costs, tokens, rate limits, and trends
    #[command(after_help = r#"EXAMPLES:
    wa analytics                      Summary of last 7 days
    wa analytics --period 30d         Summary of last 30 days
    wa analytics daily                Daily breakdown table
    wa analytics by-agent             Per-agent breakdown
    wa analytics export --format csv  Export raw metrics as CSV
    wa analytics export --format json Export raw metrics as JSON

SEE ALSO:
    wa events     View detected events
    wa status     Show watcher overview"#)]
    Analytics {
        #[command(subcommand)]
        command: Option<AnalyticsCommands>,

        /// Time period: 1d, 7d, 30d, 90d (default: 7d)
        #[arg(long, default_value = "7d")]
        period: String,

        /// Output format: auto, plain, json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },

    /// Simulation mode: run wa with a mock WezTerm driven by YAML scenarios
    #[command(after_help = r#"EXAMPLES:
    wa simulate run scenario.yaml        Run a scenario file
    wa simulate run scenario.yaml -s 4   Run at 4x speed
    wa simulate list                     List built-in scenarios
    wa simulate validate scenario.yaml   Check scenario syntax

SEE ALSO:
    wa demo       Interactive demo mode
    wa record     Session recording"#)]
    Simulate {
        #[command(subcommand)]
        command: SimulateCommands,
    },

    /// Display a unified event timeline with cross-pane correlations
    #[command(after_help = r#"EXAMPLES:
    wa timeline                       Recent events (last 30m)
    wa timeline --last 2h             Events from the last 2 hours
    wa timeline --pane 3              Filter to pane 3
    wa timeline --type session.started  Filter by event type
    wa timeline -f json               Machine-readable output
    wa timeline -vv                   Show full correlation reasoning

SEE ALSO:
    wa events     List detection events
    wa status     Pane and system overview"#)]
    Timeline {
        /// Time range to display (e.g., "30m", "2h", "1d")
        #[arg(long, default_value = "30m")]
        last: String,

        /// Filter to specific pane ID(s) (comma-separated)
        #[arg(long, short = 'p', value_delimiter = ',')]
        pane: Vec<u64>,

        /// Filter to specific event type(s) (comma-separated)
        #[arg(long, short = 't', value_delimiter = ',')]
        r#type: Vec<String>,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,

        /// Maximum events to display
        #[arg(long, short = 'l', default_value = "100")]
        limit: usize,
    },

    /// Interactive demo mode for presentations
    #[command(after_help = r#"EXAMPLES:
    wa demo                        List available demos
    wa demo quickstart             Run quickstart demo
    wa demo quickstart --speed 2   Run at 2x speed
    wa demo quickstart --narrate   Show explanatory text

SEE ALSO:
    wa simulate   Run simulation scenarios
    wa learn      Interactive tutorial"#)]
    Demo {
        /// Demo name to run (omit to list available demos)
        name: Option<String>,

        /// Playback speed multiplier
        #[arg(long, default_value = "1")]
        speed: f64,

        /// Show explanatory narration text
        #[arg(long)]
        narrate: bool,

        /// Output as JSON
        #[arg(long)]
        json: bool,
    },
}

#[derive(Subcommand)]
enum AnalyticsCommands {
    /// Daily metrics breakdown
    Daily,
    /// Per-agent breakdown
    ByAgent,
    /// Export raw metrics
    Export {
        /// Export format: csv or json
        #[arg(long, short = 'f', default_value = "json")]
        format: String,
        /// Output file path (defaults to stdout)
        #[arg(long, short = 'o')]
        output: Option<String>,
    },
}

#[derive(Subcommand)]
enum SimulateCommands {
    /// Run a simulation scenario from a YAML file
    Run {
        /// Path to scenario YAML file
        scenario: PathBuf,

        /// Playback speed multiplier (e.g., 0.5, 1, 2, 4)
        #[arg(long, short = 's', default_value = "1")]
        speed: f64,

        /// Output as JSON (events and state changes)
        #[arg(long)]
        json: bool,
    },
    /// List available built-in scenarios
    List,
    /// Validate a scenario YAML file without running it
    Validate {
        /// Path to scenario YAML file
        scenario: PathBuf,

        /// Output as JSON
        #[arg(long)]
        json: bool,
    },
}

#[derive(Subcommand)]
enum PanesCommands {
    /// Set/clear a runtime pane capture priority override (watcher only)
    Priority {
        /// Pane ID to modify
        pane_id: u64,

        /// Priority override value (lower = higher priority)
        #[arg(long, alias = "priority")]
        weight: Option<u32>,

        /// TTL for the override (seconds). 0 = until cleared.
        #[arg(long, default_value = "3600")]
        ttl_secs: u64,

        /// Clear any existing override
        #[arg(long)]
        clear: bool,

        /// Output raw IPC JSON response
        #[arg(long)]
        json: bool,
    },

    /// Manage pane bookmarks (add, list, remove aliases)
    Bookmark {
        #[command(subcommand)]
        action: BookmarkAction,
    },
}

#[derive(Subcommand)]
enum BookmarkAction {
    /// Add a bookmark for a pane
    Add {
        /// Pane ID to bookmark
        pane_id: u64,

        /// Unique alias for this bookmark
        #[arg(long)]
        alias: String,

        /// Optional comma-separated tags
        #[arg(long)]
        tags: Option<String>,

        /// Optional description
        #[arg(long)]
        description: Option<String>,

        /// Output as JSON
        #[arg(long)]
        json: bool,
    },

    /// List all bookmarks
    List {
        /// Filter by tag
        #[arg(long)]
        tag: Option<String>,

        /// Output as JSON
        #[arg(long)]
        json: bool,
    },

    /// Remove a bookmark by alias
    Remove {
        /// Alias of the bookmark to remove
        alias: String,

        /// Output as JSON
        #[arg(long)]
        json: bool,
    },
}

#[derive(Subcommand)]
enum AuditCommands {
    /// Stream audit log as JSONL
    #[command(after_help = r#"EXAMPLES:
    wa audit tail --follow            Stream audit records as JSONL
    wa audit tail --follow -l 100     Stream with larger batches
    wa audit -s 1706000000 tail       Stream records since timestamp"#)]
    Tail {
        /// Continue streaming and poll for new records
        #[arg(long)]
        follow: bool,

        /// Poll interval while following (milliseconds)
        #[arg(long, default_value = "1000")]
        poll_interval_ms: u64,
    },
}

#[derive(Subcommand)]
enum NotifyCommands {
    /// Send a test notification to a configured channel
    #[command(after_help = r#"EXAMPLES:
    wa notify test --channel desktop
    wa notify test --channel ops --format json

NOTES:
    Channel names match [notifications.webhooks].name or "desktop"."#)]
    Test {
        /// Channel name (webhook name or "desktop")
        #[arg(long)]
        channel: String,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },
}

#[derive(Subcommand)]
enum MuteCommands {
    /// Mute an event identity key (suppress notifications)
    Add {
        /// Event identity key to mute (use `wa events --format json` to find keys)
        identity_key: String,

        /// Duration to mute (e.g., "1h", "30m", "7d"). Omit for permanent mute.
        #[arg(long, value_name = "DURATION")]
        r#for: Option<String>,

        /// Scope: workspace (default) or global
        #[arg(long, default_value = "workspace")]
        scope: String,

        /// Reason for muting
        #[arg(long)]
        reason: Option<String>,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },

    /// Unmute an event identity key
    Remove {
        /// Event identity key to unmute
        identity_key: String,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },

    /// List active mutes
    List {
        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },
}

#[derive(Subcommand)]
enum EventsCommands {
    /// Set or clear the note on an event
    #[command(after_help = r#"EXAMPLES:
    wa events annotate 123 --note "Investigating"
    wa events annotate 123 --clear

NOTES:
    Note text is redacted before being persisted."#)]
    Annotate {
        /// Event ID to annotate
        event_id: i64,

        /// Note text to set
        #[arg(long)]
        note: Option<String>,

        /// Clear the note
        #[arg(long)]
        clear: bool,

        /// Actor identifier to record (optional)
        #[arg(long)]
        by: Option<String>,
    },

    /// Set or clear the triage state for an event
    #[command(after_help = r#"EXAMPLES:
    wa events triage 123 --state investigating
    wa events triage 123 --clear"#)]
    Triage {
        /// Event ID to triage
        event_id: i64,

        /// Triage state to set (string, exact-match)
        #[arg(long)]
        state: Option<String>,

        /// Clear the triage state
        #[arg(long)]
        clear: bool,

        /// Actor identifier to record (optional)
        #[arg(long)]
        by: Option<String>,
    },

    /// Add/remove/list event labels
    #[command(after_help = r#"EXAMPLES:
    wa events label 123 --add urgent
    wa events label 123 --remove urgent
    wa events label 123 --list"#)]
    Label {
        /// Event ID to modify
        event_id: i64,

        /// Label to add (idempotent)
        #[arg(long)]
        add: Option<String>,

        /// Label to remove
        #[arg(long)]
        remove: Option<String>,

        /// List labels (and current annotations)
        #[arg(long)]
        list: bool,

        /// Actor identifier to record (optional; applies to --add)
        #[arg(long)]
        by: Option<String>,
    },
}

#[derive(Subcommand)]
enum ReproduceCommands {
    /// Export an incident bundle for sharing or analysis
    Export {
        /// Incident kind to export
        #[arg(long, default_value = "crash")]
        kind: String,

        /// Output directory for the bundle (default: crash_dir)
        #[arg(long)]
        out: Option<PathBuf>,

        /// Output format (text or json)
        #[arg(short = 'f', long, default_value = "text")]
        format: String,
    },

    /// Replay a bundle for deterministic analysis
    Replay {
        /// Path to the incident bundle directory
        bundle: PathBuf,

        /// Replay mode: policy (re-run policy eval) or rules (re-run pattern matching)
        #[arg(long, default_value = "policy")]
        mode: String,

        /// Output format (text or json)
        #[arg(short = 'f', long, default_value = "text")]
        format: String,
    },
}

#[derive(Subcommand)]
enum RecordCommands {
    /// Start recording a pane's terminal output
    Start {
        /// Pane ID to record (default: current pane)
        #[arg(long)]
        pane: Option<u64>,

        /// Title/label for this recording
        #[arg(long)]
        title: Option<String>,

        /// Auto-stop after this duration (e.g., "30m", "1h")
        #[arg(long)]
        auto_stop: Option<String>,

        /// Output .war file path (default: .wa/recordings/<timestamp>.war)
        #[arg(short = 'o', long)]
        output: Option<PathBuf>,
    },

    /// Stop an active recording
    Stop {
        /// Pane ID to stop recording (default: current pane)
        #[arg(long)]
        pane: Option<u64>,

        /// Stop all active recordings
        #[arg(long)]
        all: bool,
    },

    /// List available recordings
    List {
        /// Maximum number of recordings to show
        #[arg(short = 'l', long, default_value = "20")]
        limit: usize,

        /// Output as JSON
        #[arg(long)]
        json: bool,
    },

    /// Show detailed info about a recording
    Info {
        /// Path to the .war recording file
        file: PathBuf,

        /// Output as JSON
        #[arg(long)]
        json: bool,
    },

    /// Export a .war recording to Asciinema cast or self-contained HTML
    Export {
        /// Path to the .war recording file
        file: PathBuf,

        /// Export format: asciinema or html
        #[arg(short = 'f', long, default_value = "asciinema")]
        format: String,

        /// Output file path (default: stdout for asciinema, required for html)
        #[arg(short = 'o', long)]
        output: Option<PathBuf>,

        /// Terminal columns (overrides auto-detection from recording)
        #[arg(long)]
        cols: Option<u16>,

        /// Terminal rows (overrides auto-detection from recording)
        #[arg(long)]
        rows: Option<u16>,

        /// Title for the recording
        #[arg(long)]
        title: Option<String>,

        /// Disable secret redaction (WARNING: may expose credentials)
        #[arg(long)]
        no_redact: bool,

        /// Additional regex patterns to redact
        #[arg(long = "redact-pattern")]
        redact_patterns: Vec<String>,
    },
}

#[derive(Subcommand)]
enum SecretsCommands {
    /// Run a secret scan over stored segments and record the report
    #[command(after_help = r#"EXAMPLES:
    wa secrets scan
    wa secrets scan --pane 3
    wa secrets scan --since 1700000000000 --until 1700003600000
    wa secrets scan --format json"#)]
    Scan {
        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,

        /// Filter by pane ID
        #[arg(long)]
        pane_id: Option<u64>,

        /// Filter by start time (epoch ms)
        #[arg(long)]
        since: Option<i64>,

        /// Filter by end time (epoch ms)
        #[arg(long)]
        until: Option<i64>,

        /// Maximum segments to scan (None = unlimited)
        #[arg(long)]
        max_segments: Option<usize>,

        /// Batch size for incremental reads
        #[arg(long, default_value = "1000")]
        batch_size: usize,

        /// Maximum number of sample records to retain
        #[arg(long, default_value = "200")]
        sample_limit: usize,

        /// Pretty-print JSON output
        #[arg(long)]
        pretty: bool,
    },

    /// Show the latest secret scan report for a scope
    #[command(after_help = r#"EXAMPLES:
    wa secrets report
    wa secrets report --pane 3
    wa secrets report --format json"#)]
    Report {
        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,

        /// Filter by pane ID
        #[arg(long)]
        pane_id: Option<u64>,

        /// Filter by start time (epoch ms)
        #[arg(long)]
        since: Option<i64>,

        /// Filter by end time (epoch ms)
        #[arg(long)]
        until: Option<i64>,

        /// Pretty-print JSON output
        #[arg(long)]
        pretty: bool,
    },
}

#[derive(Subcommand)]
enum SearchCommands {
    /// FTS maintenance commands
    #[command(after_help = r#"EXAMPLES:
    wa search fts verify              Verify FTS index health
    wa search fts rebuild             Rebuild FTS index

SEE ALSO:
    wa search \"error\"               Run a normal search
    wa doctor                         System diagnostics"#)]
    Fts {
        #[command(subcommand)]
        command: FtsCommands,
    },
    /// Save a search query for reuse
    #[command(after_help = r#"EXAMPLES:
    wa search save errors "error OR warning"
    wa search save codex-errors "usage limit" --pane 0 --limit 50

SEE ALSO:
    wa search saved list
    wa search saved run <name>"#)]
    Save {
        /// Saved search name
        name: String,

        /// FTS query string
        query: String,

        /// Optional pane ID scope
        #[arg(long)]
        pane: Option<u64>,

        /// Maximum results to store for this search
        #[arg(long, default_value = "50")]
        limit: usize,

        /// Fixed since timestamp (epoch ms). If set, uses fixed since mode.
        #[arg(long)]
        since: Option<i64>,
    },
    /// Manage saved searches
    Saved {
        #[command(subcommand)]
        command: SavedSearchCommands,
    },
}

#[derive(Subcommand)]
enum FtsCommands {
    /// Verify FTS index integrity and consistency
    Verify,

    /// Rebuild the FTS index from stored segments
    Rebuild,
}

#[derive(Subcommand)]
enum SavedSearchCommands {
    /// List saved searches
    List,
    /// Run a saved search by name
    Run {
        /// Saved search name
        name: String,
    },
    /// Enable and schedule a saved search (sets interval + enabled=on)
    Schedule {
        /// Saved search name
        name: String,

        /// Interval in milliseconds (minimum 1000)
        interval_ms: i64,
    },
    /// Disable scheduling and clear interval (enabled=off, schedule=NULL)
    Unschedule {
        /// Saved search name
        name: String,
    },
    /// Enable scheduling for an already-scheduled search (enabled=on)
    Enable {
        /// Saved search name
        name: String,
    },
    /// Disable scheduling without clearing interval (enabled=off)
    Disable {
        /// Saved search name
        name: String,
    },
    /// Delete a saved search by name
    Delete {
        /// Saved search name
        name: String,
    },
}

#[derive(Subcommand)]
#[command(disable_help_subcommand = true)]
enum RobotCommands {
    /// Show robot help as JSON
    Help,

    /// Show quick-start guide for agents (default when no subcommand)
    QuickStart,

    /// Get all panes as JSON
    State,

    /// Get text from a pane
    GetText {
        /// Pane ID
        pane_id: u64,

        /// Number of lines to return from the end (tail)
        #[arg(long, default_value = "50")]
        tail: usize,

        /// Include ANSI escape sequences
        #[arg(long)]
        escapes: bool,
    },

    /// Send text to a pane
    Send {
        /// Pane ID
        pane_id: u64,

        /// Text to send
        text: String,

        /// Preview what would happen without executing
        #[arg(long)]
        dry_run: bool,

        /// Verify by waiting for a pattern after sending
        #[arg(long)]
        wait_for: Option<String>,

        /// Timeout for wait-for verification (seconds)
        #[arg(long, default_value = "30")]
        timeout_secs: u64,

        /// Treat wait-for pattern as regex
        #[arg(long)]
        wait_for_regex: bool,
    },

    /// Wait for a pattern in pane output
    WaitFor {
        /// Pane ID
        pane_id: u64,

        /// Pattern to wait for (substring by default, regex with --regex)
        pattern: String,

        /// Timeout in seconds
        #[arg(long, default_value = "30")]
        timeout_secs: u64,

        /// Number of tail lines to consider (0 = full buffer)
        #[arg(long, default_value = "200")]
        tail: usize,

        /// Treat pattern as a regex instead of substring
        #[arg(long)]
        regex: bool,
    },

    /// Search captured output
    Search {
        /// FTS query
        query: String,

        /// Limit number of results
        #[arg(long, default_value = "20")]
        limit: usize,

        /// Filter by pane ID
        #[arg(long)]
        pane: Option<u64>,

        /// Only return results since this timestamp (epoch ms)
        #[arg(long)]
        since: Option<i64>,

        /// Include snippets with highlighted terms
        #[arg(long)]
        snippets: bool,
    },

    /// Explain why search results may be missing or incomplete
    SearchExplain {
        /// FTS query to explain
        query: String,

        /// Filter diagnosis to a specific pane ID
        #[arg(long)]
        pane: Option<u64>,
    },

    /// Get recent events
    Events {
        /// Maximum number of events to return
        #[arg(long, default_value = "20")]
        limit: usize,

        /// Filter by pane ID
        #[arg(long)]
        pane: Option<u64>,

        /// Filter by rule ID (exact match)
        #[arg(long)]
        rule_id: Option<String>,

        /// Filter by event type (e.g., "compaction_warning")
        #[arg(long)]
        event_type: Option<String>,

        /// Filter by triage state (exact match)
        #[arg(long)]
        triage_state: Option<String>,

        /// Filter by label (exact match)
        #[arg(long)]
        label: Option<String>,

        /// Only return unhandled events
        #[arg(long, visible_alias = "unhandled-only")]
        unhandled: bool,

        /// Only return events since this timestamp (epoch ms)
        #[arg(long)]
        since: Option<i64>,

        /// Preview which workflows would handle these events (no execution)
        #[arg(long)]
        would_handle: bool,

        /// Mark output as dry-run preview (implies --would-handle)
        #[arg(long)]
        dry_run: bool,

        #[command(subcommand)]
        command: Option<RobotEventsCommands>,
    },

    /// Workflow management commands
    Workflow {
        #[command(subcommand)]
        command: RobotWorkflowCommands,
    },

    /// Rule management commands (list rules, test text against rules)
    Rules {
        #[command(subcommand)]
        command: RobotRulesCommands,
    },

    /// Explain an error code or policy denial
    Why {
        /// Error code or template ID to explain (e.g., "deny.alt_screen", "robot.policy_denied")
        code: String,
    },

    /// Account management commands (list, refresh, pick preview)
    Accounts {
        #[command(subcommand)]
        command: RobotAccountsCommands,
    },

    /// Pane reservation commands (reserve, release, list)
    Reservations {
        #[command(subcommand)]
        command: RobotReservationCommands,
    },

    /// Get watcher health snapshot (queue depths, ingest lag, stuck panes, scheduler state)
    Health,

    /// Submit an approval code for a pending action
    Approve {
        /// The approval code (8-character alphanumeric)
        code: String,

        /// Target pane ID for fingerprint validation (optional)
        #[arg(long)]
        pane: Option<u64>,

        /// Expected action fingerprint (optional)
        #[arg(long)]
        fingerprint: Option<String>,

        /// Check approval status without consuming
        #[arg(long)]
        dry_run: bool,
    },
}

/// Robot event triage/annotation subcommands (bd-2gce)
#[derive(Subcommand)]
enum RobotEventsCommands {
    /// Set or clear the note on an event
    Annotate {
        /// Event ID to annotate
        event_id: i64,

        /// Note text to set
        #[arg(long)]
        note: Option<String>,

        /// Clear the note
        #[arg(long)]
        clear: bool,

        /// Actor identifier to record (optional)
        #[arg(long)]
        by: Option<String>,
    },

    /// Set or clear the triage state for an event
    Triage {
        /// Event ID to triage
        event_id: i64,

        /// Triage state to set (string, exact-match)
        #[arg(long)]
        state: Option<String>,

        /// Clear the triage state
        #[arg(long)]
        clear: bool,

        /// Actor identifier to record (optional)
        #[arg(long)]
        by: Option<String>,
    },

    /// Add/remove/list event labels
    Label {
        /// Event ID to modify
        event_id: i64,

        /// Label to add (idempotent)
        #[arg(long)]
        add: Option<String>,

        /// Label to remove
        #[arg(long)]
        remove: Option<String>,

        /// List labels (and current annotations)
        #[arg(long)]
        list: bool,

        /// Actor identifier to record (optional; applies to --add)
        #[arg(long)]
        by: Option<String>,
    },
}

/// Robot workflow subcommands
#[derive(Subcommand)]
enum RobotWorkflowCommands {
    /// Run a workflow by name on a pane
    Run {
        /// Workflow name
        name: String,

        /// Target pane ID
        pane_id: u64,

        /// Bypass "already handled" checks (still policy-gated)
        #[arg(long)]
        force: bool,

        /// Preview what would happen without executing
        #[arg(long)]
        dry_run: bool,
    },

    /// List available workflows
    List,

    /// Check workflow execution status
    Status {
        /// Execution ID (optional when using --pane or --active)
        execution_id: Option<String>,

        /// Filter by pane ID (list all workflows for this pane)
        #[arg(long)]
        pane: Option<u64>,

        /// List all active workflows (status: running or waiting)
        #[arg(long)]
        active: bool,

        /// Include step logs in response (-v verbose, -vv debug)
        #[arg(long, short, action = clap::ArgAction::Count)]
        verbose: u8,
    },

    /// Abort a running workflow
    Abort {
        /// Execution ID
        execution_id: String,

        /// Reason for aborting
        #[arg(long)]
        reason: Option<String>,

        /// Force abort (skip cleanup steps)
        #[arg(long)]
        force: bool,
    },
}

/// Robot rules subcommands
#[derive(Subcommand)]
enum RobotRulesCommands {
    /// List all rules with metadata
    List {
        /// Filter by pack name (e.g., "builtin:codex")
        #[arg(long)]
        pack: Option<String>,

        /// Filter by agent type (codex, claude_code, gemini, wezterm)
        #[arg(long)]
        agent_type: Option<String>,

        /// Include rule descriptions in output (-v verbose, -vv debug)
        #[arg(long, short, action = clap::ArgAction::Count)]
        verbose: u8,
    },

    /// Test text against rules and show match trace
    Test {
        /// Text to test against rules
        text: String,

        /// Show full trace evidence for matches
        #[arg(long)]
        trace: bool,

        /// Only test rules from a specific pack
        #[arg(long)]
        pack: Option<String>,
    },

    /// Show details for a specific rule
    Show {
        /// Rule ID (e.g., "codex.usage_reached")
        rule_id: String,
    },

    /// Lint rules: validate IDs, check fixtures, validate regex patterns
    Lint {
        /// Only check a specific pack (e.g., "builtin:codex")
        #[arg(long)]
        pack: Option<String>,

        /// Include fixture coverage check (validates corpus has tests for each rule)
        #[arg(long)]
        fixtures: bool,

        /// Skip regex complexity check
        #[arg(long)]
        skip_regex_check: bool,

        /// Fail on warnings (exit non-zero)
        #[arg(long)]
        strict: bool,
    },
}

/// Human accounts subcommands
#[derive(Subcommand)]
enum AccountsCommands {
    /// Refresh account usage data from caut
    Refresh {
        /// Service to refresh (default: "openai")
        #[arg(long, default_value = "openai")]
        service: String,
    },
}

/// Robot accounts subcommands
#[derive(Subcommand)]
enum RobotAccountsCommands {
    /// List accounts with usage data and pick preview
    List {
        /// Service filter (default: "openai")
        #[arg(long, default_value = "openai")]
        service: String,

        /// Include pick preview (which account would be selected next)
        #[arg(long)]
        pick: bool,
    },

    /// Refresh account usage data from caut
    Refresh {
        /// Service to refresh (default: "openai")
        #[arg(long, default_value = "openai")]
        service: String,
    },
}

#[derive(Subcommand)]
enum RobotReservationCommands {
    /// Reserve a pane for exclusive use
    Reserve {
        /// Pane ID to reserve
        pane_id: u64,

        /// TTL in seconds (default: 1800 = 30 minutes)
        #[arg(long, default_value = "1800")]
        ttl: u64,

        /// Owner kind (workflow, agent, manual)
        #[arg(long, default_value = "agent")]
        owner_kind: String,

        /// Owner identifier
        #[arg(long)]
        owner_id: String,

        /// Reason for reservation
        #[arg(long)]
        reason: Option<String>,
    },

    /// Release a pane reservation
    Release {
        /// Reservation ID to release
        reservation_id: i64,
    },

    /// List active pane reservations
    List,
}

#[cfg(feature = "mcp")]
#[derive(Subcommand)]
enum McpCommands {
    /// Start MCP server (stdio transport by default)
    Serve {
        /// Transport to use (currently only "stdio")
        #[arg(long, default_value = "stdio")]
        transport: String,
    },
}

#[derive(Subcommand)]
enum WorkflowCommands {
    /// List available workflows
    List,

    /// Run a workflow
    Run {
        /// Workflow name
        name: String,

        /// Target pane ID
        #[arg(long)]
        pane: u64,

        /// Preview what would happen without executing
        #[arg(long)]
        dry_run: bool,
    },

    /// Show workflow execution status
    Status {
        /// Execution ID
        execution_id: String,

        /// Include action plan and step logs (-v verbose, -vv debug)
        #[arg(long, short, action = clap::ArgAction::Count)]
        verbose: u8,
    },
}

#[derive(Subcommand)]
enum PrepareCommands {
    /// Prepare a send_text plan preview
    Send {
        /// Target pane ID
        #[arg(long, alias = "pane")]
        pane_id: u64,

        /// Text to send
        text: String,

        /// Output format: plain or json
        #[arg(long, short = 'f', default_value = "plain")]
        format: String,

        /// Send character by character (no paste mode)
        #[arg(long)]
        no_paste: bool,

        /// Do not append a trailing newline
        #[arg(long)]
        no_newline: bool,

        /// Verify by waiting for a pattern after sending
        #[arg(long)]
        wait_for: Option<String>,

        /// Timeout for wait-for verification (seconds)
        #[arg(long, default_value = "30")]
        timeout_secs: u64,

        /// Treat wait-for pattern as regex
        #[arg(long)]
        wait_for_regex: bool,
    },

    /// Prepare a workflow action plan preview
    Workflow {
        #[command(subcommand)]
        command: PrepareWorkflowCommands,
    },
}

#[derive(Subcommand)]
enum PrepareWorkflowCommands {
    /// Prepare a workflow run plan
    Run {
        /// Workflow name
        name: String,

        /// Target pane ID
        #[arg(long, alias = "pane")]
        pane_id: u64,

        /// Output format: plain or json
        #[arg(long, short = 'f', default_value = "plain")]
        format: String,
    },
}

/// Human CLI rules subcommands
#[derive(Subcommand)]
enum RulesCommands {
    /// List all pattern detection rules
    List {
        /// Filter by agent type (codex, claude_code, gemini, wezterm)
        #[arg(long, short = 'a')]
        agent_type: Option<String>,

        /// Show descriptions for each rule (-v verbose, -vv debug)
        #[arg(long, short, action = clap::ArgAction::Count)]
        verbose: u8,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },

    /// Test text against pattern rules
    Test {
        /// Text to test against all rules
        text: String,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },

    /// Show full details for a specific rule
    Show {
        /// Rule ID (e.g., "codex.usage_reached")
        rule_id: String,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },

    /// Manage ruleset profiles
    Profile {
        #[command(subcommand)]
        command: RulesProfileCommands,
    },
}

#[derive(Subcommand)]
enum ExtCommands {
    /// List all extensions (built-in and installed)
    List {
        /// Filter by type: all, builtin, file
        #[arg(long, short = 't', default_value = "all")]
        r#type: String,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },

    /// Install an extension from a local file
    Install {
        /// Path to the extension file (.toml, .yaml, .json)
        path: PathBuf,
    },

    /// Remove an installed extension
    Remove {
        /// Extension name or file stem
        name: String,
    },

    /// Validate an extension file without installing
    Validate {
        /// Path to the extension file
        path: PathBuf,
    },

    /// Show detailed information about an extension
    Info {
        /// Extension name (e.g., "codex", "my-patterns")
        name: String,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },
}

#[derive(Subcommand)]
enum RulesProfileCommands {
    /// List available ruleset profiles
    List {
        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },

    /// Apply a ruleset profile
    Apply {
        /// Profile name (e.g., "incident" or "default")
        name: String,
    },
}

#[derive(Subcommand)]
enum DiagCommands {
    /// Generate a sanitized diagnostic bundle for bug reports
    Bundle {
        /// Output directory (default: workspace diag_dir)
        #[arg(long, short = 'o')]
        output: Option<PathBuf>,

        /// Overwrite existing output directory
        #[arg(long)]
        force: bool,

        /// Maximum number of recent events to include (default: 100)
        #[arg(long, default_value = "100")]
        events: usize,

        /// Maximum number of recent audit actions to include (default: 50)
        #[arg(long, default_value = "50")]
        audit: usize,

        /// Maximum number of recent workflow executions to include (default: 50)
        #[arg(long, default_value = "50")]
        workflows: usize,
    },
}

#[derive(Subcommand)]
enum SetupCommands {
    /// Setup local WezTerm configuration
    Local,

    /// Setup remote host
    Remote {
        /// SSH host (from ~/.ssh/config)
        host: String,

        /// Skip interactive confirmation (only with --apply)
        #[arg(long)]
        yes: bool,

        /// Install wa on the remote host
        #[arg(long)]
        install_wa: bool,

        /// Path to local wa binary for scp
        #[arg(long)]
        wa_path: Option<PathBuf>,

        /// Install wa from git (optional tag or revision)
        #[arg(long)]
        wa_version: Option<String>,

        /// Timeout per remote command (seconds)
        #[arg(long, default_value = "30")]
        timeout_secs: u64,
    },

    /// Generate WezTerm config additions
    Config,

    /// Patch wezterm.lua with user-var forwarding (idempotent)
    Patch {
        /// Remove the wa block instead of adding it
        #[arg(long)]
        remove: bool,

        /// Custom path to wezterm.lua (auto-detected if not specified)
        #[arg(long)]
        config_path: Option<PathBuf>,
    },

    /// Install OSC 133 prompt markers in shell rc file (idempotent)
    Shell {
        /// Remove the wa block instead of adding it
        #[arg(long)]
        remove: bool,

        /// Shell type: bash, zsh, or fish (auto-detected from $SHELL if not specified)
        #[arg(long, value_parser = ["bash", "zsh", "fish"])]
        shell: Option<String>,

        /// Custom path to rc file (auto-detected if not specified)
        #[arg(long)]
        rc_path: Option<PathBuf>,
    },
}

#[derive(Subcommand)]
enum ConfigCommands {
    /// Initialize configuration (creates default config if absent)
    Init {
        /// Overwrite existing config (dangerous)
        #[arg(long)]
        force: bool,

        /// Custom config path (default: ./wa.toml or ~/.config/wa/wa.toml)
        #[arg(long)]
        path: Option<String>,
    },

    /// Validate configuration file (schema + semantic checks)
    Validate {
        /// Custom config path to validate
        #[arg(long)]
        path: Option<String>,

        /// Strict validation (fail on warnings)
        #[arg(long)]
        strict: bool,
    },

    /// Show current configuration
    Show {
        /// Show effective config including resolved paths
        #[arg(long)]
        effective: bool,

        /// Output as JSON
        #[arg(long)]
        json: bool,

        /// Custom config path
        #[arg(long)]
        path: Option<String>,
    },

    /// Set a configuration value
    Set {
        /// Configuration key (dot notation, e.g., "general.log_level")
        key: String,

        /// Value to set
        value: String,

        /// Preview changes without applying
        #[arg(long)]
        dry_run: bool,

        /// Custom config path
        #[arg(long)]
        path: Option<String>,
    },

    /// Export configuration to a TOML file
    Export {
        /// Output path (default: stdout)
        #[arg(long, short = 'o')]
        output: Option<String>,

        /// Output as JSON instead of TOML
        #[arg(long)]
        json: bool,

        /// Source config path
        #[arg(long)]
        path: Option<String>,
    },

    /// Import configuration from a TOML file
    Import {
        /// Path to the config file to import
        source: String,

        /// Preview changes without applying
        #[arg(long)]
        dry_run: bool,

        /// Replace entire config instead of merging
        #[arg(long)]
        replace: bool,

        /// Skip confirmation prompt
        #[arg(long)]
        yes: bool,

        /// Target config path
        #[arg(long)]
        path: Option<String>,
    },

    /// Manage configuration profiles (overlays)
    Profile {
        #[command(subcommand)]
        command: ConfigProfileCommands,
    },
}

#[derive(Subcommand)]
enum ConfigProfileCommands {
    /// List available config profiles
    List {
        /// Output as JSON
        #[arg(long)]
        json: bool,

        /// Custom config path
        #[arg(long)]
        path: Option<String>,
    },

    /// Show the diff between base config and a profile overlay
    Diff {
        /// Profile name
        name: String,

        /// Custom config path
        #[arg(long)]
        path: Option<String>,
    },

    /// Create a new profile from the current config or another profile
    Create {
        /// Profile name
        name: String,

        /// Source profile name or "current" (default)
        #[arg(long, default_value = "current")]
        from: String,

        /// Optional description stored in manifest
        #[arg(long)]
        description: Option<String>,

        /// Overwrite existing profile file
        #[arg(long)]
        force: bool,

        /// Custom config path
        #[arg(long)]
        path: Option<String>,
    },

    /// Apply a profile overlay to the base config
    Apply {
        /// Profile name
        name: String,

        /// Preview changes without applying
        #[arg(long)]
        dry_run: bool,

        /// Custom config path
        #[arg(long)]
        path: Option<String>,
    },

    /// Roll back to the previous config saved before profile apply
    Rollback {
        /// Skip confirmation prompt
        #[arg(long)]
        yes: bool,

        /// Custom config path
        #[arg(long)]
        path: Option<String>,
    },
}

#[derive(Subcommand)]
enum DbCommands {
    /// Migrate or inspect the database schema
    Migrate {
        /// Show migration status without applying changes
        #[arg(long)]
        status: bool,

        /// Target schema version (default: current SCHEMA_VERSION)
        #[arg(long)]
        to: Option<i32>,

        /// Apply without prompting for confirmation
        #[arg(long)]
        yes: bool,

        /// Allow downgrades (dangerous)
        #[arg(long)]
        allow_downgrade: bool,

        /// Show the plan without applying migrations
        #[arg(long)]
        dry_run: bool,
    },

    /// Check database health (integrity, FTS, WAL, schema)
    Check {
        /// Output format (auto, plain, json)
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },

    /// Repair database issues (FTS rebuild, WAL checkpoint, vacuum)
    Repair {
        /// Show what would be repaired without executing
        #[arg(long)]
        dry_run: bool,

        /// Skip confirmation prompt
        #[arg(long)]
        yes: bool,

        /// Skip creating a backup before repair
        #[arg(long)]
        no_backup: bool,

        /// Output format (auto, plain, json)
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },

    /// Show database size, record counts, and cleanup suggestions
    Stats {
        /// Output format (auto, plain, json)
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },
}

#[derive(Subcommand)]
enum BackupCommands {
    /// Export database and metadata to a portable backup archive
    Export {
        /// Output directory path (default: .wa/backups/wa_backup_<timestamp>)
        #[arg(long, short = 'o')]
        output: Option<String>,

        /// Include SQL text dump alongside binary database copy
        #[arg(long)]
        sql_dump: bool,

        /// Skip post-export verification
        #[arg(long)]
        no_verify: bool,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },

    /// Import (restore) from a backup archive
    Import {
        /// Path to the backup directory to import
        path: String,

        /// Only verify and show what would happen (no modifications)
        #[arg(long)]
        dry_run: bool,

        /// Skip interactive confirmation
        #[arg(long)]
        yes: bool,

        /// Skip creating a safety backup of current data before import
        #[arg(long)]
        no_safety_backup: bool,

        /// Only verify the backup integrity without importing
        #[arg(long)]
        verify: bool,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },
}

#[cfg(feature = "sync")]
#[derive(Subcommand)]
enum SyncCommands {
    /// Show configured targets and sync defaults
    Status {
        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },
    /// Preview or apply a push plan
    Push {
        /// Target name (if multiple are configured)
        #[arg(long)]
        target: Option<String>,

        /// Show what would change without modifying files
        #[arg(long)]
        dry_run: bool,

        /// Apply changes (requires confirmation)
        #[arg(long)]
        apply: bool,

        /// Skip confirmation when applying
        #[arg(long)]
        yes: bool,

        /// Allow overwriting existing files
        #[arg(long)]
        allow_overwrite: bool,

        /// Limit payloads to the selected categories
        #[arg(long, value_enum)]
        include: Vec<SyncInclude>,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },
    /// Preview or apply a pull plan
    Pull {
        /// Target name (if multiple are configured)
        #[arg(long)]
        target: Option<String>,

        /// Show what would change without modifying files
        #[arg(long)]
        dry_run: bool,

        /// Apply changes (requires confirmation)
        #[arg(long)]
        apply: bool,

        /// Skip confirmation when applying
        #[arg(long)]
        yes: bool,

        /// Allow overwriting existing files
        #[arg(long)]
        allow_overwrite: bool,

        /// Limit payloads to the selected categories
        #[arg(long, value_enum)]
        include: Vec<SyncInclude>,

        /// Output format: auto, plain, or json
        #[arg(long, short = 'f', default_value = "auto")]
        format: String,
    },
}

// =============================================================================
// Auth subcommands
// =============================================================================

#[derive(Subcommand)]
enum AuthCommands {
    /// Test browser authentication flow for a service
    #[command(after_help = r#"EXAMPLES:
    wa auth test openai --account work     Test OpenAI auth with 'work' profile
    wa auth test openai --headful          Debug mode (visible browser)
    wa auth test openai --timeout-secs 120 Custom timeout

OUTCOMES:
    Success     Profile authenticated, automated auth works
    NeedsHuman  Interactive bootstrap required (MFA/password)
    Fail        Automation error (selector change, network, etc.)"#)]
    Test {
        /// Service to test (e.g., "openai")
        service: String,

        /// Account name for profile selection (default: "default")
        #[arg(long, default_value = "default")]
        account: String,

        /// Run browser in visible (non-headless) mode for debugging
        #[arg(long)]
        headful: bool,

        /// Flow timeout in seconds (default: 60)
        #[arg(long, default_value = "60")]
        timeout_secs: u64,

        /// Output as JSON
        #[arg(long)]
        json: bool,
    },

    /// Check browser profile health and authentication status
    #[command(after_help = r#"EXAMPLES:
    wa auth status openai                  Check OpenAI profile
    wa auth status openai --account work   Check specific account
    wa auth status --all                   Check all profiles"#)]
    Status {
        /// Service to check (omit with --all for all services)
        service: Option<String>,

        /// Account name (default: "default")
        #[arg(long, default_value = "default")]
        account: String,

        /// Check all profiles
        #[arg(long)]
        all: bool,

        /// Output as JSON
        #[arg(long)]
        json: bool,
    },

    /// Interactively bootstrap a browser profile (one-time login)
    #[command(after_help = r#"EXAMPLES:
    wa auth bootstrap openai               Bootstrap OpenAI profile
    wa auth bootstrap openai --account work Bootstrap specific account

NOTE: Opens a visible browser window. You must complete login manually."#)]
    Bootstrap {
        /// Service to bootstrap (e.g., "openai")
        service: String,

        /// Account name (default: "default")
        #[arg(long, default_value = "default")]
        account: String,

        /// Login URL override
        #[arg(long)]
        login_url: Option<String>,

        /// Bootstrap timeout in seconds (default: 300)
        #[arg(long, default_value = "300")]
        timeout_secs: u64,

        /// Output as JSON
        #[arg(long)]
        json: bool,
    },
}

/// Outcome of a browser auth test, matching the auth realities matrix.
#[cfg(feature = "browser")]
#[derive(Debug, Clone, serde::Serialize)]
#[serde(tag = "outcome")]
enum AuthTestOutcome {
    /// Profile is authenticated; automated auth flow succeeds.
    #[serde(rename = "success")]
    Success {
        service: String,
        account: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        elapsed_ms: Option<u64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        last_bootstrapped: Option<String>,
    },
    /// Interactive login required (MFA/password).
    #[serde(rename = "needs_human")]
    NeedsHuman {
        service: String,
        account: String,
        reason: String,
        next_step: String,
    },
    /// Auth test failed with an error.
    #[serde(rename = "fail")]
    Fail {
        service: String,
        account: String,
        error: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        next_step: Option<String>,
    },
}

/// Profile status for `wa auth status`.
#[cfg(feature = "browser")]
#[derive(Debug, Clone, serde::Serialize)]
struct AuthProfileStatus {
    service: String,
    account: String,
    profile_exists: bool,
    has_storage_state: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    bootstrapped_at: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    bootstrap_method: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    last_used_at: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    automated_use_count: Option<u64>,
}

const ROBOT_ERR_INVALID_ARGS: &str = "robot.invalid_args";
const ROBOT_ERR_UNKNOWN_SUBCOMMAND: &str = "robot.unknown_subcommand";
const ROBOT_ERR_CONFIG: &str = "robot.config_error";
const ROBOT_ERR_FTS_QUERY: &str = "robot.fts_query_error";
const ROBOT_ERR_STORAGE: &str = "robot.storage_error";
/// Cooldown period between account refreshes (milliseconds)
const ROBOT_REFRESH_COOLDOWN_MS: i64 = 30_000;

#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]
enum RobotOutputFormat {
    Json,
    Toon,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]
enum NotifyChannel {
    Webhook,
    Desktop,
    Email,
}

#[cfg(feature = "sync")]
#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]
enum SyncInclude {
    Binary,
    Config,
    Snapshots,
}

#[cfg(feature = "sync")]
impl From<SyncInclude> for wa_core::sync::SyncCategory {
    fn from(value: SyncInclude) -> Self {
        match value {
            SyncInclude::Binary => wa_core::sync::SyncCategory::Binary,
            SyncInclude::Config => wa_core::sync::SyncCategory::Config,
            SyncInclude::Snapshots => wa_core::sync::SyncCategory::Snapshots,
        }
    }
}

fn parse_robot_output_format(s: &str) -> Option<RobotOutputFormat> {
    match s.trim().to_ascii_lowercase().as_str() {
        "json" => Some(RobotOutputFormat::Json),
        "toon" => Some(RobotOutputFormat::Toon),
        _ => None,
    }
}

fn resolve_robot_output_format(cli: Option<RobotOutputFormat>) -> RobotOutputFormat {
    if let Some(format) = cli {
        return format;
    }

    if let Ok(val) = std::env::var("WA_OUTPUT_FORMAT") {
        if let Some(format) = parse_robot_output_format(&val) {
            return format;
        }
    }

    if let Ok(val) = std::env::var("TOON_DEFAULT_FORMAT") {
        if let Some(format) = parse_robot_output_format(&val) {
            return format;
        }
    }

    RobotOutputFormat::Json
}

fn sniff_robot_output_format_from_args() -> Option<RobotOutputFormat> {
    let mut args = std::env::args();
    while let Some(arg) = args.next() {
        if let Some(rest) = arg.strip_prefix("--format=") {
            return parse_robot_output_format(rest);
        }

        if arg == "--format" || arg == "-f" {
            if let Some(val) = args.next() {
                return parse_robot_output_format(&val);
            }
        }
    }
    None
}

fn sniff_robot_mode_from_args() -> bool {
    let mut args = std::env::args();
    // Skip argv[0]
    let _ = args.next();

    let mut skip_next_value = false;

    while let Some(arg) = args.next() {
        if skip_next_value {
            skip_next_value = false;
            continue;
        }

        if arg == "--" {
            return args.next().is_some_and(|sub| sub == "robot");
        }

        // Known global options that take values.
        if arg == "--config" || arg == "-c" || arg == "--workspace" {
            skip_next_value = true;
            continue;
        }
        if arg.starts_with("--config=") || arg.starts_with("--workspace=") {
            continue;
        }

        // Any other long option (including clap-provided --help/--version).
        if arg.starts_with("--") {
            continue;
        }

        // Handle short option clusters like `-vc foo robot` and attached values like `-cfoo`.
        if arg.starts_with('-') && !arg.starts_with("--") && arg.len() > 1 {
            if arg == "-v" {
                continue;
            }
            if let Some(rest) = arg.strip_prefix("-c") {
                // `-cVALUE` consumes the rest of the arg as the value.
                if rest.is_empty() {
                    skip_next_value = true;
                }
                continue;
            }

            let mut chars = arg[1..].chars().peekable();
            while let Some(ch) = chars.next() {
                match ch {
                    'v' => {}
                    'c' => {
                        // `-cVALUE` (attached) or `-c VALUE` (next token).
                        if chars.peek().is_none() {
                            skip_next_value = true;
                        }
                        break;
                    }
                    _ => {}
                }
            }
            continue;
        }

        // First positional token is the subcommand.
        return arg == "robot";
    }

    false
}

fn should_show_toon_stats(cli_stats: bool) -> bool {
    cli_stats || std::env::var("TOON_STATS").is_ok()
}

/// JSON envelope for robot mode responses
#[derive(serde::Serialize)]
struct RobotResponse<T> {
    ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    data: Option<T>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error_code: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    hint: Option<String>,
    elapsed_ms: u64,
    version: String,
    now: u64,
}

impl<T> RobotResponse<T> {
    fn success(data: T, elapsed_ms: u64) -> Self {
        Self {
            ok: true,
            data: Some(data),
            error: None,
            error_code: None,
            hint: None,
            elapsed_ms,
            version: wa_core::VERSION.to_string(),
            now: now_ms(),
        }
    }

    fn error_with_code(
        code: &str,
        msg: impl Into<String>,
        hint: Option<String>,
        elapsed_ms: u64,
    ) -> Self {
        Self {
            ok: false,
            data: None,
            error: Some(msg.into()),
            error_code: Some(code.to_string()),
            hint,
            elapsed_ms,
            version: wa_core::VERSION.to_string(),
            now: now_ms(),
        }
    }
}

fn estimate_tokens(s: &str) -> usize {
    let chars = s.len();
    let words = s.split_whitespace().count();
    std::cmp::max(chars / 4, words)
}

fn emit_toon_stats(json: &str, toon: &str) {
    let json_tokens = estimate_tokens(json);
    let toon_tokens = estimate_tokens(toon);
    #[allow(clippy::cast_possible_wrap)]
    let savings_pct = if json_tokens > 0 {
        // TOON can be larger than JSON for very small payloads; use signed math so we don't underflow.
        // Token counts are small enough that wrap is impossible in practice.
        100_i64 - ((toon_tokens as i64) * 100 / (json_tokens as i64))
    } else {
        0
    };

    eprintln!(
        "[stats] JSON: {json_tokens} tokens, TOON: {toon_tokens} tokens ({savings_pct}% savings)"
    );
}

fn print_robot_response<T: serde::Serialize>(
    response: &RobotResponse<T>,
    format: RobotOutputFormat,
    cli_stats: bool,
) -> anyhow::Result<()> {
    let show_stats = should_show_toon_stats(cli_stats);

    match format {
        RobotOutputFormat::Json => {
            if show_stats {
                // Use compact JSON for stats to avoid counting whitespace.
                let json_compact = serde_json::to_string(response)?;
                let toon = toon_rust::encode(serde_json::to_value(response)?, None);
                emit_toon_stats(&json_compact, &toon);
            }

            println!("{}", serde_json::to_string_pretty(response)?);
        }
        RobotOutputFormat::Toon => {
            let toon = toon_rust::encode(serde_json::to_value(response)?, None);

            if show_stats {
                let json_compact = serde_json::to_string(response)?;
                emit_toon_stats(&json_compact, &toon);
            }

            println!("{toon}");
        }
    }

    Ok(())
}

#[derive(serde::Serialize)]
struct RobotHelp {
    commands: Vec<RobotCommandInfo>,
    global_flags: Vec<&'static str>,
}

#[derive(serde::Serialize)]
struct RobotCommandInfo {
    name: &'static str,
    description: &'static str,
}

/// Quick-start data for agents
#[derive(serde::Serialize)]
struct RobotQuickStartData {
    description: &'static str,
    global_flags: Vec<QuickStartGlobalFlag>,
    core_loop: Vec<QuickStartStep>,
    commands: Vec<QuickStartCommand>,
    tips: Vec<&'static str>,
    error_handling: QuickStartErrorHandling,
}

#[derive(serde::Serialize)]
struct QuickStartGlobalFlag {
    flag: &'static str,
    env_var: Option<&'static str>,
    description: &'static str,
}

#[derive(serde::Serialize)]
struct QuickStartStep {
    step: u8,
    action: &'static str,
    command: &'static str,
}

#[derive(serde::Serialize)]
struct QuickStartCommand {
    name: &'static str,
    args: &'static str,
    summary: &'static str,
    examples: Vec<&'static str>,
}

#[derive(serde::Serialize)]
struct QuickStartErrorHandling {
    common_codes: Vec<QuickStartErrorCode>,
    safety_notes: Vec<&'static str>,
}

#[derive(serde::Serialize)]
struct QuickStartErrorCode {
    code: &'static str,
    meaning: &'static str,
    recovery: &'static str,
}

/// Pane state for CLI output (list and robot state commands)
#[derive(serde::Serialize)]
struct PaneState {
    pane_id: u64,
    /// Stable pane UUID (assigned at discovery, persists across renames/moves)
    /// Will be null until the pane has been observed by the daemon.
    pane_uuid: Option<String>,
    tab_id: u64,
    window_id: u64,
    domain: String,
    title: Option<String>,
    cwd: Option<String>,
    observed: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    ignore_reason: Option<String>,
}

impl PaneState {
    fn from_pane_info(
        info: &wa_core::wezterm::PaneInfo,
        filter: &wa_core::config::PaneFilterConfig,
    ) -> Self {
        let domain = info.inferred_domain();
        let title = info.title.clone().unwrap_or_default();
        let cwd = info.cwd.clone().unwrap_or_default();

        let ignore_reason = filter.check_pane(&domain, &title, &cwd);

        Self {
            pane_id: info.pane_id,
            pane_uuid: None, // Not assigned until pane is observed by daemon
            tab_id: info.tab_id,
            window_id: info.window_id,
            domain,
            title: info.title.clone(),
            cwd: info.cwd.clone(),
            observed: ignore_reason.is_none(),
            ignore_reason,
        }
    }

    fn format_human(&self) -> String {
        let status = if self.observed { "observed" } else { "ignored" };
        let reason = self
            .ignore_reason
            .as_ref()
            .map(|r| format!(" ({r})"))
            .unwrap_or_default();
        let title = self.title.as_deref().unwrap_or("(untitled)");
        let cwd = self.cwd.as_deref().unwrap_or("(unknown)");

        format!(
            "  {:>4}  {:>10}  {:<20}  {:<40}  {}{}",
            self.pane_id, status, title, cwd, self.domain, reason
        )
    }
}

/// Robot get-text response data (matches wa-robot-get-text.json schema)
#[derive(serde::Serialize)]
struct RobotGetTextData {
    pane_id: u64,
    text: String,
    tail_lines: usize,
    escapes_included: bool,
    #[serde(skip_serializing_if = "std::ops::Not::not")]
    truncated: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    truncation_info: Option<TruncationInfo>,
}

#[derive(serde::Serialize)]
struct TruncationInfo {
    original_bytes: usize,
    returned_bytes: usize,
    original_lines: usize,
    returned_lines: usize,
}

/// Wait-for result data for robot mode
#[derive(serde::Serialize)]
struct RobotWaitForData {
    pane_id: u64,
    pattern: String,
    matched: bool,
    elapsed_ms: u64,
    polls: usize,
    #[serde(skip_serializing_if = "std::ops::Not::not")]
    is_regex: bool,
}

/// Robot send response data
#[derive(serde::Serialize)]
struct RobotSendData {
    pane_id: u64,
    injection: wa_core::policy::InjectionResult,
    #[serde(skip_serializing_if = "Option::is_none")]
    wait_for: Option<RobotWaitForData>,
    #[serde(skip_serializing_if = "Option::is_none")]
    verification_error: Option<String>,
}

/// Human send response data (stable JSON when non-TTY)
#[derive(serde::Serialize)]
struct HumanSendData {
    pane_id: u64,
    injection: wa_core::policy::InjectionResult,
    #[serde(skip_serializing_if = "Option::is_none")]
    wait_for: Option<RobotWaitForData>,
    #[serde(skip_serializing_if = "Option::is_none")]
    verification_error: Option<String>,
    no_paste: bool,
    no_newline: bool,
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
enum PreparedPlanParams {
    SendText {
        pane_id: u64,
        no_paste: bool,
        no_newline: bool,
        wait_for: Option<String>,
        wait_for_regex: bool,
        timeout_secs: u64,
    },
    WorkflowRun {
        workflow_name: String,
        pane_id: u64,
    },
}

#[derive(serde::Serialize)]
struct PrepareApprovalOutput {
    code: String,
    expires_at: i64,
    expires_at_iso: String,
}

#[derive(serde::Serialize)]
struct PrepareCommitHint {
    command: String,
}

#[derive(serde::Serialize)]
struct PrepareOutput {
    plan_id: String,
    plan_hash: String,
    expires_at: i64,
    expires_at_iso: String,
    action_kind: String,
    pane_id: Option<u64>,
    requires_approval: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    approval: Option<PrepareApprovalOutput>,
    commit: PrepareCommitHint,
    plan: wa_core::plan::ActionPlan,
}

#[derive(serde::Serialize)]
struct NotifyTestOutput {
    channel: String,
    channel_type: String,
    event_type: String,
    severity: String,
    agent_type: String,
    decision: String,
    redaction_ok: bool,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    redaction_issues: Vec<String>,
    payload: wa_core::notifications::NotificationPayload,
    #[serde(skip_serializing_if = "Option::is_none")]
    delivery: Option<wa_core::notifications::NotificationDelivery>,
    #[serde(skip_serializing_if = "Option::is_none")]
    warning: Option<String>,
}

#[derive(serde::Serialize)]
struct NotifyTestResponse {
    ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    error: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error_code: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    hint: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    data: Option<NotifyTestOutput>,
}

#[derive(Debug, serde::Deserialize)]
struct IpcPaneState {
    pane_id: u64,
    known: bool,
    #[serde(default)]
    observed: Option<bool>,
    #[serde(default)]
    alt_screen: Option<bool>,
    #[serde(default)]
    last_status_at: Option<i64>,
    #[serde(default)]
    in_gap: Option<bool>,
    #[serde(default)]
    cursor_alt_screen: Option<bool>,
    #[serde(default)]
    reason: Option<String>,
}

/// Search result data for robot mode
#[derive(serde::Serialize)]
struct RobotSearchData {
    query: String,
    results: Vec<RobotSearchHit>,
    total_hits: usize,
    limit: usize,
    #[serde(skip_serializing_if = "Option::is_none")]
    pane_filter: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    since_filter: Option<i64>,
}

/// Individual search hit for robot mode
#[derive(serde::Serialize)]
struct RobotSearchHit {
    segment_id: i64,
    pane_id: u64,
    seq: u64,
    captured_at: i64,
    score: f64,
    #[serde(skip_serializing_if = "Option::is_none")]
    snippet: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    content: Option<String>,
}

/// Robot search-explain response data
#[derive(serde::Serialize)]
struct RobotSearchExplainData {
    query: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pane_filter: Option<u64>,
    total_panes: usize,
    observed_panes: usize,
    ignored_panes: usize,
    total_segments: u64,
    reasons: Vec<wa_core::search_explain::SearchExplainReason>,
}

/// Robot events response data
#[derive(serde::Serialize)]
struct RobotEventsData {
    events: Vec<RobotEventItem>,
    total_count: usize,
    limit: usize,
    #[serde(skip_serializing_if = "Option::is_none")]
    pane_filter: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    rule_id_filter: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    event_type_filter: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    triage_state_filter: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    label_filter: Option<String>,
    unhandled_only: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    since_filter: Option<i64>,
    #[serde(skip_serializing_if = "std::ops::Not::not")]
    would_handle: bool,
    #[serde(skip_serializing_if = "std::ops::Not::not")]
    dry_run: bool,
}

/// Individual event for robot mode
#[derive(serde::Serialize)]
struct RobotEventItem {
    id: i64,
    pane_id: u64,
    rule_id: String,
    pack_id: String,
    event_type: String,
    severity: String,
    confidence: f64,
    #[serde(skip_serializing_if = "Option::is_none")]
    extracted: Option<serde_json::Value>,
    /// Optional triage/annotation fields (bd-2gce)
    #[serde(skip_serializing_if = "Option::is_none")]
    annotations: Option<wa_core::storage::EventAnnotations>,
    captured_at: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    handled_at: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    workflow_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    would_handle_with: Option<RobotEventWouldHandle>,
}

/// Workflow preview for robot events dry-run
#[derive(serde::Serialize)]
struct RobotEventWouldHandle {
    workflow: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    preview_command: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    first_step: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    estimated_duration_ms: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    would_run: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    reason: Option<String>,
}

/// Robot event annotation/triage mutation response data (bd-2gce).
#[derive(serde::Serialize)]
struct RobotEventMutationData {
    event_id: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    changed: Option<bool>,
    annotations: wa_core::storage::EventAnnotations,
}

/// Workflow execution result for robot mode
#[derive(Debug, serde::Serialize)]
struct RobotWorkflowData {
    workflow_name: String,
    pane_id: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    execution_id: Option<String>,
    status: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    result: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    steps_executed: Option<usize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    step_index: Option<usize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    elapsed_ms: Option<u64>,
}

/// Robot why command response data (matches wa-robot-why.json schema)
#[derive(Debug, serde::Serialize)]
struct RobotWhyData {
    code: String,
    category: String,
    title: String,
    explanation: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    suggestions: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    see_also: Option<Vec<String>>,
}

/// Robot approve command response data (matches wa-robot-approve.json schema)
#[derive(Debug, serde::Serialize)]
struct RobotApproveData {
    code: String,
    valid: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    created_at: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    action_kind: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pane_id: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    expires_at: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    consumed_at: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    action_fingerprint: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    dry_run: Option<bool>,
}

/// Robot rules list response data
#[derive(Debug, serde::Serialize)]
struct RobotRulesListData {
    rules: Vec<RobotRuleItem>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pack_filter: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    agent_type_filter: Option<String>,
}

/// Individual rule item for robot mode
#[derive(Debug, serde::Serialize)]
struct RobotRuleItem {
    id: String,
    agent_type: String,
    event_type: String,
    severity: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    workflow: Option<String>,
    anchor_count: usize,
    has_regex: bool,
}

/// Robot rules test response data
#[derive(Debug, serde::Serialize)]
struct RobotRulesTestData {
    text_length: usize,
    match_count: usize,
    matches: Vec<RobotRuleMatchItem>,
}

/// Individual rule match item for robot mode
#[derive(Debug, serde::Serialize)]
struct RobotRuleMatchItem {
    rule_id: String,
    agent_type: String,
    event_type: String,
    severity: String,
    confidence: f64,
    matched_text: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    extracted: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    trace: Option<RobotRuleTraceInfo>,
}

/// Trace info for rule match
#[derive(Debug, serde::Serialize)]
struct RobotRuleTraceInfo {
    anchors_checked: bool,
    regex_matched: bool,
}

/// Robot rules show response data (full rule details)
#[derive(Debug, serde::Serialize)]
struct RobotRuleDetailData {
    id: String,
    agent_type: String,
    event_type: String,
    severity: String,
    description: String,
    anchors: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    regex: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    workflow: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    remediation: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    manual_fix: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    learn_more_url: Option<String>,
}

/// Robot rules lint response data
#[derive(Debug, serde::Serialize)]
struct RobotRulesLintData {
    total_rules: usize,
    rules_checked: usize,
    errors: Vec<RobotLintIssue>,
    warnings: Vec<RobotLintIssue>,
    /// Fixture coverage statistics (present when --fixtures flag used)
    #[serde(skip_serializing_if = "Option::is_none")]
    fixture_coverage: Option<RobotFixtureCoverage>,
    passed: bool,
}

/// Individual lint issue
#[derive(Debug, serde::Serialize)]
struct RobotLintIssue {
    rule_id: String,
    category: String,
    message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    suggestion: Option<String>,
}

/// Fixture coverage statistics
#[derive(Debug, serde::Serialize)]
#[allow(clippy::struct_field_names)]
struct RobotFixtureCoverage {
    rules_with_fixtures: usize,
    rules_without_fixtures: Vec<String>,
    total_fixtures: usize,
}

const RULE_ID_PREFIXES: &[&str] = &["codex.", "claude_code.", "gemini.", "wezterm."];

fn collect_fixture_rule_ids(
    dir: &Path,
    rules_with_fixtures: &mut HashSet<String>,
    total_fixtures: &mut usize,
) {
    let Ok(entries) = std::fs::read_dir(dir) else {
        return;
    };
    for entry in entries.flatten() {
        let path = entry.path();
        if path.is_dir() {
            collect_fixture_rule_ids(&path, rules_with_fixtures, total_fixtures);
        } else if path.extension().is_some_and(|ext| ext == "json")
            && path.to_string_lossy().contains(".expect.")
        {
            *total_fixtures += 1;
            if let Ok(content) = std::fs::read_to_string(&path) {
                if let Ok(val) = serde_json::from_str::<serde_json::Value>(&content) {
                    if let Some(arr) = val.as_array() {
                        for item in arr {
                            if let Some(rule_id) =
                                item.get("rule_id").and_then(serde_json::Value::as_str)
                            {
                                rules_with_fixtures.insert(rule_id.to_string());
                            }
                        }
                    }
                }
            }
        }
    }
}

#[derive(Debug)]
struct RobotApproveError {
    code: &'static str,
    message: String,
    hint: Option<String>,
}

impl RobotApproveError {
    fn new(code: &'static str, message: impl Into<String>, hint: Option<String>) -> Self {
        Self {
            code,
            message: message.into(),
            hint,
        }
    }
}

/// Robot workflow list response data (matches wa-robot-workflow-list.json schema)
#[derive(Debug, serde::Serialize)]
struct RobotWorkflowListData {
    workflows: Vec<RobotWorkflowInfo>,
    total: usize,
    #[serde(skip_serializing_if = "Option::is_none")]
    enabled_count: Option<usize>,
}

#[derive(Debug, serde::Serialize)]
struct RobotWorkflowInfo {
    name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    description: Option<String>,
    enabled: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    trigger_event_types: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    requires_pane: Option<bool>,
}

/// Robot workflow status response data (matches wa-robot-workflow-status.json schema)
#[derive(Debug, serde::Serialize)]
struct RobotWorkflowStatusData {
    execution_id: String,
    workflow_name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pane_id: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    trigger_event_id: Option<i64>,
    status: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    step_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    elapsed_ms: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    last_step_result: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    current_step: Option<usize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    total_steps: Option<usize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    wait_condition: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    context: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    result: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    started_at: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    updated_at: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    completed_at: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    step_logs: Option<Vec<RobotWorkflowStepLog>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    action_plan: Option<RobotWorkflowActionPlan>,
}

/// Robot workflow step log entry (matches wa-robot-workflow-status.json schema)
#[derive(Debug, serde::Serialize)]
struct RobotWorkflowStepLog {
    step_index: usize,
    step_name: String,
    result_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    step_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    step_kind: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    result_data: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    policy_summary: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    verification_refs: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error_code: Option<String>,
    started_at: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    completed_at: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    duration_ms: Option<i64>,
}

/// Robot workflow action plan entry
#[derive(Debug, serde::Serialize)]
struct RobotWorkflowActionPlan {
    plan_id: String,
    plan_hash: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    plan: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    created_at: Option<i64>,
}

/// Robot workflow status list response (for --pane or --active)
#[derive(Debug, serde::Serialize)]
struct RobotWorkflowStatusListData {
    executions: Vec<RobotWorkflowStatusData>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pane_filter: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    active_only: Option<bool>,
    count: usize,
}

/// Robot workflow abort response data (matches wa-robot-workflow-abort.json schema)
#[derive(Debug, serde::Serialize)]
struct RobotWorkflowAbortData {
    execution_id: String,
    aborted: bool,
    forced: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    workflow_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    previous_status: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    reason: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    aborted_at: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error_reason: Option<String>,
}

/// Account info for robot accounts list
#[derive(serde::Serialize)]
struct RobotAccountInfo {
    account_id: String,
    service: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    name: Option<String>,
    percent_remaining: f64,
    #[serde(skip_serializing_if = "Option::is_none")]
    reset_at: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    tokens_used: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    tokens_remaining: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    tokens_limit: Option<i64>,
    last_refreshed_at: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    last_used_at: Option<i64>,
}

/// Robot accounts list response data
#[derive(serde::Serialize)]
struct RobotAccountsListData {
    accounts: Vec<RobotAccountInfo>,
    total: usize,
    service: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pick_preview: Option<RobotAccountPickPreview>,
}

/// Pick preview shows which account would be selected next
#[derive(serde::Serialize)]
struct RobotAccountPickPreview {
    #[serde(skip_serializing_if = "Option::is_none")]
    selected_account_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    selected_name: Option<String>,
    selection_reason: String,
    threshold_percent: f64,
    candidates_count: usize,
    filtered_count: usize,
}

/// Robot accounts refresh response data
#[derive(serde::Serialize)]
struct RobotAccountsRefreshData {
    service: String,
    refreshed_count: usize,
    #[serde(skip_serializing_if = "Option::is_none")]
    refreshed_at: Option<String>,
    accounts: Vec<RobotAccountInfo>,
}

#[derive(serde::Serialize)]
struct RobotReservationInfo {
    id: i64,
    pane_id: u64,
    owner_kind: String,
    owner_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    reason: Option<String>,
    created_at: i64,
    expires_at: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    released_at: Option<i64>,
    status: String,
}

#[derive(serde::Serialize)]
struct RobotReserveData {
    reservation: RobotReservationInfo,
}

#[derive(serde::Serialize)]
struct RobotReleaseData {
    reservation_id: i64,
    released: bool,
}

#[derive(serde::Serialize)]
struct RobotReservationsListData {
    reservations: Vec<RobotReservationInfo>,
    total: usize,
}

fn redact_for_output(text: &str) -> String {
    static REDACTOR: LazyLock<wa_core::policy::Redactor> =
        LazyLock::new(wa_core::policy::Redactor::new);
    REDACTOR.redact(text)
}

fn search_lints_have_errors(lints: &[wa_core::storage::SearchLint]) -> bool {
    lints
        .iter()
        .any(|lint| lint.severity == wa_core::storage::SearchLintSeverity::Error)
}

fn format_search_lints_plain(lints: &[wa_core::storage::SearchLint]) -> String {
    let mut output = String::new();
    output.push_str("Query lint findings:\n");
    for lint in lints {
        let severity = match lint.severity {
            wa_core::storage::SearchLintSeverity::Error => "error",
            wa_core::storage::SearchLintSeverity::Warning => "warning",
        };
        output.push_str(&format!("  - [{severity}] {}\n", lint.message));
        if let Some(suggestion) = &lint.suggestion {
            output.push_str(&format!("    Suggestion: {suggestion}\n"));
        }
    }
    output
}

async fn resolve_bookmark_pane_ids(
    storage: &wa_core::storage::StorageHandle,
    bookmark_alias: Option<&str>,
    bookmark_tag: Option<&str>,
) -> std::result::Result<Option<HashSet<u64>>, String> {
    if bookmark_alias.is_none() && bookmark_tag.is_none() {
        return Ok(None);
    }

    let mut pane_ids = if let Some(alias) = bookmark_alias {
        let resolved = storage
            .get_pane_bookmark_by_alias(alias)
            .await
            .map_err(|e| format!("Failed to resolve bookmark alias \"{alias}\": {e}"))?;
        let mut alias_ids = HashSet::new();
        if let Some(record) = resolved {
            alias_ids.insert(record.pane_id);
        }
        Some(alias_ids)
    } else {
        None
    };

    if let Some(tag) = bookmark_tag {
        let records = storage
            .list_pane_bookmarks_by_tag(tag)
            .await
            .map_err(|e| format!("Failed to resolve bookmark tag \"{tag}\": {e}"))?;
        let tag_ids: HashSet<u64> = records.into_iter().map(|record| record.pane_id).collect();
        pane_ids = Some(match pane_ids {
            Some(existing_ids) => existing_ids.intersection(&tag_ids).copied().collect(),
            None => tag_ids,
        });
    }

    Ok(pane_ids)
}

fn format_saved_searches_plain(searches: &[wa_core::storage::SavedSearchRecord]) -> String {
    if searches.is_empty() {
        return "No saved searches.\n".to_string();
    }

    let mut output = String::new();
    output.push_str(&format!("Saved searches ({}):\n", searches.len()));
    for search in searches {
        let pane = search
            .pane_id
            .map(|id| id.to_string())
            .unwrap_or_else(|| "any".to_string());
        let last_run = search
            .last_run_at
            .map(|ts| ts.to_string())
            .unwrap_or_else(|| "never".to_string());
        let last_count = search
            .last_result_count
            .map(|count| count.to_string())
            .unwrap_or_else(|| "-".to_string());
        let enabled = if search.enabled { "on" } else { "off" };
        let schedule = search
            .schedule_interval_ms
            .map(|v| v.to_string())
            .unwrap_or_else(|| "-".to_string());
        let query = redact_for_output(&search.query);
        output.push_str(&format!(
            "  - {}: query=\"{}\" pane={} limit={} since_mode={} schedule_ms={} enabled={} last_run_at={} last_count={}\n",
            search.name,
            query,
            pane,
            search.limit,
            search.since_mode,
            schedule,
            enabled,
            last_run,
            last_count
        ));
        if let Some(err) = &search.last_error {
            output.push_str(&format!("    last_error: {err}\n"));
        }
    }
    output
}

fn format_search_lint_hint(lints: &[wa_core::storage::SearchLint]) -> Option<String> {
    let mut hint_lines = Vec::new();
    for lint in lints.iter().take(3) {
        let mut line = lint.message.clone();
        if let Some(suggestion) = &lint.suggestion {
            line.push_str(&format!(" (suggestion: {suggestion})"));
        }
        hint_lines.push(line);
    }
    if hint_lines.is_empty() {
        None
    } else {
        Some(hint_lines.join(" | "))
    }
}

async fn evaluate_robot_approve(
    storage: &wa_core::storage::StorageHandle,
    workspace_id: &str,
    code: &str,
    pane: Option<u64>,
    fingerprint: Option<&str>,
    dry_run: bool,
) -> Result<RobotApproveData, RobotApproveError> {
    evaluate_approve(
        storage,
        workspace_id,
        code,
        pane,
        fingerprint,
        dry_run,
        "robot",
    )
    .await
}

async fn evaluate_approve(
    storage: &wa_core::storage::StorageHandle,
    workspace_id: &str,
    code: &str,
    pane: Option<u64>,
    fingerprint: Option<&str>,
    dry_run: bool,
    actor_kind: &str,
) -> Result<RobotApproveData, RobotApproveError> {
    let code_hash = wa_core::approval::hash_allow_once_code(code);

    let token = match storage.get_approval_token(&code_hash).await {
        Ok(Some(t)) => t,
        Ok(None) => {
            return Err(RobotApproveError::new(
                "E_APPROVAL_NOT_FOUND",
                format!("No approval found with code: {code}"),
                Some(
                    "Approval codes are issued when policy requires approval. \
                     Check that you have the correct code."
                        .to_string(),
                ),
            ));
        }
        Err(e) => {
            return Err(RobotApproveError::new(
                ROBOT_ERR_STORAGE,
                format!("Failed to look up approval: {e}"),
                None,
            ));
        }
    };

    // Workspace scope check (explicit to provide E_WRONG_WORKSPACE)
    if token.workspace_id != workspace_id {
        return Err(RobotApproveError::new(
            "E_WRONG_WORKSPACE",
            format!(
                "Approval code is scoped to workspace '{}', but current workspace is '{}'",
                token.workspace_id, workspace_id
            ),
            Some("Use the approval code in the workspace where it was issued.".to_string()),
        ));
    }

    let now_ms = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map_or(0, |d| d.as_millis() as i64);

    if token.used_at.is_some() {
        return Err(RobotApproveError::new(
            "E_APPROVAL_CONSUMED",
            "Approval code has already been used".to_string(),
            Some(
                "Approval codes can only be used once. Request a new approval if needed."
                    .to_string(),
            ),
        ));
    }

    if token.expires_at < now_ms {
        return Err(RobotApproveError::new(
            "E_APPROVAL_EXPIRED",
            format!(
                "Approval code expired at {} (now: {})",
                token.expires_at, now_ms
            ),
            Some(
                "Approval codes have a limited validity period. Request a new approval."
                    .to_string(),
            ),
        ));
    }

    if let Some(expected_pane) = pane {
        if token.pane_id != Some(expected_pane) {
            return Err(RobotApproveError::new(
                "E_WRONG_PANE",
                format!(
                    "Approval was for pane {:?}, but --pane {} was specified",
                    token.pane_id, expected_pane
                ),
                Some("Use the correct pane ID or omit --pane.".to_string()),
            ));
        }
    }

    if let Some(expected_fingerprint) = fingerprint {
        if token.action_fingerprint != expected_fingerprint {
            return Err(RobotApproveError::new(
                "E_FINGERPRINT_MISMATCH",
                "Approval fingerprint does not match the requested action".to_string(),
                Some(
                    "The approval was issued for a different action. Request a new approval."
                        .to_string(),
                ),
            ));
        }
    }

    if dry_run {
        return Ok(RobotApproveData {
            code: code.to_string(),
            valid: true,
            created_at: Some(token.created_at as u64),
            action_kind: Some(token.action_kind),
            pane_id: token.pane_id,
            expires_at: Some(token.expires_at as u64),
            consumed_at: None,
            action_fingerprint: Some(token.action_fingerprint),
            dry_run: Some(true),
        });
    }

    let consumed_token = match storage
        .consume_approval_token_by_code(&code_hash, workspace_id)
        .await
    {
        Ok(Some(t)) => t,
        Ok(None) => {
            return Err(RobotApproveError::new(
                "E_APPROVAL_CONSUMED",
                "Approval code was consumed by another process".to_string(),
                Some(
                    "The approval was valid but consumed between validation and consumption. \
                     This is a race condition."
                        .to_string(),
                ),
            ));
        }
        Err(e) => {
            return Err(RobotApproveError::new(
                ROBOT_ERR_STORAGE,
                format!("Failed to consume approval: {e}"),
                None,
            ));
        }
    };

    let consumed_at = consumed_token.used_at.unwrap_or(now_ms);

    let audit = wa_core::storage::AuditActionRecord {
        id: 0,
        ts: consumed_at,
        actor_kind: actor_kind.to_string(),
        actor_id: None,
        correlation_id: None,
        pane_id: consumed_token.pane_id,
        domain: None,
        action_kind: "approve_allow_once".to_string(),
        policy_decision: "allow".to_string(),
        decision_reason: Some(format!(
            "{} submitted approval code",
            if actor_kind == "human" {
                "Human"
            } else {
                "Robot"
            }
        )),
        rule_id: None,
        input_summary: Some(format!(
            "wa approve {} for {} pane {:?}",
            code, consumed_token.action_kind, consumed_token.pane_id
        )),
        verification_summary: Some(format!(
            "code_hash={}, fingerprint={}",
            code_hash, consumed_token.action_fingerprint
        )),
        decision_context: None,
        result: "success".to_string(),
    };

    if let Err(e) = storage.record_audit_action_redacted(audit).await {
        tracing::warn!("Failed to record approval audit: {e}");
    }

    Ok(RobotApproveData {
        code: code.to_string(),
        valid: true,
        created_at: Some(consumed_token.created_at as u64),
        action_kind: Some(consumed_token.action_kind),
        pane_id: consumed_token.pane_id,
        expires_at: Some(consumed_token.expires_at as u64),
        consumed_at: Some(consumed_at as u64),
        action_fingerprint: Some(consumed_token.action_fingerprint),
        dry_run: None,
    })
}

const SEND_OSC_SEGMENT_LIMIT: usize = 200;

struct CapabilityResolution {
    capabilities: wa_core::policy::PaneCapabilities,
    warnings: Vec<String>,
}

async fn derive_osc_state_from_storage(
    storage: &wa_core::storage::StorageHandle,
    pane_id: u64,
) -> Result<Option<wa_core::ingest::Osc133State>, String> {
    let segments = storage
        .get_segments(pane_id, SEND_OSC_SEGMENT_LIMIT)
        .await
        .map_err(|e| format!("failed to read segments: {e}"))?;
    if segments.is_empty() {
        return Ok(None);
    }

    let mut state = wa_core::ingest::Osc133State::new();
    for segment in segments.iter().rev() {
        wa_core::ingest::process_osc133_output(&mut state, &segment.content);
    }

    if state.markers_seen == 0 {
        return Ok(None);
    }

    Ok(Some(state))
}

#[cfg(unix)]
async fn fetch_pane_state_from_ipc(
    socket_path: &Path,
    pane_id: u64,
) -> Result<Option<IpcPaneState>, String> {
    let client = wa_core::ipc::IpcClient::new(socket_path);
    match client.pane_state(pane_id).await {
        Ok(response) => {
            if !response.ok {
                let detail = response
                    .error
                    .unwrap_or_else(|| "unknown error".to_string());
                return Err(detail);
            }
            if let Some(data) = response.data {
                serde_json::from_value::<IpcPaneState>(data)
                    .map(Some)
                    .map_err(|e| format!("invalid pane state payload: {e}"))
            } else {
                Ok(None)
            }
        }
        Err(err) => Err(err.to_string()),
    }
}

#[cfg(not(unix))]
async fn fetch_pane_state_from_ipc(
    _socket_path: &Path,
    _pane_id: u64,
) -> Result<Option<IpcPaneState>, String> {
    Err("IPC not supported on this platform".to_string())
}

fn resolve_alt_screen_state(state: &IpcPaneState) -> Option<bool> {
    if !state.known {
        return None;
    }
    if let Some(cursor_state) = state.cursor_alt_screen {
        return Some(cursor_state);
    }
    if state.last_status_at.is_some() {
        return state.alt_screen;
    }
    None
}

async fn resolve_pane_capabilities(
    pane_id: u64,
    storage: Option<&wa_core::storage::StorageHandle>,
    ipc_socket_path: Option<&Path>,
) -> CapabilityResolution {
    let mut warnings = Vec::new();
    let mut osc_state = None;

    if let Some(storage) = storage {
        match derive_osc_state_from_storage(storage, pane_id).await {
            Ok(state) => osc_state = state,
            Err(err) => warnings.push(format!("OSC 133 state unavailable: {err}")),
        }
    } else {
        warnings.push("Storage unavailable; prompt state unknown.".to_string());
    }

    let mut alt_screen = None;
    let mut in_gap = true;
    let mut gap_known = false;

    if let Some(socket_path) = ipc_socket_path {
        match fetch_pane_state_from_ipc(socket_path, pane_id).await {
            Ok(Some(state)) => {
                if state.pane_id != pane_id {
                    warnings.push(format!(
                        "Watcher returned state for pane {} (expected {})",
                        state.pane_id, pane_id
                    ));
                }
                if !state.known {
                    let reason = state.reason.as_deref().unwrap_or("unknown");
                    warnings.push(format!("Watcher has no state for this pane ({reason})."));
                } else if state.observed == Some(false) {
                    warnings.push(
                        "Pane is not observed by watcher; state may be incomplete.".to_string(),
                    );
                }
                alt_screen = resolve_alt_screen_state(&state);
                if state.in_gap.is_some() {
                    gap_known = true;
                    in_gap = state.in_gap.unwrap_or(true);
                }
                if alt_screen.is_none() {
                    warnings
                        .push("Alt-screen state unknown; approval may be required.".to_string());
                }
                if in_gap {
                    if gap_known {
                        warnings.push(
                            "Recent capture gap detected; approval may be required.".to_string(),
                        );
                    } else {
                        warnings.push(
                            "Capture continuity unknown; treating as recent gap.".to_string(),
                        );
                    }
                } else if !gap_known {
                    warnings
                        .push("Capture continuity unknown; treating as recent gap.".to_string());
                }
            }
            Ok(None) => {
                warnings.push("Watcher IPC returned no pane state.".to_string());
            }
            Err(err) => {
                warnings.push(format!("Watcher IPC unavailable: {err}"));
            }
        }
    } else {
        warnings.push("IPC socket unavailable; alt-screen/gap unknown.".to_string());
    }

    let capabilities = wa_core::policy::PaneCapabilities::from_ingest_state(
        osc_state.as_ref(),
        alt_screen,
        in_gap,
    );

    CapabilityResolution {
        capabilities,
        warnings,
    }
}

fn build_send_dry_run_report(
    command_ctx: &wa_core::dry_run::CommandContext,
    pane_id: u64,
    pane_info: Option<&wa_core::wezterm::PaneInfo>,
    capabilities: Option<&wa_core::policy::PaneCapabilities>,
    text: &str,
    no_paste: bool,
    wait_for: Option<&str>,
    timeout_secs: u64,
    config: &wa_core::config::Config,
    actor_kind: wa_core::policy::ActorKind,
) -> wa_core::dry_run::DryRunReport {
    use wa_core::dry_run::{
        PolicyCheck, TargetResolution, build_send_policy_evaluation, create_send_action,
        create_wait_for_action,
    };
    use wa_core::policy::{ActionKind, PaneCapabilities, PolicyEngine, PolicyInput};

    let mut ctx = command_ctx.dry_run_context();

    // Target resolution (best-effort)
    let domain = pane_info
        .map(|info| info.inferred_domain())
        .unwrap_or_else(|| "unknown".to_string());
    if let Some(info) = pane_info {
        let mut target =
            TargetResolution::new(pane_id, domain.clone()).with_is_active(info.is_active);
        if let Some(title) = &info.title {
            target = target.with_title(title.clone());
        }
        if let Some(cwd) = &info.cwd {
            target = target.with_cwd(cwd.clone());
        }
        ctx.set_target(target);
    } else {
        ctx.set_target(TargetResolution::new(pane_id, "unknown"));
        ctx.add_warning("Pane metadata unavailable; ensure WezTerm is running and pane exists.");
    }

    // Policy evaluation (best-effort; uses config defaults + assumed prompt state)
    let capabilities_opt = capabilities;
    let capabilities = capabilities_opt
        .cloned()
        .unwrap_or_else(PaneCapabilities::prompt);
    let mut eval = build_send_policy_evaluation(
        (0, config.safety.rate_limit_per_pane),
        capabilities.prompt_active,
        config.safety.require_prompt_active,
        capabilities.has_recent_gap,
    );

    let mut engine = PolicyEngine::new(
        config.safety.rate_limit_per_pane,
        config.safety.rate_limit_global,
        config.safety.require_prompt_active,
    )
    .with_command_gate_config(config.safety.command_gate.clone())
    .with_policy_rules(config.safety.rules.clone());

    let summary = engine.redact_secrets(text);
    let mut input = PolicyInput::new(ActionKind::SendText, actor_kind)
        .with_pane(pane_id)
        .with_domain(domain.clone())
        .with_capabilities(capabilities.clone())
        .with_text_summary(summary)
        .with_command_text(text);
    if let Some(info) = pane_info {
        if let Some(title) = &info.title {
            input = input.with_pane_title(title.clone());
        }
        if let Some(cwd) = &info.cwd {
            input = input.with_pane_cwd(cwd.clone());
        }
    }

    let decision = engine.authorize(&input);
    let mut decision_check = PolicyCheck::from(&decision);
    if let Some(rule_id) = decision.rule_id() {
        decision_check = decision_check.with_details(format!("rule: {rule_id}"));
    }
    eval.add_check(decision_check);
    if let Some(context) = decision.context() {
        if let Some(rule) = context
            .rules_evaluated
            .iter()
            .find(|rule| rule.rule_id.starts_with("command."))
        {
            let reason = rule
                .reason
                .as_deref()
                .unwrap_or("Command safety gate triggered");
            let message = match rule.decision.as_deref() {
                Some("require_approval") => format!("Approval required: {reason}"),
                Some("deny") => reason.to_string(),
                Some("allow") => reason.to_string(),
                _ => reason.to_string(),
            };
            let mut check = if matches!(rule.decision.as_deref(), Some("allow")) {
                PolicyCheck::passed("command_safety", message)
            } else {
                PolicyCheck::failed("command_safety", message)
            };
            check = check.with_details(format!("rule: {}", rule.rule_id));
            eval.add_check(check);
        } else if let Some(rule) = context
            .rules_evaluated
            .iter()
            .find(|rule| rule.rule_id == "policy.command_gate")
        {
            let message = rule
                .reason
                .clone()
                .unwrap_or_else(|| "Command gate evaluated".to_string());
            let check = PolicyCheck::passed("command_safety", message)
                .with_details(format!("rule: {}", rule.rule_id));
            eval.add_check(check);
        } else {
            eval.add_check(PolicyCheck::passed(
                "command_safety",
                "Command gate not evaluated (blocked earlier)",
            ));
        }
    } else {
        eval.add_check(PolicyCheck::passed(
            "command_safety",
            "Command gate context unavailable",
        ));
    }
    ctx.set_policy_evaluation(eval);

    if let Some(provided_caps) = capabilities_opt {
        if provided_caps.alt_screen == Some(true) {
            ctx.add_warning("Pane is in alt-screen; send will be denied by policy.");
        } else if provided_caps.alt_screen.is_none() {
            ctx.add_warning("Alt-screen state unknown; approval may be required.");
        }
        if provided_caps.has_recent_gap {
            ctx.add_warning("Recent capture gap detected; approval may be required.");
        }
        if config.safety.require_prompt_active && !provided_caps.prompt_active {
            ctx.add_warning("Prompt not active; approval or denial likely.");
        }
    }

    // Expected actions
    ctx.add_action(create_send_action(1, pane_id, text.len()));
    if let Some(pattern) = wait_for {
        let timeout_ms = timeout_secs.saturating_mul(1000);
        ctx.add_action(create_wait_for_action(2, pattern, timeout_ms));
    }

    if no_paste {
        ctx.add_warning("no_paste mode sends characters individually (slower)");
    }

    ctx.take_report()
}

fn build_prepare_send_plan(
    workspace_id: &str,
    pane_id: u64,
    text: &str,
    no_paste: bool,
    no_newline: bool,
    wait_for: Option<&str>,
    wait_for_regex: bool,
    timeout_secs: u64,
) -> wa_core::plan::ActionPlan {
    use wa_core::plan::{ActionPlan, StepAction, StepPlan};

    let send_step = StepPlan::new(
        1,
        StepAction::Custom {
            action_type: "prepare.send_text".to_string(),
            payload: serde_json::json!({
                "pane_id": pane_id,
                "text": text,
                "no_paste": no_paste,
                "no_newline": no_newline,
            }),
        },
        "Send text to pane",
    )
    .idempotent();

    let mut builder = ActionPlan::builder(
        format!("Send text to pane {pane_id}"),
        workspace_id.to_string(),
    )
    .add_step(send_step)
    .created_at(now_ms_i64());

    if let Some(pattern) = wait_for {
        let wait_step = StepPlan::new(
            2,
            StepAction::Custom {
                action_type: "prepare.wait_for".to_string(),
                payload: serde_json::json!({
                    "pane_id": pane_id,
                    "pattern": pattern,
                    "is_regex": wait_for_regex,
                    "timeout_ms": timeout_secs.saturating_mul(1000),
                }),
            },
            "Wait for verification pattern",
        );
        builder = builder.add_step(wait_step);
    }

    builder.build()
}

fn redact_prepare_plan(plan: &wa_core::plan::ActionPlan) -> wa_core::plan::ActionPlan {
    let mut redacted = plan.clone();
    let redactor = wa_core::policy::Redactor::new();

    for step in &mut redacted.steps {
        if let wa_core::plan::StepAction::Custom {
            action_type,
            payload,
        } = &mut step.action
        {
            if action_type == "prepare.send_text" {
                redact_payload_field(payload, "text", &redactor);
            } else if action_type == "prepare.wait_for" {
                redact_payload_field(payload, "pattern", &redactor);
            }
        }
    }

    redacted
}

fn prepare_audit_action_kind(action_kind: &str) -> String {
    format!("prepare.{action_kind}")
}

fn commit_audit_action_kind(action_kind: &str) -> String {
    format!("commit.{action_kind}")
}

fn build_plan_audit_context(
    plan_id: &str,
    plan_hash: &str,
    stage: &str,
    action_kind: &str,
    pane_id: Option<u64>,
) -> String {
    serde_json::json!({
        "correlation_id": plan_hash,
        "plan_id": plan_id,
        "plan_hash": plan_hash,
        "stage": stage,
        "action_kind": action_kind,
        "pane_id": pane_id,
    })
    .to_string()
}

fn redact_payload_field(
    payload: &mut serde_json::Value,
    field: &str,
    redactor: &wa_core::policy::Redactor,
) {
    let Some(obj) = payload.as_object_mut() else {
        return;
    };
    let Some(value) = obj.get_mut(field) else {
        return;
    };
    let Some(text) = value.as_str() else {
        return;
    };

    let len = serde_json::Number::from(text.len() as u64);
    let redacted = redactor.redact(text);
    *value = serde_json::Value::String(redacted);
    obj.insert(format!("{field}_len"), serde_json::Value::Number(len));
}

async fn generate_workflow_plan(
    storage: &std::sync::Arc<wa_core::storage::StorageHandle>,
    workflow: &std::sync::Arc<dyn wa_core::workflows::Workflow>,
    workspace_id: &str,
    pane_id: u64,
    execution_id: &str,
) -> wa_core::plan::ActionPlan {
    use wa_core::workflows::{PaneMetadata, WorkflowContext, workflow_to_action_plan};

    let mut ctx = WorkflowContext::new(
        std::sync::Arc::clone(storage),
        pane_id,
        wa_core::policy::PaneCapabilities::default(),
        execution_id,
    );
    if let Ok(Some(record)) = storage.get_pane(pane_id).await {
        ctx.set_pane_meta(PaneMetadata {
            domain: Some(record.domain),
            title: record.title,
            cwd: record.cwd,
        });
    }

    if let Some(plan) = workflow.to_action_plan(&ctx, execution_id) {
        plan
    } else {
        workflow_to_action_plan(workflow.as_ref(), workspace_id, pane_id, execution_id)
    }
}

fn build_workflow_by_name(
    name: &str,
    config: &wa_core::config::Config,
) -> Option<std::sync::Arc<dyn wa_core::workflows::Workflow>> {
    use std::sync::Arc;
    use wa_core::workflows::{HandleCompaction, Workflow};

    let workflows: Vec<Arc<dyn Workflow>> = vec![
        Arc::new(
            HandleCompaction::new().with_prompt_config(config.workflows.compaction_prompts.clone()),
        ),
        Arc::new(wa_core::workflows::HandleUsageLimits::new()),
        Arc::new(wa_core::workflows::HandleSessionEnd::new()),
        Arc::new(wa_core::workflows::HandleAuthRequired::new()),
        Arc::new(wa_core::workflows::HandleClaudeCodeLimits::new()),
        Arc::new(wa_core::workflows::HandleGeminiQuota::new()),
    ];

    workflows.into_iter().find(|wf| wf.name() == name)
}

fn now_ms_i64() -> i64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map_or(0, |d| d.as_millis() as i64)
}

/// Parse a human-friendly duration string into milliseconds.
///
/// Supports: "30s", "5m", "1h", "7d", "2w". Returns `None` if the format is invalid.
fn parse_duration_to_ms(s: &str) -> Option<i64> {
    let s = s.trim();
    if s.is_empty() {
        return None;
    }
    let (num_str, suffix) = s.split_at(s.len().saturating_sub(1));
    let value: i64 = num_str.parse().ok()?;
    if value < 0 {
        return None;
    }
    let multiplier: i64 = match suffix {
        "s" => 1_000,
        "m" => 60_000,
        "h" => 3_600_000,
        "d" => 86_400_000,
        "w" => 604_800_000,
        _ => return None,
    };
    value.checked_mul(multiplier)
}

fn resolve_prepare_output_format(format: &str) -> wa_core::output::OutputFormat {
    use wa_core::output::{OutputFormat, detect_format};

    match format.to_lowercase().as_str() {
        "json" => OutputFormat::Json,
        "plain" => OutputFormat::Plain,
        "auto" => detect_format(),
        _ => {
            eprintln!("Error: Unknown output format '{format}'. Use plain or json.");
            std::process::exit(1);
        }
    }
}

fn build_prepare_output(
    plan: &wa_core::plan::ActionPlan,
    plan_hash: &str,
    expires_at: i64,
    action_kind: &str,
    pane_id: Option<u64>,
    approval_request: Option<&wa_core::policy::ApprovalRequest>,
    commit_command: String,
) -> PrepareOutput {
    let approval = approval_request.map(|request| PrepareApprovalOutput {
        code: request.allow_once_code.clone(),
        expires_at: request.expires_at,
        expires_at_iso: format_epoch_ms(request.expires_at),
    });

    PrepareOutput {
        plan_id: plan.plan_id.to_string(),
        plan_hash: plan_hash.to_string(),
        expires_at,
        expires_at_iso: format_epoch_ms(expires_at),
        action_kind: action_kind.to_string(),
        pane_id,
        requires_approval: approval_request.is_some(),
        approval,
        commit: PrepareCommitHint {
            command: commit_command,
        },
        plan: plan.clone(),
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
enum CommitValidationError {
    NotFound,
    WorkspaceMismatch,
    Expired,
    Consumed,
    MissingParams,
    ActionKindMismatch,
    HashMismatch,
    PaneMismatch,
}

fn require_prepared_plan(
    record: Option<wa_core::storage::PreparedPlanRecord>,
) -> Result<wa_core::storage::PreparedPlanRecord, CommitValidationError> {
    record.ok_or(CommitValidationError::NotFound)
}

fn validate_prepared_plan_record(
    record: &wa_core::storage::PreparedPlanRecord,
    workspace_id: &str,
    now: i64,
) -> Result<(), CommitValidationError> {
    if record.workspace_id != workspace_id {
        return Err(CommitValidationError::WorkspaceMismatch);
    }
    if record.expires_at < now {
        return Err(CommitValidationError::Expired);
    }
    if record.consumed_at.is_some() {
        return Err(CommitValidationError::Consumed);
    }
    Ok(())
}

fn parse_prepared_plan_params(
    record: &wa_core::storage::PreparedPlanRecord,
) -> Result<PreparedPlanParams, CommitValidationError> {
    record
        .params_json
        .as_deref()
        .and_then(|json| serde_json::from_str::<PreparedPlanParams>(json).ok())
        .ok_or(CommitValidationError::MissingParams)
}

fn ensure_action_kind(
    record: &wa_core::storage::PreparedPlanRecord,
    expected: &str,
) -> Result<(), CommitValidationError> {
    if record.action_kind != expected {
        return Err(CommitValidationError::ActionKindMismatch);
    }
    Ok(())
}

fn ensure_plan_hash(expected: &str, actual: &str) -> Result<(), CommitValidationError> {
    if expected != actual {
        return Err(CommitValidationError::HashMismatch);
    }
    Ok(())
}

fn ensure_pane_uuid_matches(
    expected: Option<&str>,
    actual: Option<&str>,
) -> Result<(), CommitValidationError> {
    if let Some(expected) = expected {
        if actual != Some(expected) {
            return Err(CommitValidationError::PaneMismatch);
        }
    }
    Ok(())
}

fn commit_validation_message(
    err: CommitValidationError,
    plan_id: &str,
) -> (String, Option<String>) {
    match err {
        CommitValidationError::NotFound => (
            format!("Error: Plan not found: {plan_id} (E_PLAN_NOT_FOUND)"),
            Some("Hint: Re-run `wa prepare ...` and try again.".to_string()),
        ),
        CommitValidationError::WorkspaceMismatch => (
            "Error: Plan workspace mismatch (E_PLAN_WORKSPACE_MISMATCH).".to_string(),
            None,
        ),
        CommitValidationError::Expired => (
            "Error: Plan expired (E_PLAN_EXPIRED).".to_string(),
            Some("Hint: Re-run `wa prepare ...` and try again.".to_string()),
        ),
        CommitValidationError::Consumed => (
            "Error: Plan already consumed (E_PLAN_CONSUMED).".to_string(),
            None,
        ),
        CommitValidationError::MissingParams => (
            "Error: Prepared plan params missing or invalid.".to_string(),
            None,
        ),
        CommitValidationError::ActionKindMismatch => (
            "Error: Prepared plan action kind mismatch.".to_string(),
            None,
        ),
        CommitValidationError::HashMismatch => (
            "Error: Plan hash mismatch (E_PLAN_HASH_MISMATCH).".to_string(),
            Some("Hint: Re-run `wa prepare ...` and try again.".to_string()),
        ),
        CommitValidationError::PaneMismatch => (
            "Error: Pane identity changed (E_PLAN_PANE_MISMATCH).".to_string(),
            Some("Hint: Re-run `wa prepare ...` for the current pane.".to_string()),
        ),
    }
}

fn exit_on_commit_validation_error(err: CommitValidationError, plan_id: &str) -> ! {
    let (message, hint) = commit_validation_message(err, plan_id);
    eprintln!("{message}");
    if let Some(hint) = hint {
        eprintln!("{hint}");
    }
    std::process::exit(1);
}

fn format_send_result_human(
    data: &HumanSendData,
    redacted_text: &str,
    redacted_wait_for: Option<&str>,
) -> String {
    use std::fmt::Write as _;
    use wa_core::policy::{InjectionResult, PolicyDecision};

    let mut output = String::new();
    let status = match data.injection {
        InjectionResult::Allowed { .. } => "allowed",
        InjectionResult::Denied { .. } => "denied",
        InjectionResult::RequiresApproval { .. } => "approval_required",
        InjectionResult::Error { .. } => "error",
    };

    let mut reason = None;
    let mut approval = None;
    if let InjectionResult::Denied { decision, .. }
    | InjectionResult::RequiresApproval { decision, .. } = &data.injection
    {
        match decision {
            PolicyDecision::Deny { reason: r, .. } => reason = Some(r.as_str()),
            PolicyDecision::RequireApproval {
                reason: r,
                approval: a,
                ..
            } => {
                reason = Some(r.as_str());
                approval = a.as_ref();
            }
            PolicyDecision::Allow { .. } => {}
        }
    }

    if let InjectionResult::Error { error, .. } = &data.injection {
        reason = Some(error.as_str());
    }

    let _ = writeln!(output, "Send result");
    let _ = writeln!(output, "  Pane: {}", data.pane_id);
    let _ = writeln!(output, "  Status: {status}");
    let _ = writeln!(output, "  Text: {redacted_text}");

    if data.no_paste {
        let _ = writeln!(output, "  Mode: no-paste");
    }
    if data.no_newline {
        let _ = writeln!(output, "  Newline: suppressed");
    }

    if let Some(rule_id) = data.injection.rule_id() {
        let _ = writeln!(output, "  Rule: {rule_id}");
    }
    if let Some(reason) = reason {
        let _ = writeln!(output, "  Reason: {reason}");
    }
    if let Some(approval) = approval {
        let _ = writeln!(output, "  Approval: {}", approval.summary);
        let _ = writeln!(output, "  Command: {}", approval.command);
    }
    if let Some(audit_id) = data.injection.audit_action_id() {
        let _ = writeln!(output, "  Audit ID: {audit_id}");
    }

    if let Some(wait_for) = &data.wait_for {
        let status = if wait_for.matched {
            "matched"
        } else {
            "timed out"
        };
        let regex = if wait_for.is_regex { " (regex)" } else { "" };
        let _ = writeln!(
            output,
            "  Wait-for{regex}: {} ({status}, {} ms, {} polls)",
            wait_for.pattern, wait_for.elapsed_ms, wait_for.polls
        );
    } else if redacted_wait_for.is_some() && !data.injection.is_allowed() {
        let _ = writeln!(output, "  Wait-for: skipped (send not executed)");
    }

    if let Some(err) = data.verification_error.as_deref() {
        let _ = writeln!(output, "  Verification: {err}");
    }

    output
}

fn resolve_workflow(
    name: &str,
    workflows_config: &wa_core::config::WorkflowsConfig,
) -> Option<std::sync::Arc<dyn wa_core::workflows::Workflow>> {
    match name {
        "handle_compaction" => Some(std::sync::Arc::new(
            wa_core::workflows::HandleCompaction::new()
                .with_prompt_config(workflows_config.compaction_prompts.clone()),
        )),
        "handle_usage_limits" => Some(std::sync::Arc::new(
            wa_core::workflows::HandleUsageLimits::new(),
        )),
        "handle_claude_code_limits" => Some(std::sync::Arc::new(
            wa_core::workflows::HandleClaudeCodeLimits::new(),
        )),
        "handle_gemini_quota" => Some(std::sync::Arc::new(
            wa_core::workflows::HandleGeminiQuota::new(),
        )),
        _ => None,
    }
}

/// Map a plan `StepAction` to the dry-run `ActionType`.
///
/// For `Custom` actions (the default from `steps_to_plans()`), infer the type
/// from the action_type string which encodes `workflow_step:<step_name>`.
fn step_action_to_dry_run_type(action: &wa_core::plan::StepAction) -> wa_core::dry_run::ActionType {
    use wa_core::dry_run::ActionType;
    use wa_core::plan::StepAction;
    match action {
        StepAction::SendText { .. } => ActionType::SendText,
        StepAction::WaitFor { .. } => ActionType::WaitFor,
        StepAction::AcquireLock { .. } => ActionType::AcquireLock,
        StepAction::ReleaseLock { .. } => ActionType::ReleaseLock,
        StepAction::StoreData { .. } => ActionType::StoreData,
        StepAction::RunWorkflow { .. } => ActionType::WorkflowStep,
        StepAction::MarkEventHandled { .. } => ActionType::MarkEventHandled,
        StepAction::ValidateApproval { .. } => ActionType::ValidateApproval,
        StepAction::NestedPlan { .. } => ActionType::WorkflowStep,
        StepAction::Custom { action_type, .. } => infer_action_type_from_name(action_type),
    }
}

/// Infer a dry-run `ActionType` from a step/action name string.
fn infer_action_type_from_name(name: &str) -> wa_core::dry_run::ActionType {
    use wa_core::dry_run::ActionType;
    let lower = name.to_lowercase();
    if lower.contains("send") {
        ActionType::SendText
    } else if lower.contains("wait")
        || lower.contains("stabilize")
        || lower.contains("verify")
        || lower.contains("check")
    {
        ActionType::WaitFor
    } else if lower.contains("lock") {
        ActionType::AcquireLock
    } else if lower.contains("mark") && lower.contains("handled") {
        ActionType::MarkEventHandled
    } else {
        ActionType::WorkflowStep
    }
}

/// Extract metadata from a `StepPlan` for the dry-run report.
fn step_plan_metadata(step: &wa_core::plan::StepPlan) -> serde_json::Value {
    use wa_core::plan::StepAction;
    let mut meta = serde_json::Map::new();

    meta.insert(
        "step_id".to_string(),
        serde_json::Value::String(step.step_id.to_string()),
    );
    meta.insert(
        "idempotent".to_string(),
        serde_json::Value::Bool(step.idempotent),
    );

    if let Some(timeout_ms) = step.timeout_ms {
        meta.insert(
            "timeout_ms".to_string(),
            serde_json::Value::Number(timeout_ms.into()),
        );
    }

    if !step.preconditions.is_empty() {
        meta.insert(
            "precondition_count".to_string(),
            serde_json::Value::Number(step.preconditions.len().into()),
        );
    }

    if step.verification.is_some() {
        meta.insert(
            "has_verification".to_string(),
            serde_json::Value::Bool(true),
        );
    }

    // Action-specific metadata
    match &step.action {
        StepAction::SendText {
            pane_id,
            text,
            paste_mode,
        } => {
            meta.insert("policy_gated".to_string(), serde_json::Value::Bool(true));
            meta.insert(
                "pane_id".to_string(),
                serde_json::Value::Number((*pane_id).into()),
            );
            meta.insert(
                "text_len".to_string(),
                serde_json::Value::Number(text.len().into()),
            );
            // Show truncated preview (redacted at report level)
            let preview = if text.len() > 60 {
                format!("{}...", &text[..60])
            } else {
                text.clone()
            };
            meta.insert(
                "text_preview".to_string(),
                serde_json::Value::String(preview),
            );
            if let Some(paste) = paste_mode {
                meta.insert("paste_mode".to_string(), serde_json::Value::Bool(*paste));
            }
        }
        StepAction::WaitFor {
            pane_id,
            condition,
            timeout_ms,
        } => {
            if let Some(pid) = pane_id {
                meta.insert(
                    "pane_id".to_string(),
                    serde_json::Value::Number((*pid).into()),
                );
            }
            meta.insert(
                "wait_timeout_ms".to_string(),
                serde_json::Value::Number((*timeout_ms).into()),
            );
            meta.insert(
                "condition".to_string(),
                serde_json::Value::String(condition.canonical_string()),
            );
        }
        StepAction::AcquireLock {
            lock_name,
            timeout_ms,
        } => {
            meta.insert(
                "lock_name".to_string(),
                serde_json::Value::String(lock_name.clone()),
            );
            if let Some(t) = timeout_ms {
                meta.insert(
                    "lock_timeout_ms".to_string(),
                    serde_json::Value::Number((*t).into()),
                );
            }
        }
        StepAction::ReleaseLock { lock_name } => {
            meta.insert(
                "lock_name".to_string(),
                serde_json::Value::String(lock_name.clone()),
            );
        }
        StepAction::Custom {
            action_type,
            payload,
        } => {
            meta.insert(
                "custom_action_type".to_string(),
                serde_json::Value::String(action_type.clone()),
            );
            meta.insert("custom_payload".to_string(), payload.clone());
        }
        _ => {}
    }

    serde_json::Value::Object(meta)
}

fn build_workflow_dry_run_report(
    command_ctx: &wa_core::dry_run::CommandContext,
    name: &str,
    pane: u64,
    pane_info: Option<&wa_core::wezterm::PaneInfo>,
    config: &wa_core::config::Config,
) -> wa_core::dry_run::DryRunReport {
    use wa_core::dry_run::{
        ActionType, PlannedAction, PolicyCheck, PolicyEvaluation, TargetResolution,
    };

    let mut ctx = command_ctx.dry_run_context();

    // Target resolution
    if let Some(info) = pane_info {
        let mut target =
            TargetResolution::new(pane, info.inferred_domain()).with_is_active(info.is_active);
        if let Some(title) = &info.title {
            target = target.with_title(title.clone());
        }
        if let Some(cwd) = &info.cwd {
            target = target.with_cwd(cwd.clone());
        }
        ctx.set_target(target);
    } else {
        ctx.set_target(TargetResolution::new(pane, "unknown"));
        ctx.add_warning("Pane metadata unavailable; verify pane ID and daemon state.");
    }

    // Policy evaluation for workflow
    let mut eval = PolicyEvaluation::new();
    let workflow = resolve_workflow(name, &config.workflows);
    match workflow.as_ref() {
        Some(wf) => {
            eval.add_check(PolicyCheck::passed(
                "workflow",
                format!("Workflow '{name}' loaded"),
            ));
            if wf.is_enabled() {
                eval.add_check(PolicyCheck::passed(
                    "workflow_enabled",
                    "Workflow is enabled",
                ));
            } else {
                eval.add_check(PolicyCheck::failed(
                    "workflow_enabled",
                    "Workflow is disabled",
                ));
            }

            if wf.requires_approval() {
                eval.add_check(PolicyCheck::failed(
                    "approval",
                    "Workflow requires approval",
                ));
            } else {
                eval.add_check(PolicyCheck::passed("approval", "No approval required"));
            }

            if wf.is_destructive() {
                eval.add_check(PolicyCheck::failed(
                    "destructive",
                    "Workflow marked destructive",
                ));
            } else {
                eval.add_check(PolicyCheck::passed(
                    "destructive",
                    "Workflow marked non-destructive",
                ));
            }
        }
        None => {
            eval.add_check(PolicyCheck::failed(
                "workflow",
                format!("Workflow '{name}' not found"),
            ));
        }
    }

    if pane_info.is_some() {
        eval.add_check(PolicyCheck::passed("pane", "Pane found"));
    } else {
        eval.add_check(PolicyCheck::failed(
            "pane",
            "Pane not found (dry-run uses best-effort resolution)",
        ));
    }

    eval.add_check(
        PolicyCheck::passed("pane_state", "Pane state not inspected during dry-run")
            .with_details("Verify prompt/alt-screen state before execution."),
    );
    eval.add_check(
        PolicyCheck::passed("policy", "Policy checks deferred to execution")
            .with_details("Send steps remain policy-gated at runtime."),
    );
    ctx.set_policy_evaluation(eval);

    // Expected workflow steps  use structured StepPlans when available
    if let Some(wf) = workflow.as_ref() {
        let mut step = 1u32;

        // Step 1: Acquire workflow lock
        ctx.add_action(PlannedAction::new(
            step,
            ActionType::AcquireLock,
            format!("Acquire workflow lock for pane {pane}"),
        ));
        step += 1;

        // Workflow body steps via structured StepPlan
        let step_plans = wf.steps_to_plans(pane);
        for sp in &step_plans {
            let action_type = step_action_to_dry_run_type(&sp.action);
            let mut description = sp.description.clone();
            if action_type == ActionType::SendText {
                description.push_str(" [policy-gated]");
            }
            let mut meta = step_plan_metadata(sp);
            if action_type == ActionType::SendText {
                if let serde_json::Value::Object(ref mut map) = meta {
                    map.insert("policy_gated".to_string(), serde_json::Value::Bool(true));
                }
            }
            let action = PlannedAction::new(step, action_type, description).with_metadata(meta);
            ctx.add_action(action);
            step += 1;
        }

        // Mark event handled (if workflow has triggers)
        let trigger_event_types = wf.trigger_event_types();
        let trigger_rule_ids = wf.trigger_rule_ids();
        if !trigger_event_types.is_empty() || !trigger_rule_ids.is_empty() {
            let mut details = Vec::new();
            if !trigger_event_types.is_empty() {
                details.push(format!("event types: {}", trigger_event_types.join(", ")));
            }
            if !trigger_rule_ids.is_empty() {
                details.push(format!("rule ids: {}", trigger_rule_ids.join(", ")));
            }
            let suffix = details.join("; ");
            ctx.add_action(PlannedAction::new(
                step,
                ActionType::MarkEventHandled,
                format!("Mark triggering event handled ({suffix})"),
            ));
            step += 1;
        }

        // Final step: Release lock
        ctx.add_action(PlannedAction::new(
            step,
            ActionType::ReleaseLock,
            "Release workflow lock".to_string(),
        ));
    } else {
        ctx.add_warning("No workflow steps available; check workflow name.");
    }

    ctx.take_report()
}

fn workflow_enabled(workflow: &str, config: &wa_core::config::WorkflowsConfig) -> bool {
    if config.enabled.is_empty() {
        return true;
    }
    config.enabled.iter().any(|name| name == workflow)
}

fn workflow_auto_run(workflow: &str, config: &wa_core::config::WorkflowsConfig) -> bool {
    if config.auto_run_denylist.iter().any(|name| name == workflow) {
        return false;
    }
    if config.auto_run_allowlist.is_empty() {
        return true;
    }
    config
        .auto_run_allowlist
        .iter()
        .any(|name| name == workflow)
}

fn workflow_first_step(name: &str) -> Option<String> {
    use wa_core::workflows::{HandleCompaction, Workflow};

    match name {
        "handle_compaction" => HandleCompaction::new()
            .steps()
            .first()
            .map(|step| step.name.clone()),
        _ => None,
    }
}

fn build_event_would_handle(
    event: &wa_core::storage::StoredEvent,
    rule: Option<&wa_core::patterns::RuleDef>,
    config: &wa_core::config::Config,
) -> Option<RobotEventWouldHandle> {
    let rule = rule?;
    let workflow = rule.workflow.as_ref()?;

    let enabled = workflow_enabled(workflow, &config.workflows);
    let auto_run = workflow_auto_run(workflow, &config.workflows);
    let already_handled = event.handled_at.is_some();
    let would_run = enabled && auto_run && !already_handled;

    let reason = if already_handled {
        Some("event already handled".to_string())
    } else if !enabled {
        Some("workflow disabled by config".to_string())
    } else if !auto_run {
        Some("workflow not in auto-run allowlist".to_string())
    } else {
        None
    };

    Some(RobotEventWouldHandle {
        workflow: workflow.clone(),
        preview_command: rule.get_preview_command(event.pane_id, Some(event.id)),
        first_step: workflow_first_step(workflow),
        estimated_duration_ms: None,
        would_run: Some(would_run),
        reason,
    })
}

#[allow(dead_code)]
struct RobotContext {
    effective: wa_core::config::EffectiveConfig,
}

fn build_robot_context(
    config: &wa_core::config::Config,
    workspace_root: &Path,
) -> anyhow::Result<RobotContext> {
    let effective = config.effective_config(Some(workspace_root))?;
    Ok(RobotContext { effective })
}

fn build_robot_help() -> RobotHelp {
    RobotHelp {
        commands: vec![
            RobotCommandInfo {
                name: "help",
                description: "Show this help as JSON",
            },
            RobotCommandInfo {
                name: "state",
                description: "List panes with metadata",
            },
            RobotCommandInfo {
                name: "get-text",
                description: "Fetch recent pane output",
            },
            RobotCommandInfo {
                name: "send",
                description: "Send text to a pane",
            },
            RobotCommandInfo {
                name: "wait-for",
                description: "Wait for a pattern on a pane",
            },
            RobotCommandInfo {
                name: "search",
                description: "Search captured output",
            },
            RobotCommandInfo {
                name: "search-explain",
                description: "Explain why search results may be missing or incomplete",
            },
            RobotCommandInfo {
                name: "events",
                description: "Fetch recent events (optional workflow preview)",
            },
            RobotCommandInfo {
                name: "workflow run",
                description: "Run a workflow by name on a pane",
            },
            RobotCommandInfo {
                name: "workflow list",
                description: "List available workflows",
            },
            RobotCommandInfo {
                name: "workflow status",
                description: "Check workflow execution status",
            },
            RobotCommandInfo {
                name: "workflow abort",
                description: "Abort a running workflow",
            },
            RobotCommandInfo {
                name: "why",
                description: "Explain an error code or policy denial",
            },
            RobotCommandInfo {
                name: "health",
                description: "Get watcher health snapshot (queue depths, ingest lag, stuck panes)",
            },
            RobotCommandInfo {
                name: "approve",
                description: "Submit an approval code for a pending action",
            },
        ],
        global_flags: vec![
            "--workspace <path>",
            "--config <path>",
            "--verbose",
            "--format <json|toon>",
            "--stats",
        ],
    }
}

fn build_robot_quick_start() -> RobotQuickStartData {
    RobotQuickStartData {
        description: "wa robot mode: JSON API for AI agents to observe and control WezTerm panes",
        global_flags: vec![
            QuickStartGlobalFlag {
                flag: "--workspace <path>",
                env_var: Some("WA_WORKSPACE"),
                description: "Project root directory for config and database",
            },
            QuickStartGlobalFlag {
                flag: "--config <path>",
                env_var: None,
                description: "Override config file location",
            },
            QuickStartGlobalFlag {
                flag: "--format <json|toon>",
                env_var: Some("WA_OUTPUT_FORMAT"),
                description: "Robot stdout format (default: json); also consults TOON_DEFAULT_FORMAT",
            },
            QuickStartGlobalFlag {
                flag: "--stats",
                env_var: Some("TOON_STATS"),
                description: "Emit token comparison stats to stderr (JSON vs TOON)",
            },
        ],
        core_loop: vec![
            QuickStartStep {
                step: 1,
                action: "Discover panes",
                command: "wa robot state",
            },
            QuickStartStep {
                step: 2,
                action: "Select target pane_id from state output",
                command: "(parse JSON, pick pane_id)",
            },
            QuickStartStep {
                step: 3,
                action: "Read pane output",
                command: "wa robot get-text <pane_id> --tail 100",
            },
            QuickStartStep {
                step: 4,
                action: "Preview send (safety-first)",
                command: "wa robot send <pane_id> \"text\" --dry-run",
            },
            QuickStartStep {
                step: 5,
                action: "Execute send (if policy allows)",
                command: "wa robot send <pane_id> \"text\"",
            },
        ],
        commands: vec![
            QuickStartCommand {
                name: "state",
                args: "",
                summary: "List all panes with metadata (pane_id, title, cwd, observed)",
                examples: vec!["wa robot state"],
            },
            QuickStartCommand {
                name: "get-text",
                args: "<pane_id> [--tail N] [--escapes]",
                summary: "Fetch recent output from a pane",
                examples: vec!["wa robot get-text 0", "wa robot get-text 0 --tail 200"],
            },
            QuickStartCommand {
                name: "send",
                args: "<pane_id> \"<text>\" [--dry-run]",
                summary: "Send text input to a pane (policy-gated)",
                examples: vec![
                    "wa robot send 0 \"/help\" --dry-run",
                    "wa robot send 0 \"/compact\"",
                ],
            },
            QuickStartCommand {
                name: "wait-for",
                args: "<pane_id> <pattern> [--timeout-secs N] [--regex]",
                summary: "Wait for a pattern to appear in pane output",
                examples: vec![
                    "wa robot wait-for 0 \"ready>\"",
                    "wa robot wait-for 0 \"error|failed\" --regex --timeout-secs 60",
                ],
            },
            QuickStartCommand {
                name: "search",
                args: "\"<query>\" [--limit N] [--pane ID]",
                summary: "Full-text search across captured output",
                examples: vec![
                    "wa robot search \"compilation failed\"",
                    "wa robot search \"error\" --pane 0 --limit 10",
                ],
            },
            QuickStartCommand {
                name: "search-explain",
                args: "\"<query>\" [--pane ID]",
                summary: "Explain why search results may be missing or incomplete",
                examples: vec![
                    "wa robot search-explain \"compilation failed\"",
                    "wa robot search-explain \"error\" --pane 3",
                ],
            },
            QuickStartCommand {
                name: "events",
                args: "[--limit N] [--pane ID] [--rule-id ID] [--event-type TYPE] [--unhandled-only] [--would-handle] [--dry-run]",
                summary: "Fetch recent pattern detection events (with optional workflow preview)",
                examples: vec![
                    "wa robot events",
                    "wa robot events --rule-id codex.usage_reached",
                    "wa robot events --would-handle --dry-run",
                ],
            },
            QuickStartCommand {
                name: "workflow run",
                args: "<name> <pane_id> [--force] [--dry-run]",
                summary: "Run a workflow by name on a pane (policy-gated)",
                examples: vec![
                    "wa robot workflow run handle_compaction 0",
                    "wa robot workflow run handle_usage_limit 1 --force",
                ],
            },
            QuickStartCommand {
                name: "workflow list",
                args: "",
                summary: "List available workflows",
                examples: vec!["wa robot workflow list"],
            },
            QuickStartCommand {
                name: "workflow status",
                args: "<execution_id>",
                summary: "Check workflow execution status",
                examples: vec!["wa robot workflow status robot-handle_compaction-1234567890"],
            },
            QuickStartCommand {
                name: "workflow abort",
                args: "<execution_id> [--reason \"<reason>\"]",
                summary: "Abort a running workflow",
                examples: vec![
                    "wa robot workflow abort robot-handle_compaction-1234567890 --reason \"User requested\"",
                ],
            },
            QuickStartCommand {
                name: "why",
                args: "<code>",
                summary: "Explain an error code or policy denial",
                examples: vec![
                    "wa robot why deny.alt_screen",
                    "wa robot why robot.policy_denied",
                ],
            },
            QuickStartCommand {
                name: "approve",
                args: "<code> [--pane <id>] [--dry-run] [--fingerprint <hash>]",
                summary: "Submit an approval code for a pending action",
                examples: vec![
                    "wa robot approve ABC12345",
                    "wa robot approve ABC12345 --dry-run",
                ],
            },
            QuickStartCommand {
                name: "help",
                args: "",
                summary: "Show command list as JSON",
                examples: vec!["wa robot help"],
            },
            QuickStartCommand {
                name: "quick-start",
                args: "",
                summary: "Show this quick-start guide",
                examples: vec!["wa robot quick-start", "wa robot"],
            },
        ],
        tips: vec![
            "Always use --dry-run before send to preview policy decisions",
            "The 'ok' field in responses indicates success (true) or failure (false)",
            "Check 'error_code' field for programmatic error handling",
            "Use 'now' timestamp in responses to track freshness",
            "Pane IDs are stable within a WezTerm session but may change across restarts",
            "Use --format toon for compact output when piping robot results between agents",
        ],
        error_handling: QuickStartErrorHandling {
            common_codes: vec![
                QuickStartErrorCode {
                    code: "robot.pane_not_found",
                    meaning: "The specified pane_id does not exist",
                    recovery: "Use 'wa robot state' to list valid pane IDs",
                },
                QuickStartErrorCode {
                    code: "robot.wezterm_not_running",
                    meaning: "WezTerm is not running or not accessible",
                    recovery: "Start WezTerm before running wa commands",
                },
                QuickStartErrorCode {
                    code: "robot.policy_denied",
                    meaning: "Action blocked by safety policy",
                    recovery: "Use --dry-run to see policy details; adjust config if needed",
                },
                QuickStartErrorCode {
                    code: "robot.require_approval",
                    meaning: "Action requires human approval",
                    recovery: "A human must approve via 'wa approve <token>' or interactive prompt",
                },
                QuickStartErrorCode {
                    code: "robot.timeout",
                    meaning: "Wait operation timed out",
                    recovery: "Increase --timeout-secs or check if pattern is correct",
                },
            ],
            safety_notes: vec![
                "All send operations are policy-gated by default",
                "--dry-run shows what would happen without executing",
                "RequireApproval decisions surface a token for human approval",
                "Approval can be granted via 'wa approve <token>' command",
            ],
        },
    }
}

/// Helper to convert elapsed time to u64 milliseconds safely
fn elapsed_ms(start: std::time::Instant) -> u64 {
    u64::try_from(start.elapsed().as_millis()).unwrap_or(u64::MAX)
}

fn now_ms() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map_or(0, |dur| u64::try_from(dur.as_millis()).unwrap_or(u64::MAX))
}

/// Return current epoch in milliseconds as i64 (for storage queries).
fn now_epoch_ms() -> i64 {
    i64::try_from(now_ms()).unwrap_or(i64::MAX)
}

/// Parse a period string (e.g. "7d", "30d", "90d", "1d") into milliseconds.
fn parse_period_ms(period: &str) -> i64 {
    let s = period.trim().to_lowercase();
    if let Some(days_str) = s.strip_suffix('d') {
        if let Ok(days) = days_str.parse::<i64>() {
            return days * 86_400_000;
        }
    }
    // Default: 7 days
    7 * 86_400_000
}

/// Format a period string into a human-readable label.
fn format_period_label(period: &str) -> String {
    let s = period.trim().to_lowercase();
    if let Some(days_str) = s.strip_suffix('d') {
        if let Ok(days) = days_str.parse::<i64>() {
            return format!("Last {days} Day{}", if days == 1 { "" } else { "s" });
        }
    }
    "Last 7 Days".to_string()
}

/// Check if a refresh is rate-limited based on the most recent refresh timestamp.
///
/// Returns `Some((seconds_since_last, seconds_to_wait))` if rate-limited,
/// `None` if refresh is allowed.
fn check_refresh_cooldown(
    most_recent_refresh_ms: i64,
    now_ms_val: i64,
    cooldown_ms: i64,
) -> Option<(i64, i64)> {
    if most_recent_refresh_ms <= 0 {
        return None;
    }
    let elapsed = now_ms_val - most_recent_refresh_ms;
    if elapsed < cooldown_ms {
        Some((elapsed / 1000, (cooldown_ms - elapsed) / 1000))
    } else {
        None
    }
}

/// Apply tail truncation to text, returning the truncated text and truncation info
fn apply_tail_truncation(text: &str, tail_lines: usize) -> (String, bool, Option<TruncationInfo>) {
    let lines: Vec<&str> = text.lines().collect();
    let original_lines = lines.len();
    let original_bytes = text.len();

    if lines.len() <= tail_lines {
        // No truncation needed
        return (text.to_string(), false, None);
    }

    // Take the last N lines
    let start_idx = lines.len().saturating_sub(tail_lines);
    let truncated_lines: Vec<&str> = lines[start_idx..].to_vec();
    let truncated_text = truncated_lines.join("\n");
    let returned_bytes = truncated_text.len();
    let returned_lines = truncated_lines.len();

    (
        truncated_text,
        true,
        Some(TruncationInfo {
            original_bytes,
            returned_bytes,
            original_lines,
            returned_lines,
        }),
    )
}

/// Map wa_core errors to stable robot error codes
fn map_wezterm_error_to_robot(error: &wa_core::Error) -> (&'static str, Option<String>) {
    use wa_core::error::WeztermError;

    match error {
        wa_core::Error::Wezterm(wezterm_err) => match wezterm_err {
            WeztermError::CliNotFound => (
                "robot.wezterm_not_found",
                Some("Install WezTerm or ensure 'wezterm' is in PATH.".to_string()),
            ),
            WeztermError::NotRunning => (
                "robot.wezterm_not_running",
                Some("Start WezTerm before running wa commands.".to_string()),
            ),
            WeztermError::PaneNotFound(pane_id) => (
                "robot.pane_not_found",
                Some(format!(
                    "Pane {pane_id} does not exist. Use 'wa robot state' to list available panes."
                )),
            ),
            WeztermError::SocketNotFound(_) => (
                "robot.wezterm_socket_not_found",
                Some("WezTerm socket not found. Is WezTerm running?".to_string()),
            ),
            WeztermError::CommandFailed(_) => (
                "robot.wezterm_command_failed",
                Some("The WezTerm CLI command failed. Check WezTerm logs for details.".to_string()),
            ),
            WeztermError::ParseError(_) => (
                "robot.wezterm_parse_error",
                Some(
                    "Failed to parse WezTerm output. This may indicate a version mismatch."
                        .to_string(),
                ),
            ),
            WeztermError::Timeout(_) => (
                "robot.wezterm_timeout",
                Some("WezTerm command timed out. The terminal may be unresponsive.".to_string()),
            ),
            WeztermError::CircuitOpen { retry_after_ms } => (
                "robot.circuit_open",
                Some(format!(
                    "WezTerm circuit breaker is open. Retry after {retry_after_ms} ms."
                )),
            ),
        },
        _ => (
            "robot.internal_error",
            Some("An unexpected internal error occurred.".to_string()),
        ),
    }
}

fn init_logging_from_config(
    config: &wa_core::config::Config,
    workspace_root: Option<&Path>,
) -> anyhow::Result<()> {
    let log_file = config
        .general
        .log_file
        .as_ref()
        .map(|path| resolve_log_path(path, workspace_root));

    let log_config = LogConfig {
        level: config.general.log_level.clone(),
        format: config.general.log_format,
        file: log_file,
    };

    match init_logging(&log_config) {
        Ok(()) | Err(LogError::AlreadyInitialized) => {}
        Err(err) => return Err(err.into()),
    }

    if let Some(root) = workspace_root {
        tracing::info!(workspace = %root.display(), "Workspace resolved");
    }

    Ok(())
}

fn resolve_log_path(path: &str, workspace_root: Option<&Path>) -> std::path::PathBuf {
    let candidate = std::path::PathBuf::from(path);
    if candidate.is_absolute() {
        candidate
    } else if let Some(root) = workspace_root {
        root.join(candidate)
    } else {
        candidate
    }
}

fn emit_permission_warnings(warnings: &[wa_core::config::PermissionWarning]) {
    for warning in warnings {
        tracing::warn!(
            label = warning.label,
            path = %warning.path.display(),
            actual_mode = format!("{actual_mode:o}", actual_mode = warning.actual_mode),
            expected_mode = format!("{expected_mode:o}", expected_mode = warning.expected_mode),
            "Permissions too open"
        );
    }
}

/// Simple glob pattern matching for CLI filters.
///
/// Supports `*` for any sequence and `?` for single character.
fn glob_match(pattern: &str, value: &str) -> bool {
    if !pattern.contains('*') && !pattern.contains('?') {
        // Exact match
        return value == pattern;
    }

    // Convert glob to regex-style matching
    let mut regex_pattern = String::from("^");
    for ch in pattern.chars() {
        match ch {
            '*' => regex_pattern.push_str(".*"),
            '?' => regex_pattern.push('.'),
            '.' | '+' | '^' | '$' | '(' | ')' | '[' | ']' | '{' | '}' | '|' | '\\' => {
                regex_pattern.push('\\');
                regex_pattern.push(ch);
            }
            _ => regex_pattern.push(ch),
        }
    }
    regex_pattern.push('$');

    fancy_regex::Regex::new(&regex_pattern).is_ok_and(|re| re.is_match(value).unwrap_or(false))
}

fn is_structured_uservar_name(name: &str) -> bool {
    let lower = name.to_lowercase();
    lower.starts_with("wa-") || lower.starts_with("wa_") || lower == "wa_event"
}

fn validate_uservar_request(pane_id: u64, name: &str, value: &str) -> Result<(), String> {
    // Maximum message size for IPC (128KB) - mirrors wa_core::ipc::MAX_MESSAGE_SIZE
    const MAX_MESSAGE_SIZE: usize = 131_072;

    if name.trim().is_empty() {
        return Err("user-var name cannot be empty".to_string());
    }
    if value.is_empty() {
        return Err("user-var value cannot be empty".to_string());
    }

    // Estimate request size (JSON overhead is ~50 bytes for field names + pane_id)
    // Format: {"type":"user_var","pane_id":N,"name":"...","value":"..."}
    let request_size = 50 + pane_id.to_string().len() + name.len() + value.len();
    if request_size > MAX_MESSAGE_SIZE {
        return Err(format!(
            "user-var payload too large: {request_size} bytes (max {MAX_MESSAGE_SIZE})"
        ));
    }

    if is_structured_uservar_name(name) {
        wa_core::events::UserVarPayload::decode(value, false)
            .map_err(|e| format!("invalid structured user-var payload for '{name}': {e}"))?;
    }

    Ok(())
}

struct IpcRpcArgError {
    message: String,
    hint: Option<String>,
}

fn sanitize_ipc_rpc_args(args: &[String]) -> Result<Vec<String>, IpcRpcArgError> {
    let mut sanitized = Vec::with_capacity(args.len());
    let mut skip_next = false;

    for arg in args {
        if skip_next {
            skip_next = false;
            continue;
        }

        if arg == "--help" || arg == "-h" {
            return Err(IpcRpcArgError {
                message: "help flags are not supported over IPC".to_string(),
                hint: Some("Use `wa robot help` or the `help` command instead.".to_string()),
            });
        }

        if arg == "--format" || arg == "-f" {
            skip_next = true;
            continue;
        }

        if arg.starts_with("--format=") || arg == "--stats" {
            continue;
        }

        sanitized.push(arg.clone());
    }

    Ok(sanitized)
}

fn build_ipc_rpc_summary(args: &[String]) -> String {
    if args.is_empty() {
        return "wa robot".to_string();
    }

    let redacted: Vec<String> = args.iter().map(|arg| redact_for_output(arg)).collect();
    format!("wa robot {}", redacted.join(" "))
}

async fn run_robot_rpc_via_cli(
    args: &[String],
    config_path: Option<&Path>,
    workspace_root: &Path,
) -> Result<wa_core::ipc::IpcResponse, String> {
    use std::process::Stdio;
    use tokio::process::Command;

    let exe =
        std::env::current_exe().map_err(|e| format!("failed to resolve wa executable: {e}"))?;
    let mut cmd = Command::new(exe);

    if let Some(path) = config_path {
        cmd.arg("--config").arg(path);
    }

    cmd.arg("--workspace").arg(workspace_root);
    cmd.arg("robot").arg("--format").arg("json");
    cmd.args(args);
    cmd.stdout(Stdio::piped()).stderr(Stdio::piped());

    let output = cmd
        .output()
        .await
        .map_err(|e| format!("failed to run wa robot: {e}"))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        let stdout = String::from_utf8_lossy(&output.stdout);
        let detail = if stderr.trim().is_empty() {
            stdout.trim()
        } else {
            stderr.trim()
        };
        if detail.is_empty() {
            return Err(format!("wa robot exited with status {}", output.status));
        }
        return Err(format!("wa robot failed: {detail}"));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let payload = stdout.trim();
    if payload.is_empty() {
        return Err("wa robot returned empty output".to_string());
    }

    serde_json::from_str::<wa_core::ipc::IpcResponse>(payload)
        .map_err(|e| format!("invalid wa robot response: {e}"))
}

async fn record_ipc_rpc_audit(
    storage: &Arc<tokio::sync::Mutex<wa_core::storage::StorageHandle>>,
    request_id: Option<String>,
    summary: String,
    result: &str,
) {
    let audit = wa_core::storage::AuditActionRecord {
        id: 0,
        ts: now_ms_i64(),
        actor_kind: "robot".to_string(),
        actor_id: None,
        correlation_id: request_id,
        pane_id: None,
        domain: None,
        action_kind: "ipc.rpc".to_string(),
        policy_decision: "allow".to_string(),
        decision_reason: None,
        rule_id: None,
        input_summary: Some(summary),
        verification_summary: None,
        decision_context: None,
        result: result.to_string(),
    };

    if let Err(e) = storage
        .lock()
        .await
        .record_audit_action_redacted(audit)
        .await
    {
        tracing::warn!("Failed to record IPC RPC audit: {e}");
    }
}

async fn handle_ipc_rpc_request(
    request: wa_core::ipc::IpcRpcRequest,
    workspace_root: PathBuf,
    config_path: Option<PathBuf>,
    storage: Arc<tokio::sync::Mutex<wa_core::storage::StorageHandle>>,
) -> wa_core::ipc::IpcResponse {
    let summary = build_ipc_rpc_summary(&request.args);
    tracing::debug!(
        request_id = request.request_id.as_deref(),
        command = %summary,
        "IPC RPC request (redacted)"
    );

    let sanitized = match sanitize_ipc_rpc_args(&request.args) {
        Ok(args) => args,
        Err(err) => {
            let response = wa_core::ipc::IpcResponse::error_with_code(
                "ipc.rpc_invalid_args",
                err.message,
                err.hint,
            );
            record_ipc_rpc_audit(&storage, request.request_id, summary, "error").await;
            return response;
        }
    };

    let response =
        match run_robot_rpc_via_cli(&sanitized, config_path.as_deref(), &workspace_root).await {
            Ok(resp) => resp,
            Err(err) => wa_core::ipc::IpcResponse::error_with_code(
                "ipc.rpc_failed",
                err,
                Some("Ensure 'wa robot' can run and outputs JSON.".to_string()),
            ),
        };

    let result = if response.ok { "success" } else { "error" };
    record_ipc_rpc_audit(&storage, request.request_id, summary, result).await;

    response
}

fn build_ipc_rpc_handler(
    workspace_root: PathBuf,
    config_path: Option<PathBuf>,
    storage: Arc<tokio::sync::Mutex<wa_core::storage::StorageHandle>>,
) -> wa_core::ipc::IpcRpcHandler {
    Arc::new(move |request: wa_core::ipc::IpcRpcRequest| {
        let workspace_root = workspace_root.clone();
        let config_path = config_path.clone();
        let storage = Arc::clone(&storage);
        Box::pin(async move {
            handle_ipc_rpc_request(request, workspace_root, config_path, storage).await
        })
    })
}

struct ReqwestWebhookTransport {
    client: reqwest::Client,
}

impl ReqwestWebhookTransport {
    fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
        }
    }
}

impl wa_core::webhook::WebhookTransport for ReqwestWebhookTransport {
    fn send<'a>(
        &'a self,
        url: &'a str,
        headers: &'a std::collections::HashMap<String, String>,
        body: &'a serde_json::Value,
    ) -> std::pin::Pin<
        Box<dyn std::future::Future<Output = wa_core::webhook::DeliveryResult> + Send + 'a>,
    > {
        Box::pin(async move {
            let mut req = self.client.post(url).json(body);
            for (key, value) in headers {
                req = req.header(key, value);
            }

            match req.send().await {
                Ok(resp) => {
                    let status = resp.status();
                    if status.is_success() {
                        wa_core::webhook::DeliveryResult::ok(status.as_u16())
                    } else {
                        let body = resp.text().await.unwrap_or_default();
                        let message = if body.trim().is_empty() {
                            format!("http {}", status.as_u16())
                        } else {
                            format!("http {}: {}", status.as_u16(), body.trim())
                        };
                        wa_core::webhook::DeliveryResult::err(status.as_u16(), message)
                    }
                }
                Err(err) => {
                    wa_core::webhook::DeliveryResult::err(0, format!("request_failed: {err}"))
                }
            }
        })
    }
}

const WATCHER_CRASH_WINDOW: Duration = Duration::from_secs(5 * 60);
const WATCHER_STABLE_RESET: Duration = Duration::from_secs(5 * 60);
const WATCHER_BASE_BACKOFF: Duration = Duration::from_secs(2);
const WATCHER_MAX_BACKOFF: Duration = Duration::from_secs(60);
const WATCHER_CRASH_LOOP_THRESHOLD: usize = 3;

struct WatcherCrashLoop {
    crash_times: VecDeque<Instant>,
}

impl WatcherCrashLoop {
    fn new() -> Self {
        Self {
            crash_times: VecDeque::new(),
        }
    }

    fn register_crash(&mut self, runtime: Duration) -> CrashLoopStatus {
        if runtime >= WATCHER_STABLE_RESET {
            self.crash_times.clear();
        }

        let now = Instant::now();
        self.crash_times.push_back(now);
        while let Some(front) = self.crash_times.front().copied() {
            if now.duration_since(front) > WATCHER_CRASH_WINDOW {
                self.crash_times.pop_front();
            } else {
                break;
            }
        }

        let crash_count = self.crash_times.len();
        let in_loop = crash_count >= WATCHER_CRASH_LOOP_THRESHOLD;
        let backoff = compute_watcher_backoff(crash_count);

        CrashLoopStatus {
            crash_count,
            in_loop,
            backoff,
        }
    }
}

struct CrashLoopStatus {
    crash_count: usize,
    in_loop: bool,
    backoff: Duration,
}

fn compute_watcher_backoff(crash_count: usize) -> Duration {
    let mut backoff_secs = WATCHER_BASE_BACKOFF.as_secs().max(1);
    let mut steps = crash_count.saturating_sub(1);
    while steps > 0 {
        backoff_secs = backoff_secs.saturating_mul(2);
        steps -= 1;
    }
    backoff_secs = backoff_secs.min(WATCHER_MAX_BACKOFF.as_secs().max(1));
    Duration::from_secs(backoff_secs)
}

fn watcher_error_is_non_retryable(err: &anyhow::Error) -> bool {
    let message = err.to_string();
    message.contains("Another watcher is already running")
        || message.contains("Failed to acquire watcher lock")
}

/// Run the observation watcher daemon with crash-loop backoff.
#[allow(clippy::too_many_arguments, clippy::fn_params_excessive_bools)]
async fn run_watcher_with_backoff(
    layout: &wa_core::config::WorkspaceLayout,
    config: &wa_core::config::Config,
    config_path: Option<&Path>,
    auto_handle: bool,
    foreground: bool,
    poll_interval: u64,
    no_patterns: bool,
    notify_only: bool,
    notify_filter: Vec<String>,
    notify_via: Vec<NotifyChannel>,
    disable_lock: bool,
    dangerous_bind_any: bool,
) -> anyhow::Result<()> {
    let mut crash_loop = WatcherCrashLoop::new();

    loop {
        let started_at = Instant::now();
        let result = run_watcher(
            layout,
            config,
            config_path,
            auto_handle,
            foreground,
            poll_interval,
            no_patterns,
            notify_only,
            notify_filter.clone(),
            notify_via.clone(),
            disable_lock,
            dangerous_bind_any,
        )
        .await;

        match result {
            Ok(()) => return Ok(()),
            Err(err) => {
                if watcher_error_is_non_retryable(&err) {
                    return Err(err);
                }

                let runtime = started_at.elapsed();
                let status = crash_loop.register_crash(runtime);
                let error_message = err.to_string();
                let backoff = status.backoff;

                if status.in_loop {
                    tracing::error!(
                        crashes = status.crash_count,
                        runtime_ms = runtime.as_millis(),
                        backoff_ms = backoff.as_millis(),
                        error = %error_message,
                        "Watcher crash loop detected; backing off"
                    );
                } else {
                    tracing::warn!(
                        crashes = status.crash_count,
                        runtime_ms = runtime.as_millis(),
                        backoff_ms = backoff.as_millis(),
                        error = %error_message,
                        "Watcher exited with error; restarting"
                    );
                }

                tokio::select! {
                    () = tokio::time::sleep(backoff) => {}
                    _ = tokio::signal::ctrl_c() => {
                        tracing::info!("Watcher restart cancelled by Ctrl-C");
                        return Ok(());
                    }
                }
            }
        }
    }
}

/// Run the observation watcher daemon.
#[allow(clippy::too_many_arguments, clippy::fn_params_excessive_bools)]
async fn run_watcher(
    layout: &wa_core::config::WorkspaceLayout,
    config: &wa_core::config::Config,
    config_path: Option<&Path>,
    auto_handle: bool,
    _foreground: bool,
    poll_interval: u64,
    no_patterns: bool,
    notify_only: bool,
    notify_filter: Vec<String>,
    notify_via: Vec<NotifyChannel>,
    disable_lock: bool,
    dangerous_bind_any: bool,
) -> anyhow::Result<()> {
    use std::time::Duration;
    use tokio::sync::mpsc;
    use wa_core::config::{Config, ConfigOverrides, HotReloadableConfig};
    use wa_core::events::{Event, EventBus, NotifyDecision};
    use wa_core::lock::WatcherLock;
    use wa_core::notifications::NotificationPipeline;
    use wa_core::patterns::PatternEngine;
    use wa_core::policy::{PolicyEngine, PolicyGatedInjector};
    use wa_core::runtime::{ObservationRuntime, RuntimeConfig};
    use wa_core::storage::StorageHandle;
    use wa_core::webhook::WebhookDispatcher;
    use wa_core::workflows::{
        HandleCompaction, PaneWorkflowLockManager, WorkflowEngine, WorkflowRunner,
        WorkflowRunnerConfig,
    };

    let mut config = config.clone();
    let mut auto_handle = auto_handle;
    let notify_only = notify_only || config.notifications.notify_only;

    if notify_only {
        if auto_handle {
            tracing::warn!("Notify-only mode requested; disabling automatic workflow handling");
        }
        auto_handle = false;
        if !config.notifications.enabled {
            config.notifications.enabled = true;
        }
        tracing::info!("Notify-only mode enabled (notifications only)");
    }

    if !notify_filter.is_empty() {
        tracing::info!(filter = ?notify_filter, "Applying notify-only filter override");
        config.notifications.include = notify_filter;
    }

    if !notify_via.is_empty() {
        if !config.notifications.enabled {
            config.notifications.enabled = true;
        }
        let allow_webhook = notify_via.contains(&NotifyChannel::Webhook);
        let allow_desktop = notify_via.contains(&NotifyChannel::Desktop);
        let allow_email = notify_via.contains(&NotifyChannel::Email);

        if !allow_webhook {
            config.notifications.webhooks.clear();
        }
        config.notifications.desktop.enabled = allow_desktop;
        config.notifications.email.enabled = allow_email;

        tracing::info!(
            webhook = allow_webhook,
            desktop = allow_desktop,
            email = allow_email,
            "Notification channel override applied"
        );
    }

    if config.notifications.enabled {
        if let Err(err) = config.notifications.validate() {
            anyhow::bail!("Invalid notification configuration: {err}");
        }
    }

    // Print resolved paths for diagnostic visibility
    tracing::info!(
        workspace = %layout.root.display(),
        db_path = %layout.db_path.display(),
        lock_path = %layout.lock_path.display(),
        ipc_socket = %layout.ipc_socket_path.display(),
        log_file = %layout.log_path.display(),
        "Watcher starting with resolved paths"
    );

    if auto_handle {
        tracing::info!("Automatic workflow handling: enabled");
    }

    // Acquire single-instance lock (unless disabled)
    let _lock_guard = if disable_lock {
        tracing::warn!(
            "Single-instance lock DISABLED - data corruption may occur if multiple watchers run"
        );
        None
    } else {
        match WatcherLock::acquire(&layout.lock_path) {
            Ok(lock) => {
                tracing::info!(
                    lock_path = %layout.lock_path.display(),
                    "Acquired single-instance lock"
                );
                Some(lock)
            }
            Err(wa_core::lock::LockError::AlreadyRunning { pid, started_at }) => {
                anyhow::bail!(
                    "Another watcher is already running (pid: {pid}, started: {started_at}). \
                     Use --dangerous-disable-lock to override (NOT RECOMMENDED)."
                );
            }
            Err(wa_core::lock::LockError::AlreadyRunningNoMeta) => {
                anyhow::bail!(
                    "Another watcher is already running (metadata unavailable). \
                     Use --dangerous-disable-lock to override (NOT RECOMMENDED)."
                );
            }
            Err(e) => {
                anyhow::bail!("Failed to acquire watcher lock: {e}");
            }
        }
    };

    // Create storage handle
    let db_path = layout.db_path.to_string_lossy();
    let storage_config = wa_core::storage::StorageConfig {
        write_queue_size: config.storage.writer_queue_size as usize,
    };
    let storage = StorageHandle::with_config(&db_path, storage_config).await?;
    tracing::info!(db_path = %db_path, "Storage initialized");
    let scheduler_storage = storage.clone();

    maybe_trigger_e2e_watcher_panic_once(layout);

    let patterns_root = config_path
        .and_then(|path| path.parent())
        .map(PathBuf::from);

    // Create pattern engine
    let pattern_engine = if no_patterns {
        tracing::info!("Pattern detection: disabled");
        PatternEngine::with_packs(Vec::new())
            .map_err(|e| anyhow::anyhow!("Failed to initialize empty pattern engine: {e}"))?
    } else {
        tracing::info!("Pattern detection: enabled with configured packs");
        PatternEngine::from_config_with_root(&config.patterns, patterns_root.as_deref())
            .map_err(|e| anyhow::anyhow!("Failed to load pattern packs: {e}"))?
    };
    let pattern_engine = Arc::new(tokio::sync::RwLock::new(pattern_engine));

    // Create event bus for publishing detections to workflow runners
    let event_bus = Arc::new(EventBus::new(1000));

    let _notification_handle = if config.notifications.enabled {
        let mut senders: Vec<Box<dyn wa_core::notifications::NotificationSender>> = Vec::new();

        if !config.notifications.webhooks.is_empty() {
            let dispatcher = WebhookDispatcher::new(
                config.notifications.webhooks.clone(),
                Box::new(ReqwestWebhookTransport::new()),
            );
            if dispatcher.active_endpoint_count() > 0 {
                tracing::info!(
                    count = dispatcher.active_endpoint_count(),
                    "Webhook notifications enabled"
                );
                senders.push(Box::new(dispatcher));
            } else {
                tracing::info!("Webhook notifications configured but no endpoints are enabled");
            }
        }

        let desktop_notifier =
            wa_core::desktop_notify::DesktopNotifier::new(config.notifications.desktop.clone());
        if desktop_notifier.is_available() {
            tracing::info!("Desktop notifications enabled");
            senders.push(Box::new(desktop_notifier));
        } else if config.notifications.desktop.enabled {
            tracing::info!("Desktop notifications enabled but no backend is available");
        }

        if senders.is_empty() {
            tracing::info!("Notification pipeline disabled (no active senders)");
            None
        } else {
            let mute_storage = Arc::new(tokio::sync::Mutex::new(storage.clone()));
            let mut pipeline = NotificationPipeline::with_mute_store(
                config.notifications.to_notification_gate(),
                senders,
                mute_storage,
            );
            let mut subscriber = event_bus.subscribe_detections();
            let handle = tokio::spawn(async move {
                tracing::info!("Notification pipeline started, listening for detection events");
                loop {
                    match subscriber.recv().await {
                        Ok(Event::PatternDetected {
                            pane_id,
                            pane_uuid,
                            detection,
                            event_id,
                        }) => {
                            let outcome = pipeline
                                .handle_detection(
                                    &detection,
                                    pane_id,
                                    pane_uuid.as_deref(),
                                    event_id,
                                )
                                .await;
                            match &outcome.decision {
                                NotifyDecision::Send {
                                    suppressed_since_last,
                                } => {
                                    if outcome.deliveries.is_empty() {
                                        tracing::warn!(
                                            pane_id,
                                            rule_id = %detection.rule_id,
                                            "Notification send requested but no deliveries occurred"
                                        );
                                    } else {
                                        for delivery in &outcome.deliveries {
                                            if delivery.success {
                                                tracing::info!(
                                                    pane_id,
                                                    rule_id = %detection.rule_id,
                                                    sender = %delivery.sender,
                                                    suppressed_since_last,
                                                    "Notification delivered"
                                                );
                                            } else if delivery.rate_limited {
                                                tracing::debug!(
                                                    pane_id,
                                                    rule_id = %detection.rule_id,
                                                    sender = %delivery.sender,
                                                    "Notification rate limited"
                                                );
                                            } else {
                                                tracing::warn!(
                                                    pane_id,
                                                    rule_id = %detection.rule_id,
                                                    sender = %delivery.sender,
                                                    error = ?delivery.error,
                                                    "Notification delivery failed"
                                                );
                                            }
                                        }
                                    }
                                }
                                NotifyDecision::Filtered => {
                                    tracing::debug!(
                                        pane_id,
                                        rule_id = %detection.rule_id,
                                        "Notification filtered"
                                    );
                                }
                                NotifyDecision::Deduplicated { suppressed_count } => {
                                    tracing::debug!(
                                        pane_id,
                                        rule_id = %detection.rule_id,
                                        suppressed = suppressed_count,
                                        "Notification deduplicated"
                                    );
                                }
                                NotifyDecision::Throttled { total_suppressed } => {
                                    tracing::debug!(
                                        pane_id,
                                        rule_id = %detection.rule_id,
                                        suppressed = total_suppressed,
                                        "Notification throttled"
                                    );
                                }
                            }
                        }
                        Ok(_) => {}
                        Err(wa_core::events::RecvError::Lagged { missed_count }) => {
                            tracing::warn!(missed = missed_count, "Notification subscriber lagged");
                        }
                        Err(wa_core::events::RecvError::Closed) => {
                            break;
                        }
                    }
                }
                tracing::info!("Notification pipeline stopped");
            });

            Some(handle)
        }
    } else {
        tracing::info!("Notification pipeline disabled by config");
        None
    };

    // Set up workflow runner if auto_handle is enabled
    let _workflow_runner_handle = if auto_handle {
        // Create shared storage for workflow runner (recreate config since it doesn't impl Clone)
        let workflow_storage_config = wa_core::storage::StorageConfig {
            write_queue_size: config.storage.writer_queue_size as usize,
        };
        let storage_for_workflows =
            Arc::new(StorageHandle::with_config(&db_path, workflow_storage_config).await?);

        // Create policy engine (permissive defaults for auto-handling)
        let policy_engine = PolicyEngine::permissive();
        let wezterm_handle = wa_core::wezterm::default_wezterm_handle();
        let injector = Arc::new(tokio::sync::Mutex::new(PolicyGatedInjector::with_storage(
            policy_engine,
            wezterm_handle,
            storage_for_workflows.as_ref().clone(),
        )));

        // Create workflow engine and lock manager
        let workflow_engine = WorkflowEngine::new(config.workflows.max_concurrent as usize);
        let lock_manager = Arc::new(PaneWorkflowLockManager::new());

        // Create workflow runner
        let runner_config = WorkflowRunnerConfig {
            max_concurrent: config.workflows.max_concurrent as usize,
            step_timeout_ms: config.workflows.default_step_timeout_ms,
            ..Default::default()
        };
        let workflow_runner = WorkflowRunner::new(
            workflow_engine,
            lock_manager,
            storage_for_workflows,
            injector,
            runner_config,
        );

        // Register built-in workflows
        workflow_runner.register_workflow(Arc::new(
            HandleCompaction::new().with_prompt_config(config.workflows.compaction_prompts.clone()),
        ));
        workflow_runner.register_workflow(Arc::new(wa_core::workflows::HandleUsageLimits::new()));
        workflow_runner.register_workflow(Arc::new(wa_core::workflows::HandleSessionEnd::new()));
        workflow_runner.register_workflow(Arc::new(wa_core::workflows::HandleAuthRequired::new()));
        workflow_runner
            .register_workflow(Arc::new(wa_core::workflows::HandleClaudeCodeLimits::new()));
        workflow_runner.register_workflow(Arc::new(wa_core::workflows::HandleGeminiQuota::new()));
        tracing::info!(
            "Registered workflows: handle_compaction, handle_usage_limits, handle_session_end, handle_auth_required, handle_claude_code_limits, handle_gemini_quota"
        );

        // Spawn workflow runner event loop
        let event_bus_clone = Arc::clone(&event_bus);
        let runner_handle = tokio::spawn(async move {
            tracing::info!("Workflow runner started, listening for detection events");
            workflow_runner.run(&event_bus_clone).await;
            tracing::info!("Workflow runner stopped");
        });

        Some(runner_handle)
    } else {
        None
    };

    // Configure the runtime
    let native_event_socket = if config.native.enabled {
        let env_socket = std::env::var("WEZTERM_WA_SOCKET").ok();
        let socket = env_socket.unwrap_or_else(|| config.native.socket_path.clone());
        Some(PathBuf::from(socket))
    } else {
        None
    };

    let runtime_config = RuntimeConfig {
        discovery_interval: Duration::from_millis(poll_interval),
        capture_interval: Duration::from_millis(config.ingest.poll_interval_ms),
        min_capture_interval: Duration::from_millis(config.ingest.min_poll_interval_ms),
        overlap_size: 4096, // Default overlap window size
        pane_filter: config.ingest.panes.clone(),
        pane_priorities: config.ingest.priorities.clone(),
        capture_budgets: config.ingest.budgets.clone(),
        patterns: config.patterns.clone(),
        patterns_root: patterns_root.clone(),
        channel_buffer: 1024,
        max_concurrent_captures: config.ingest.max_concurrent_captures as usize,
        retention_days: config.storage.retention_days,
        retention_max_mb: config.storage.retention_max_mb,
        checkpoint_interval_secs: config.storage.checkpoint_interval_secs,
        native_event_socket,
    };

    // Create and start the observation runtime (with event bus for workflow integration)
    let mut runtime = ObservationRuntime::new(runtime_config, storage, pattern_engine)
        .with_event_bus(Arc::clone(&event_bus));
    let handle = Arc::new(runtime.start().await?);
    tracing::info!("Observation runtime started");

    // Background scheduler for saved searches (scheduled alerts).
    //
    // Runs inside the watcher process and publishes synthetic PatternDetected
    // events onto the EventBus so the existing notification pipeline can fire.
    let _saved_search_scheduler_handle = {
        let storage = scheduler_storage.clone();
        let event_bus = Arc::clone(&event_bus);
        let shutdown_flag = Arc::clone(&handle.shutdown_flag);
        tokio::spawn(async move {
            run_saved_search_scheduler(storage, event_bus, shutdown_flag).await;
        })
    };

    #[cfg(feature = "metrics")]
    let metrics_handle: Option<wa_core::metrics::MetricsServerHandle> = if config.metrics.enabled {
        let collector = wa_core::metrics::RuntimeMetricsCollector::new(Arc::clone(&handle));
        let server = wa_core::metrics::MetricsServer::new(
            config.metrics.bind.clone(),
            config.metrics.prefix.clone(),
            Arc::new(collector),
            Arc::clone(&handle.shutdown_flag),
        );
        let server = if dangerous_bind_any {
            server.with_dangerous_public_bind()
        } else {
            server
        };
        match server.start().await {
            Ok(handle) => {
                tracing::info!(
                    bind = %handle.local_addr(),
                    prefix = %config.metrics.prefix,
                    "Metrics endpoint enabled"
                );
                Some(handle)
            }
            Err(err) => {
                tracing::error!(error = %err, "Failed to start metrics endpoint");
                None
            }
        }
    } else {
        None
    };

    #[cfg(not(feature = "metrics"))]
    if config.metrics.enabled {
        tracing::warn!("Metrics enabled in config, but wa was built without the metrics feature");
    }
    #[cfg(not(feature = "metrics"))]
    let _ = dangerous_bind_any;

    let config_path_buf = config_path.map(Path::to_path_buf);
    let ipc_handle = if config.ipc.enabled {
        #[cfg(unix)]
        {
            let ipc_auth = if config.ipc.tokens.is_empty() {
                None
            } else {
                Some(wa_core::ipc::IpcAuth::new(config.ipc.tokens.clone()))
            };
            let rpc_handler = Some(build_ipc_rpc_handler(
                layout.root.clone(),
                config_path_buf.clone(),
                Arc::clone(&handle.storage),
            ));
            match wa_core::ipc::IpcServer::bind_with_permissions(
                &layout.ipc_socket_path,
                Some(config.ipc.permissions),
            )
            .await
            {
                Ok(server) => {
                    let (shutdown_tx, shutdown_rx) = mpsc::channel(1);
                    let event_bus = Arc::clone(&event_bus);
                    let registry = Arc::clone(&handle.registry);
                    let ipc_task = tokio::spawn(async move {
                        server
                            .run_with_registry_auth_and_rpc(
                                event_bus,
                                registry,
                                ipc_auth,
                                rpc_handler,
                                shutdown_rx,
                            )
                            .await;
                    });
                    Some((shutdown_tx, ipc_task))
                }
                Err(err) => {
                    tracing::error!(
                        error = %err,
                        socket = %layout.ipc_socket_path.display(),
                        "Failed to start IPC server"
                    );
                    None
                }
            }
        }
        #[cfg(not(unix))]
        {
            tracing::warn!("IPC server not supported on this platform");
            None
        }
    } else {
        tracing::info!("IPC server disabled by config");
        None
    };

    // Start scheduled backups if enabled
    let scheduled_backup_handle = if config.backup.scheduled.enabled {
        let backup_config = config.backup.scheduled.clone();
        let workspace_root = layout.root.clone();
        let db_path = layout.db_path.clone();
        let storage = Arc::clone(&handle.storage);
        let shutdown_flag = Arc::clone(&handle.shutdown_flag);
        let notify_config = config.notifications.desktop.clone();
        Some(tokio::spawn(async move {
            run_scheduled_backups(
                backup_config,
                workspace_root,
                db_path,
                storage,
                shutdown_flag,
                notify_config,
            )
            .await;
        }))
    } else {
        None
    };

    // Track current config for hot reload
    let mut current_config = config.clone();

    // Wait for signals (SIGINT/SIGTERM to shutdown, SIGHUP to reload config)
    #[cfg(unix)]
    {
        use tokio::signal::unix::{SignalKind, signal};
        let mut sigint = signal(SignalKind::interrupt())?;
        let mut sigterm = signal(SignalKind::terminate())?;
        let mut sighup = signal(SignalKind::hangup())?;

        loop {
            tokio::select! {
                _ = sigint.recv() => {
                    tracing::info!("Received SIGINT, initiating graceful shutdown");
                    break;
                }
                _ = sigterm.recv() => {
                    tracing::info!("Received SIGTERM, initiating graceful shutdown");
                    break;
                }
                _ = sighup.recv() => {
                    tracing::info!("Received SIGHUP, attempting config reload");

                    // Reload config from disk
                    match Config::load_with_overrides(config_path, false, &ConfigOverrides::default()) {
                        Ok(new_config) => {
                            // Check what changed
                            let diff = current_config.diff_for_hot_reload(&new_config);

                            if !diff.allowed {
                                tracing::warn!(
                                    "Config reload blocked: forbidden changes detected"
                                );
                                for fc in &diff.forbidden {
                                    tracing::warn!(
                                        setting = %fc.name,
                                        reason = %fc.reason,
                                        "Forbidden config change"
                                    );
                                }
                                tracing::warn!(
                                    "Restart the watcher to apply these changes"
                                );
                            } else if diff.changes.is_empty() {
                                tracing::info!("No configuration changes detected");
                            } else {
                                // Log and apply changes
                                for change in &diff.changes {
                                    tracing::info!(
                                        setting = %change.name,
                                        old = %change.old_value,
                                        new = %change.new_value,
                                        "Applying config change"
                                    );
                                }

                                // Create hot-reloadable config and apply to runtime
                                let hot_config = HotReloadableConfig::from_config(&new_config);
                                if let Err(e) = handle.apply_config_update(hot_config) {
                                    tracing::error!(error = %e, "Failed to apply config update");
                                } else {
                                    current_config = new_config;
                                    tracing::info!("Config reload complete");
                                }
                            }
                        }
                        Err(e) => {
                            tracing::error!(error = %e, "Failed to reload config");
                        }
                    }
                }
            }
        }
    }

    #[cfg(not(unix))]
    {
        tokio::signal::ctrl_c().await?;
        tracing::info!("Received Ctrl+C, initiating graceful shutdown");
    }

    // Graceful shutdown
    if let Some((shutdown_tx, ipc_task)) = ipc_handle {
        let _ = shutdown_tx.send(()).await;
        let _ = ipc_task.await;
    }

    tracing::info!("Shutting down observation runtime...");
    handle.signal_shutdown();
    #[cfg(feature = "metrics")]
    if let Some(metrics_handle) = metrics_handle {
        metrics_handle.wait().await;
    }
    match Arc::try_unwrap(handle) {
        Ok(handle) => handle.shutdown().await,
        Err(handle) => {
            tracing::warn!(
                strong_count = Arc::strong_count(&handle),
                "Runtime handle still has outstanding references; skipping join"
            );
        }
    }
    tracing::info!("Watcher shutdown complete");

    if let Some(backup_handle) = scheduled_backup_handle {
        let _ = backup_handle.await;
    }

    Ok(())
}

fn maybe_trigger_e2e_watcher_panic_once(layout: &wa_core::config::WorkspaceLayout) {
    // E2E-only crash trigger: crash once, write a bundle, then allow subsequent runs.
    // This is intentionally environment-gated and uses an on-disk marker for one-shot behavior.
    const ENV_VAR: &str = "WA_E2E_WATCHER_PANIC_ONCE";

    let enabled = std::env::var(ENV_VAR)
        .ok()
        .is_some_and(|v| v == "1" || v.eq_ignore_ascii_case("true"));
    if !enabled {
        return;
    }

    let marker = layout.wa_dir.join("e2e_watcher_panic_once.done");
    if marker.exists() {
        return;
    }

    if let Err(err) = std::fs::write(&marker, b"1\n") {
        tracing::warn!(
            marker = %marker.display(),
            error = %err,
            "Failed to write E2E crash marker"
        );
    }

    panic!("wa-e2e: intentional watcher panic (one-shot)");
}

async fn run_saved_search_scheduler(
    storage: wa_core::storage::StorageHandle,
    event_bus: Arc<wa_core::events::EventBus>,
    shutdown_flag: Arc<std::sync::atomic::AtomicBool>,
) {
    use std::collections::HashMap;
    use std::sync::atomic::Ordering;
    use std::time::Duration;

    use wa_core::events::Event;
    use wa_core::patterns::{AgentType, Detection, Severity};
    use wa_core::policy::Redactor;
    use wa_core::storage::{
        SAVED_SEARCH_SINCE_MODE_FIXED, SAVED_SEARCH_SINCE_MODE_LAST_RUN, SavedSearchRecord,
        SearchOptions, StoredEvent,
    };

    const DEFAULT_IDLE_SLEEP_MS: i64 = 5_000;
    const MIN_SLEEP_MS: i64 = 250;
    const MIN_SCHEDULE_INTERVAL_MS: i64 = 1_000;
    const ALERT_MIN_INTERVAL_MS: i64 = 60_000;
    const ERROR_BACKOFF_BASE_MS: i64 = 5_000;
    const ERROR_BACKOFF_MAX_MS: i64 = 5 * 60_000;
    const EVENT_DEDUPE_BUCKET_MS: i64 = 5 * 60_000;

    fn epoch_ms() -> i64 {
        let ts = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default();
        i64::try_from(ts.as_millis()).unwrap_or(0)
    }

    fn clamp_schedule_interval(ms: i64) -> i64 {
        if ms <= 0 {
            0
        } else {
            ms.max(MIN_SCHEDULE_INTERVAL_MS)
        }
    }

    fn compute_since_ms(search: &SavedSearchRecord) -> Option<i64> {
        if search.since_mode == SAVED_SEARCH_SINCE_MODE_FIXED {
            search.since_ms
        } else if search.since_mode == SAVED_SEARCH_SINCE_MODE_LAST_RUN {
            search.last_run_at
        } else {
            // Unknown mode: fall back to last_run semantics.
            search.last_run_at
        }
    }

    fn compute_next_due_ms(now: i64, search: &SavedSearchRecord, interval_ms: i64) -> i64 {
        let Some(last) = search.last_run_at else {
            return now;
        };
        last.saturating_add(interval_ms)
    }

    fn backoff_ms_for_errors(consecutive_errors: u32) -> i64 {
        // Exponential backoff capped at ERROR_BACKOFF_MAX_MS.
        let shift = consecutive_errors.saturating_sub(1).min(8);
        let factor: i64 = 1_i64.checked_shl(shift).unwrap_or(i64::MAX);
        (ERROR_BACKOFF_BASE_MS.saturating_mul(factor)).min(ERROR_BACKOFF_MAX_MS)
    }

    fn to_usize_limit(value: i64) -> Option<usize> {
        if value <= 0 {
            return None;
        }
        usize::try_from(value).ok()
    }

    fn bounded_string(mut value: String, max_len: usize) -> String {
        if value.len() > max_len {
            value.truncate(max_len);
        }
        value
    }

    let redactor = Redactor::new();
    let mut consecutive_errors_by_id: HashMap<String, u32> = HashMap::new();
    let mut next_allowed_run_at_by_id: HashMap<String, i64> = HashMap::new();
    let mut last_alert_at_by_id: HashMap<String, i64> = HashMap::new();

    loop {
        if shutdown_flag.load(Ordering::SeqCst) {
            break;
        }

        let now = epoch_ms();

        let searches = match storage.list_saved_searches().await {
            Ok(searches) => searches,
            Err(err) => {
                tracing::warn!(error = %err, "Saved search scheduler: failed to list searches");
                tokio::select! {
                    () = tokio::time::sleep(Duration::from_secs(1)) => {}
                    () = wait_for_shutdown(Arc::clone(&shutdown_flag)) => break,
                }
                continue;
            }
        };

        let mut any_scheduled = false;
        let mut next_wake_at = now.saturating_add(DEFAULT_IDLE_SLEEP_MS);

        for search in searches {
            if shutdown_flag.load(Ordering::SeqCst) {
                break;
            }
            let search_id = search.id.clone();
            let search_name = search.name.clone();
            let search_query = search.query.clone();
            if !search.enabled {
                continue;
            }

            let Some(raw_interval_ms) = search.schedule_interval_ms else {
                continue;
            };

            let interval_ms = clamp_schedule_interval(raw_interval_ms);
            if interval_ms == 0 {
                continue;
            }

            any_scheduled = true;

            // Backoff gate (typically for invalid query / persistent DB errors).
            let next_allowed_run_at = next_allowed_run_at_by_id
                .get(&search_id)
                .copied()
                .unwrap_or(0);
            if next_allowed_run_at > now {
                next_wake_at = next_wake_at.min(next_allowed_run_at);
                continue;
            }

            let due_at = compute_next_due_ms(now, &search, interval_ms);
            if due_at > now {
                next_wake_at = next_wake_at.min(due_at);
                continue;
            }

            let since_ms = compute_since_ms(&search);
            let mut options = SearchOptions::default();
            options.pane_id = search.pane_id;
            options.since = since_ms;
            options.limit = to_usize_limit(search.limit);
            options.include_snippets = Some(true);
            options.snippet_max_tokens = Some(64);

            let results = match storage.search_with_results(&search.query, options).await {
                Ok(results) => {
                    consecutive_errors_by_id.remove(&search_id);
                    next_allowed_run_at_by_id.remove(&search_id);
                    results
                }
                Err(err) => {
                    let entry = consecutive_errors_by_id
                        .entry(search_id.clone())
                        .or_insert(0);
                    *entry = entry.saturating_add(1);
                    let backoff_ms = backoff_ms_for_errors(*entry);
                    let next_allowed = now.saturating_add(backoff_ms);
                    next_allowed_run_at_by_id.insert(search_id.clone(), next_allowed);
                    next_wake_at = next_wake_at.min(next_allowed);

                    let message = bounded_string(err.to_string(), 600);
                    if let Err(update_err) = storage
                        .update_saved_search_run(&search_id, now, None, Some(message.clone()))
                        .await
                    {
                        tracing::warn!(
                            search = %search_name,
                            error = %update_err,
                            "Saved search scheduler: failed to persist last_error"
                        );
                    }

                    tracing::warn!(
                        search = %search_name,
                        error = %message,
                        backoff_ms,
                        "Saved search scheduler: search execution failed; backing off"
                    );
                    continue;
                }
            };

            #[allow(clippy::cast_possible_truncation)]
            let match_count: i64 = results.len() as i64;

            if let Err(update_err) = storage
                .update_saved_search_run(&search_id, now, Some(match_count), None)
                .await
            {
                tracing::warn!(
                    search = %search_name,
                    error = %update_err,
                    "Saved search scheduler: failed to persist run metadata"
                );
            }

            if match_count <= 0 {
                continue;
            }

            // Enforce a simple alert cooldown per saved search to avoid notification storms.
            let last_alert_at = last_alert_at_by_id.get(&search_id).copied().unwrap_or(0);
            if now.saturating_sub(last_alert_at) < ALERT_MIN_INTERVAL_MS {
                continue;
            }
            last_alert_at_by_id.insert(search_id.clone(), now);

            // For unscoped searches, bind the alert to the first match's pane.
            let pane_id_for_event = search
                .pane_id
                .or_else(|| results.first().map(|r| r.segment.pane_id))
                .unwrap_or(0);

            let scope = search
                .pane_id
                .map_or_else(|| "all panes".to_string(), |pid| format!("pane {pid}"));

            let snippet = results
                .first()
                .and_then(|r| r.snippet.as_deref())
                .map(|s| bounded_string(redactor.redact(s), 280))
                .filter(|s| !s.trim().is_empty());

            let extracted = {
                let mut map = serde_json::Map::new();
                map.insert(
                    "search_name".to_string(),
                    serde_json::Value::String(search_name),
                );
                map.insert(
                    "query".to_string(),
                    serde_json::Value::String(bounded_string(redactor.redact(&search_query), 400)),
                );
                map.insert("scope".to_string(), serde_json::Value::String(scope));
                map.insert(
                    "match_count".to_string(),
                    serde_json::Value::Number(serde_json::Number::from(match_count)),
                );
                if let Some(value) = snippet {
                    map.insert("snippet".to_string(), serde_json::Value::String(value));
                }
                serde_json::Value::Object(map)
            };

            let detection = Detection {
                rule_id: "wezterm.saved_search.alert".to_string(),
                agent_type: AgentType::Wezterm,
                event_type: "saved_search.alert".to_string(),
                severity: Severity::Info,
                confidence: 1.0,
                extracted,
                matched_text: String::new(),
                span: (0, 0),
            };

            let bucket = if EVENT_DEDUPE_BUCKET_MS > 0 {
                now / EVENT_DEDUPE_BUCKET_MS
            } else {
                0
            };
            let dedupe_key = format!("ss_alert:{search_id}:{bucket}");

            let stored_event = StoredEvent {
                id: 0,
                pane_id: pane_id_for_event,
                rule_id: detection.rule_id.clone(),
                agent_type: detection.agent_type.to_string(),
                event_type: detection.event_type.clone(),
                severity: "info".to_string(),
                confidence: detection.confidence,
                extracted: Some(detection.extracted.clone()),
                matched_text: None,
                segment_id: results.first().map(|r| r.segment.id),
                detected_at: now,
                dedupe_key: Some(dedupe_key),
                handled_at: None,
                handled_by_workflow_id: None,
                handled_status: None,
            };

            let event_id = match storage.record_event(stored_event).await {
                Ok(id) => id,
                Err(err) => {
                    tracing::warn!(
                        pane_id = pane_id_for_event,
                        search = %search_id,
                        error = %err,
                        "Saved search scheduler: failed to record alert event"
                    );
                    continue;
                }
            };

            let delivered = event_bus.publish(Event::PatternDetected {
                pane_id: pane_id_for_event,
                pane_uuid: None,
                detection,
                event_id: Some(event_id),
            });
            if delivered == 0 {
                tracing::debug!(
                    pane_id = pane_id_for_event,
                    search = %search_id,
                    "Saved search scheduler: alert published but no subscribers"
                );
            }

            // Aim for fairness: after doing work, wake quickly to consider other due searches.
            next_wake_at = next_wake_at.min(now.saturating_add(MIN_SLEEP_MS));
        }

        let now = epoch_ms();
        let mut sleep_ms = if any_scheduled {
            next_wake_at.saturating_sub(now)
        } else {
            DEFAULT_IDLE_SLEEP_MS
        };
        sleep_ms = sleep_ms.max(MIN_SLEEP_MS);
        let sleep_ms_u64 = u64::try_from(sleep_ms).unwrap_or(1_000);

        tokio::select! {
            () = tokio::time::sleep(Duration::from_millis(sleep_ms_u64)) => {}
            () = wait_for_shutdown(Arc::clone(&shutdown_flag)) => break,
        }
    }

    tracing::info!("Saved search scheduler stopped");
}

async fn run_scheduled_backups(
    config: wa_core::config::ScheduledBackupConfig,
    workspace_root: PathBuf,
    db_path: PathBuf,
    storage: Arc<tokio::sync::Mutex<wa_core::storage::StorageHandle>>,
    shutdown_flag: Arc<std::sync::atomic::AtomicBool>,
    notify_config: wa_core::desktop_notify::DesktopNotifyConfig,
) {
    use std::sync::atomic::Ordering;
    use std::time::Duration;

    let schedule = match wa_core::backup::BackupSchedule::parse(&config.schedule) {
        Ok(schedule) => schedule,
        Err(err) => {
            tracing::error!(error = %err, "Invalid scheduled backup configuration");
            return;
        }
    };

    if config.compress {
        tracing::warn!(
            "Scheduled backup compression is not implemented; storing directory backups"
        );
    }
    if config.metadata_only {
        tracing::info!("Scheduled backup metadata_only: verification disabled");
    }

    let notifier = wa_core::desktop_notify::DesktopNotifier::new(notify_config);

    loop {
        if shutdown_flag.load(Ordering::SeqCst) {
            break;
        }

        let now = chrono::Local::now();
        let next_run = match schedule.next_after(now) {
            Ok(next_run) => next_run,
            Err(err) => {
                tracing::warn!(error = %err, "Failed to compute next backup schedule; retrying");
                tokio::select! {
                    () = tokio::time::sleep(Duration::from_secs(60)) => {}
                    () = wait_for_shutdown(shutdown_flag.clone()) => break,
                }
                continue;
            }
        };

        let sleep_duration = match (next_run - now).to_std() {
            Ok(duration) => duration,
            Err(_) => Duration::from_secs(1),
        };

        tracing::info!(
            schedule = %schedule.display_label(),
            next_run_at = %format_local_datetime(next_run),
            "Scheduled backup queued"
        );

        tokio::select! {
            () = tokio::time::sleep(sleep_duration) => {}
            () = wait_for_shutdown(shutdown_flag.clone()) => break,
        }

        if shutdown_flag.load(Ordering::SeqCst) {
            break;
        }

        let mut attempt = 0;
        let mut last_error: Option<String> = None;
        let mut success = false;

        while attempt < 3 {
            attempt += 1;
            if shutdown_flag.load(Ordering::SeqCst) {
                break;
            }

            match run_single_scheduled_backup(&config, &workspace_root, &db_path, &storage).await {
                Ok(result) => {
                    success = true;
                    tracing::info!(
                        output = %result.output_path,
                        size_bytes = result.total_size_bytes,
                        "Scheduled backup completed"
                    );

                    if config.notify_on_success {
                        let message = format!(
                            "Backup saved to {} ({})",
                            result.output_path,
                            format_bytes_compact(result.total_size_bytes)
                        );
                        send_backup_notification(
                            &notifier,
                            "wa backup success",
                            &message,
                            wa_core::desktop_notify::Urgency::Normal,
                        );
                    }

                    break;
                }
                Err(err) => {
                    last_error = Some(err.to_string());
                    tracing::warn!(attempt, error = %err, "Scheduled backup attempt failed");
                    if attempt < 3 {
                        let backoff = Duration::from_secs(2_u64.pow(attempt - 1));
                        tokio::select! {
                            () = tokio::time::sleep(backoff) => {}
                            () = wait_for_shutdown(shutdown_flag.clone()) => break,
                        }
                    }
                }
            }
        }

        if !success {
            if let Some(ref err) = last_error {
                tracing::error!(error = %err, "Scheduled backup failed");
            }
            if config.notify_on_failure {
                let body = last_error
                    .as_deref()
                    .unwrap_or("Backup failed (unknown error)");
                send_backup_notification(
                    &notifier,
                    "wa backup failed",
                    body,
                    wa_core::desktop_notify::Urgency::Critical,
                );
            }
        }
    }
}

async fn run_single_scheduled_backup(
    config: &wa_core::config::ScheduledBackupConfig,
    workspace_root: &Path,
    db_path: &Path,
    storage: &Arc<tokio::sync::Mutex<wa_core::storage::StorageHandle>>,
) -> anyhow::Result<wa_core::backup::ExportResult> {
    if !db_path.exists() {
        anyhow::bail!("Database not found at {}", db_path.display());
    }

    if let Err(err) = storage.lock().await.checkpoint().await {
        tracing::warn!(error = %err, "Backup checkpoint failed");
    }

    let now = chrono::Local::now();
    let output_dir = wa_core::backup::scheduled_backup_output_path(
        workspace_root,
        config.destination.as_deref(),
        now,
    );

    let opts = wa_core::backup::ExportOptions {
        output: Some(output_dir),
        include_sql_dump: false,
        verify: !config.metadata_only,
    };

    let db_path = db_path.to_path_buf();
    let workspace_root = workspace_root.to_path_buf();
    let workspace_root_for_closure = workspace_root.clone();
    let export_result = tokio::task::spawn_blocking(move || {
        wa_core::backup::export_backup(&db_path, &workspace_root_for_closure, &opts)
    })
    .await??;

    let retention_days = config.retention_days;
    let max_backups = config.max_backups;
    let destination_root =
        wa_core::backup::backup_destination_root(&workspace_root, config.destination.as_deref());

    if retention_days > 0 || max_backups > 0 {
        let now = chrono::Local::now();
        let destination_root = destination_root.clone();
        tokio::task::spawn_blocking(move || {
            wa_core::backup::prune_backups(&destination_root, retention_days, max_backups, now)
        })
        .await??;
    }

    Ok(export_result)
}

async fn wait_for_shutdown(flag: Arc<std::sync::atomic::AtomicBool>) {
    use std::sync::atomic::Ordering;
    use std::time::Duration;

    while !flag.load(Ordering::SeqCst) {
        tokio::time::sleep(Duration::from_millis(250)).await;
    }
}

fn format_local_datetime(value: chrono::DateTime<chrono::Local>) -> String {
    use chrono::{Datelike, Timelike};

    format!(
        "{:04}-{:02}-{:02}T{:02}:{:02}:{:02}",
        value.year(),
        value.month(),
        value.day(),
        value.hour(),
        value.minute(),
        value.second()
    )
}

fn format_bytes_compact(bytes: u64) -> String {
    const KB: u64 = 1024;
    const MB: u64 = KB * 1024;
    const GB: u64 = MB * 1024;

    let format_with_one_decimal = |value: u64, unit: u64, label: &str| {
        let whole = value / unit;
        let frac = (value % unit) * 10 / unit;
        format!("{whole}.{frac} {label}")
    };

    if bytes >= GB {
        format_with_one_decimal(bytes, GB, "GB")
    } else if bytes >= MB {
        format_with_one_decimal(bytes, MB, "MB")
    } else if bytes >= KB {
        format_with_one_decimal(bytes, KB, "KB")
    } else {
        format!("{bytes} bytes")
    }
}

fn send_backup_notification(
    notifier: &wa_core::desktop_notify::DesktopNotifier,
    title: &str,
    body: &str,
    urgency: wa_core::desktop_notify::Urgency,
) {
    if !notifier.is_available() {
        return;
    }
    let _ = notifier.notify_message(title, body, urgency);
}

#[tokio::main]
async fn main() {
    let robot_mode = sniff_robot_mode_from_args();
    if let Err(err) = Box::pin(run(robot_mode)).await {
        handle_fatal_error(&err, robot_mode);
        std::process::exit(1);
    }
}

async fn run(robot_mode: bool) -> anyhow::Result<()> {
    let start = std::time::Instant::now();

    let cli = match Cli::try_parse() {
        Ok(cli) => cli,
        Err(err) => {
            if robot_mode {
                let elapsed = elapsed_ms(start);
                let format = resolve_robot_output_format(sniff_robot_output_format_from_args());
                match err.kind() {
                    clap::error::ErrorKind::DisplayHelp
                    | clap::error::ErrorKind::DisplayVersion => {
                        let response = RobotResponse::success(build_robot_help(), elapsed);
                        print_robot_response(&response, format, false)?;
                    }
                    clap::error::ErrorKind::InvalidSubcommand => {
                        let response = RobotResponse::<()>::error_with_code(
                            ROBOT_ERR_UNKNOWN_SUBCOMMAND,
                            "Unknown robot subcommand",
                            Some("Use `wa robot help` for available commands.".to_string()),
                            elapsed,
                        );
                        print_robot_response(&response, format, false)?;
                    }
                    _ => {
                        let response = RobotResponse::<()>::error_with_code(
                            ROBOT_ERR_INVALID_ARGS,
                            "Invalid robot arguments",
                            Some("Use `wa robot help` for usage.".to_string()),
                            elapsed,
                        );
                        print_robot_response(&response, format, false)?;
                    }
                }
                return Ok(());
            }
            err.exit();
        }
    };

    let Cli {
        verbose,
        config: cli_config_arg,
        workspace,
        command,
    } = cli;
    // Unbox the command to keep downstream match patterns unchanged.
    // The Box avoids stack overflow for the 56-variant Commands enum in debug/test builds.
    let command = command.map(|b| *b);

    let mut overrides = wa_core::config::ConfigOverrides::default();
    if verbose > 0 {
        overrides.log_level = Some("debug".to_string());
    }
    if let Some(Commands::Watch {
        metrics,
        metrics_bind,
        metrics_prefix,
        ..
    }) = &command
    {
        if *metrics {
            overrides.metrics_enabled = Some(true);
        }
        if let Some(bind) = metrics_bind {
            overrides.metrics_enabled.get_or_insert(true);
            overrides.metrics_bind = Some(bind.clone());
        }
        if let Some(prefix) = metrics_prefix {
            overrides.metrics_enabled.get_or_insert(true);
            overrides.metrics_prefix = Some(prefix.clone());
        }
    }

    let config_path = cli_config_arg.as_deref().map(Path::new);
    let config = match wa_core::config::Config::load_with_overrides(
        config_path,
        config_path.is_some(),
        &overrides,
    ) {
        Ok(config) => config,
        Err(err) => {
            if robot_mode {
                let (format, stats) = match command.as_ref() {
                    Some(Commands::Robot { format, stats, .. }) => {
                        (resolve_robot_output_format(*format), *stats)
                    }
                    _ => (
                        resolve_robot_output_format(sniff_robot_output_format_from_args()),
                        false,
                    ),
                };
                let response = RobotResponse::<()>::error_with_code(
                    ROBOT_ERR_CONFIG,
                    format!("Failed to load config: {err}"),
                    Some("Check --config/--workspace or WA_WORKSPACE.".to_string()),
                    elapsed_ms(start),
                );
                print_robot_response(&response, format, stats)?;
                return Ok(());
            }
            return Err(err.into());
        }
    };

    let workspace_path = workspace.as_deref().map(Path::new);
    let workspace_root = config.resolve_workspace_root(workspace_path)?;
    let layout = config.workspace_layout(Some(&workspace_root))?;
    let resolved_config_path = wa_core::config::resolve_config_path(config_path);
    let log_file_path = config
        .general
        .log_file
        .as_ref()
        .map(|path| resolve_log_path(path, Some(&workspace_root)));

    init_logging_from_config(&config, Some(&workspace_root))?;
    layout.ensure_directories()?;
    let permission_warnings = wa_core::config::collect_permission_warnings(
        &layout,
        resolved_config_path.as_deref(),
        log_file_path.as_deref(),
        &config.ipc,
    );
    emit_permission_warnings(&permission_warnings);

    match command {
        Some(Commands::Version { full }) => {
            if full {
                println!("{}", build_meta::verbose_version());
            } else {
                println!("wa {}", build_meta::short_version());
            }
            return Ok(());
        }

        Some(Commands::Watch {
            auto_handle,
            foreground,
            poll_interval,
            no_patterns,
            notify_only,
            notify_filter,
            notify_via,
            metrics: _metrics,
            metrics_bind: _metrics_bind,
            metrics_prefix: _metrics_prefix,
            dangerous_disable_lock,
            dangerous_bind_any,
        }) => {
            // Install panic hook so panics write a bounded, redacted crash bundle under
            // `layout.crash_dir` (required for crash-only diagnosability + E2E coverage).
            wa_core::crash::install_panic_hook(&wa_core::crash::CrashConfig {
                crash_dir: Some(layout.crash_dir.clone()),
                include_backtrace: true,
            });

            run_watcher_with_backoff(
                &layout,
                &config,
                resolved_config_path.as_deref(),
                auto_handle,
                foreground,
                poll_interval,
                no_patterns,
                notify_only,
                notify_filter,
                notify_via,
                dangerous_disable_lock,
                dangerous_bind_any,
            )
            .await?;
        }

        Some(Commands::Robot {
            format,
            stats,
            command,
        }) => {
            let start = std::time::Instant::now();
            let command = command.unwrap_or(RobotCommands::QuickStart);
            let format = resolve_robot_output_format(format);

            match command {
                RobotCommands::Help => {
                    let response = RobotResponse::success(build_robot_help(), elapsed_ms(start));
                    print_robot_response(&response, format, stats)?;
                }
                RobotCommands::QuickStart => {
                    let response =
                        RobotResponse::success(build_robot_quick_start(), elapsed_ms(start));
                    print_robot_response(&response, format, stats)?;
                }
                other => {
                    let ctx = match build_robot_context(&config, &workspace_root) {
                        Ok(ctx) => ctx,
                        Err(err) => {
                            let response = RobotResponse::<()>::error_with_code(
                                ROBOT_ERR_CONFIG,
                                format!("Failed to load config: {err}"),
                                Some("Check --config/--workspace or WA_WORKSPACE.".to_string()),
                                elapsed_ms(start),
                            );
                            print_robot_response(&response, format, stats)?;
                            return Ok(());
                        }
                    };

                    match other {
                        RobotCommands::State => {
                            let wezterm = wa_core::wezterm::default_wezterm_handle();
                            match wezterm.list_panes().await {
                                Ok(panes) => {
                                    let filter = &config.ingest.panes;
                                    let states: Vec<PaneState> = panes
                                        .iter()
                                        .map(|p| PaneState::from_pane_info(p, filter))
                                        .collect();
                                    let response =
                                        RobotResponse::success(states, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;
                                }
                                Err(e) => {
                                    let response = RobotResponse::<Vec<PaneState>>::error_with_code(
                                        "robot.wezterm_error",
                                        format!("Failed to list panes: {e}"),
                                        Some("Is WezTerm running?".to_string()),
                                        elapsed_ms(start),
                                    );
                                    print_robot_response(&response, format, stats)?;
                                }
                            }
                        }
                        RobotCommands::GetText {
                            pane_id,
                            tail,
                            escapes,
                        } => {
                            let wezterm = wa_core::wezterm::default_wezterm_handle();
                            match wezterm.get_text(pane_id, escapes).await {
                                Ok(full_text) => {
                                    // Apply tail truncation
                                    let (text, truncated, truncation_info) =
                                        apply_tail_truncation(&full_text, tail);

                                    let data = RobotGetTextData {
                                        pane_id,
                                        text,
                                        tail_lines: tail,
                                        escapes_included: escapes,
                                        truncated,
                                        truncation_info,
                                    };
                                    let response = RobotResponse::success(data, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;
                                }
                                Err(e) => {
                                    // Map errors to stable codes
                                    let (code, hint) = map_wezterm_error_to_robot(&e);
                                    let response =
                                        RobotResponse::<RobotGetTextData>::error_with_code(
                                            code,
                                            format!("{e}"),
                                            hint,
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                }
                            }
                        }
                        RobotCommands::Send {
                            pane_id,
                            text,
                            dry_run,
                            wait_for,
                            timeout_secs,
                            wait_for_regex,
                        } => {
                            use std::fmt::Write as _;

                            let redacted_text = redact_for_output(&text);
                            let mut command = if dry_run {
                                format!("wa robot send {pane_id} \"{redacted_text}\" --dry-run")
                            } else {
                                format!("wa robot send {pane_id} \"{redacted_text}\"")
                            };
                            if let Some(pattern) = &wait_for {
                                let redacted_pattern = redact_for_output(pattern);
                                let _ = write!(command, " --wait-for \"{redacted_pattern}\"");
                                if wait_for_regex {
                                    command.push_str(" --wait-for-regex");
                                }
                                let _ = write!(command, " --timeout-secs {timeout_secs}");
                            }
                            let command_ctx =
                                wa_core::dry_run::CommandContext::new(command, dry_run);

                            if command_ctx.is_dry_run() {
                                let wezterm = wa_core::wezterm::default_wezterm_handle();
                                let pane_info = wezterm.get_pane(pane_id).await.ok();
                                let storage = wa_core::storage::StorageHandle::new(
                                    &ctx.effective.paths.db_path,
                                )
                                .await
                                .ok();
                                let ipc_socket = Path::new(&ctx.effective.paths.ipc_socket_path);
                                let resolution = resolve_pane_capabilities(
                                    pane_id,
                                    storage.as_ref(),
                                    Some(ipc_socket),
                                )
                                .await;
                                let mut report = build_send_dry_run_report(
                                    &command_ctx,
                                    pane_id,
                                    pane_info.as_ref(),
                                    Some(&resolution.capabilities),
                                    &text,
                                    false,
                                    wait_for.as_deref(),
                                    timeout_secs,
                                    &config,
                                    wa_core::policy::ActorKind::Robot,
                                );
                                report.warnings.extend(resolution.warnings);
                                let response =
                                    RobotResponse::success(report.redacted(), elapsed_ms(start));
                                print_robot_response(&response, format, stats)?;
                            } else {
                                use wa_core::approval::ApprovalStore;
                                use wa_core::policy::{
                                    ActionKind, ActorKind, InjectionResult, PolicyDecision,
                                    PolicyEngine, PolicyInput,
                                };
                                use wa_core::wezterm::{PaneWaiter, WaitMatcher, WaitOptions};

                                let db_path = &ctx.effective.paths.db_path;
                                let storage = match wa_core::storage::StorageHandle::new(db_path)
                                    .await
                                {
                                    Ok(s) => s,
                                    Err(e) => {
                                        let response =
                                                RobotResponse::<RobotSendData>::error_with_code(
                                                    ROBOT_ERR_STORAGE,
                                                    format!("Failed to open storage: {e}"),
                                                    Some(
                                                        "Is the database initialized? Run 'wa watch' first."
                                                            .to_string(),
                                                    ),
                                                    elapsed_ms(start),
                                                );
                                        print_robot_response(&response, format, stats)?;
                                        return Ok(());
                                    }
                                };

                                let wezterm = wa_core::wezterm::default_wezterm_handle();
                                let pane_info = match wezterm.get_pane(pane_id).await {
                                    Ok(info) => info,
                                    Err(e) => {
                                        let (code, hint) = map_wezterm_error_to_robot(&e);
                                        let response =
                                            RobotResponse::<RobotSendData>::error_with_code(
                                                code,
                                                format!("{e}"),
                                                hint,
                                                elapsed_ms(start),
                                            );
                                        print_robot_response(&response, format, stats)?;
                                        return Ok(());
                                    }
                                };
                                let domain = pane_info.inferred_domain();

                                let mut engine = PolicyEngine::new(
                                    config.safety.rate_limit_per_pane,
                                    config.safety.rate_limit_global,
                                    config.safety.require_prompt_active,
                                )
                                .with_command_gate_config(config.safety.command_gate.clone())
                                .with_policy_rules(config.safety.rules.clone());

                                let ipc_socket = Path::new(&ctx.effective.paths.ipc_socket_path);
                                let resolution = resolve_pane_capabilities(
                                    pane_id,
                                    Some(&storage),
                                    Some(ipc_socket),
                                )
                                .await;
                                let capabilities = resolution.capabilities;

                                let summary = engine.redact_secrets(&text);
                                let input =
                                    PolicyInput::new(ActionKind::SendText, ActorKind::Robot)
                                        .with_pane(pane_id)
                                        .with_domain(domain.clone())
                                        .with_capabilities(capabilities)
                                        .with_text_summary(&summary)
                                        .with_command_text(&text);

                                let mut decision = engine.authorize(&input);
                                if decision.requires_approval() {
                                    let store = ApprovalStore::new(
                                        &storage,
                                        config.safety.approval.clone(),
                                        ctx.effective.paths.workspace_root.clone(),
                                    );
                                    decision = match store
                                        .attach_to_decision(decision, &input, Some(summary.clone()))
                                        .await
                                    {
                                        Ok(updated) => updated,
                                        Err(e) => {
                                            let response =
                                                RobotResponse::<RobotSendData>::error_with_code(
                                                    "robot.approval_error",
                                                    format!("Failed to issue approval token: {e}"),
                                                    None,
                                                    elapsed_ms(start),
                                                );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }
                                    };
                                }

                                let mut injection = match decision {
                                    PolicyDecision::Allow { .. } => {
                                        let send_result = wezterm.send_text(pane_id, &text).await;
                                        match send_result {
                                            Ok(()) => InjectionResult::Allowed {
                                                decision,
                                                summary: summary.clone(),
                                                pane_id,
                                                action: ActionKind::SendText,
                                                audit_action_id: None,
                                            },
                                            Err(e) => InjectionResult::Error {
                                                error: e.to_string(),
                                                pane_id,
                                                action: ActionKind::SendText,
                                                audit_action_id: None,
                                            },
                                        }
                                    }
                                    PolicyDecision::Deny { .. } => InjectionResult::Denied {
                                        decision,
                                        summary: summary.clone(),
                                        pane_id,
                                        action: ActionKind::SendText,
                                        audit_action_id: None,
                                    },
                                    PolicyDecision::RequireApproval { .. } => {
                                        InjectionResult::RequiresApproval {
                                            decision,
                                            summary: summary.clone(),
                                            pane_id,
                                            action: ActionKind::SendText,
                                            audit_action_id: None,
                                        }
                                    }
                                };

                                let mut audit_record = injection.to_audit_record(
                                    ActorKind::Robot,
                                    None,
                                    Some(domain.clone()),
                                );
                                audit_record.input_summary =
                                    Some(wa_core::policy::build_send_text_audit_summary(
                                        &text, None, None,
                                    ));
                                match storage.record_audit_action_redacted(audit_record).await {
                                    Ok(audit_id) => {
                                        injection.set_audit_action_id(audit_id);
                                    }
                                    Err(e) => {
                                        tracing::warn!(pane_id, "Failed to record audit: {e}");
                                    }
                                }

                                let mut wait_for_data = None;
                                let mut verification_error = None;
                                if injection.is_allowed() {
                                    if let Some(pattern) = &wait_for {
                                        let matcher = if wait_for_regex {
                                            match fancy_regex::Regex::new(pattern) {
                                                Ok(compiled) => Some(WaitMatcher::regex(compiled)),
                                                Err(e) => {
                                                    verification_error = Some(format!(
                                                        "Invalid wait-for regex: {e}"
                                                    ));
                                                    None
                                                }
                                            }
                                        } else {
                                            Some(WaitMatcher::substring(pattern))
                                        };

                                        if let Some(matcher) = matcher {
                                            let options = WaitOptions {
                                                tail_lines: 200,
                                                escapes: false,
                                                ..WaitOptions::default()
                                            };
                                            let source = wa_core::wezterm::WeztermHandleSource::new(
                                                Arc::clone(&wezterm),
                                            );
                                            let waiter =
                                                PaneWaiter::new(&source).with_options(options);
                                            let timeout =
                                                std::time::Duration::from_secs(timeout_secs);
                                            match waiter.wait_for(pane_id, &matcher, timeout).await
                                            {
                                                Ok(wa_core::wezterm::WaitResult::Matched {
                                                    elapsed_ms,
                                                    polls,
                                                }) => {
                                                    wait_for_data = Some(RobotWaitForData {
                                                        pane_id,
                                                        pattern: pattern.clone(),
                                                        matched: true,
                                                        elapsed_ms,
                                                        polls,
                                                        is_regex: wait_for_regex,
                                                    });
                                                }
                                                Ok(wa_core::wezterm::WaitResult::TimedOut {
                                                    elapsed_ms,
                                                    polls,
                                                    ..
                                                }) => {
                                                    wait_for_data = Some(RobotWaitForData {
                                                        pane_id,
                                                        pattern: pattern.clone(),
                                                        matched: false,
                                                        elapsed_ms,
                                                        polls,
                                                        is_regex: wait_for_regex,
                                                    });
                                                    verification_error = Some(format!(
                                                        "Timeout waiting for pattern '{pattern}'"
                                                    ));
                                                }
                                                Err(e) => {
                                                    verification_error =
                                                        Some(format!("wait-for failed: {e}"));
                                                }
                                            }
                                        }
                                    }
                                }

                                let data = RobotSendData {
                                    pane_id,
                                    injection,
                                    wait_for: wait_for_data,
                                    verification_error,
                                };
                                let response = RobotResponse::success(data, elapsed_ms(start));
                                print_robot_response(&response, format, stats)?;
                            }
                        }
                        RobotCommands::WaitFor {
                            pane_id,
                            pattern,
                            timeout_secs,
                            tail,
                            regex,
                        } => {
                            use std::time::Duration;
                            use wa_core::wezterm::{
                                PaneWaiter, WaitMatcher, WaitOptions, WaitResult,
                                WeztermHandleSource, default_wezterm_handle,
                            };

                            // Build the matcher
                            let matcher = if regex {
                                match fancy_regex::Regex::new(&pattern) {
                                    Ok(compiled) => WaitMatcher::regex(compiled),
                                    Err(e) => {
                                        let response =
                                            RobotResponse::<RobotWaitForData>::error_with_code(
                                                "WA-ROBOT-INVALID-REGEX",
                                                format!("Invalid regex pattern: {e}"),
                                                Some("Check the regex syntax".to_string()),
                                                elapsed_ms(start),
                                            );
                                        print_robot_response(&response, format, stats)?;
                                        return Ok(());
                                    }
                                }
                            } else {
                                WaitMatcher::substring(&pattern)
                            };

                            // Create WezTerm client
                            let wezterm = default_wezterm_handle();

                            // First verify the pane exists
                            match wezterm.list_panes().await {
                                Ok(panes) => {
                                    if !panes.iter().any(|p| p.pane_id == pane_id) {
                                        let response =
                                            RobotResponse::<RobotWaitForData>::error_with_code(
                                                "WA-ROBOT-PANE-NOT-FOUND",
                                                format!("Pane {pane_id} not found"),
                                                Some(
                                                    "Use 'wa robot state' to list available panes"
                                                        .to_string(),
                                                ),
                                                elapsed_ms(start),
                                            );
                                        print_robot_response(&response, format, stats)?;
                                        return Ok(());
                                    }
                                }
                                Err(e) => {
                                    let response =
                                        RobotResponse::<RobotWaitForData>::error_with_code(
                                            "WA-ROBOT-WEZTERM-ERROR",
                                            format!("Failed to list panes: {e}"),
                                            None,
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            }

                            // Configure wait options
                            let options = WaitOptions {
                                tail_lines: tail,
                                escapes: false,
                                ..WaitOptions::default()
                            };

                            // Create waiter and wait
                            let source = WeztermHandleSource::new(Arc::clone(&wezterm));
                            let waiter = PaneWaiter::new(&source).with_options(options);
                            let timeout = Duration::from_secs(timeout_secs);

                            tracing::info!(
                                pane_id,
                                pattern = %pattern,
                                timeout_secs,
                                is_regex = regex,
                                "Starting wait-for"
                            );

                            match waiter.wait_for(pane_id, &matcher, timeout).await {
                                Ok(WaitResult::Matched {
                                    elapsed_ms: elapsed,
                                    polls,
                                }) => {
                                    let data = RobotWaitForData {
                                        pane_id,
                                        pattern,
                                        matched: true,
                                        elapsed_ms: elapsed,
                                        polls,
                                        is_regex: regex,
                                    };
                                    let response = RobotResponse::success(data, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;
                                }
                                Ok(WaitResult::TimedOut {
                                    elapsed_ms: elapsed,
                                    polls,
                                    ..
                                }) => {
                                    let response = RobotResponse::<RobotWaitForData>::error_with_code(
                                        "WA-ROBOT-TIMEOUT",
                                        format!(
                                            "Timeout waiting for pattern '{pattern}' after {elapsed}ms ({polls} polls)"
                                        ),
                                        Some("Increase --timeout-secs or check if the pattern is correct".to_string()),
                                        elapsed_ms(start),
                                    );
                                    print_robot_response(&response, format, stats)?;
                                }
                                Err(e) => {
                                    let response =
                                        RobotResponse::<RobotWaitForData>::error_with_code(
                                            "WA-ROBOT-GET-TEXT-FAILED",
                                            format!("Failed to get pane text: {e}"),
                                            None,
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                }
                            }
                        }
                        RobotCommands::Search {
                            query,
                            limit,
                            pane,
                            since,
                            snippets,
                        } => {
                            // Get workspace layout for db path
                            let layout = match config.workspace_layout(Some(&workspace_root)) {
                                Ok(l) => l,
                                Err(e) => {
                                    let response =
                                        RobotResponse::<RobotSearchData>::error_with_code(
                                            ROBOT_ERR_CONFIG,
                                            format!("Failed to get workspace layout: {e}"),
                                            Some("Check --workspace or WA_WORKSPACE".to_string()),
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            let lints = wa_core::storage::lint_fts_query(&query);
                            if search_lints_have_errors(&lints) {
                                let response = RobotResponse::<RobotSearchData>::error_with_code(
                                    ROBOT_ERR_FTS_QUERY,
                                    "Invalid search query.".to_string(),
                                    format_search_lint_hint(&lints),
                                    elapsed_ms(start),
                                );
                                print_robot_response(&response, format, stats)?;
                                return Ok(());
                            }

                            // Open storage handle
                            let db_path = layout.db_path.to_string_lossy();
                            let storage = match wa_core::storage::StorageHandle::new(&db_path).await
                            {
                                Ok(s) => s,
                                Err(e) => {
                                    let response = RobotResponse::<RobotSearchData>::error_with_code(
                                        ROBOT_ERR_STORAGE,
                                        format!("Failed to open storage: {e}"),
                                        Some("Is the database initialized? Run 'wa watch' first.".to_string()),
                                        elapsed_ms(start),
                                    );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            // Build search options
                            let options = wa_core::storage::SearchOptions {
                                limit: Some(limit),
                                pane_id: pane,
                                since,
                                until: None,
                                include_snippets: Some(snippets),
                                snippet_max_tokens: Some(30), // Reasonable default for terminal output
                                highlight_prefix: Some(">>".to_string()),
                                highlight_suffix: Some("<<".to_string()),
                            };

                            // Perform search
                            match storage.search_with_results(&query, options).await {
                                Ok(results) => {
                                    let total_hits = results.len();
                                    let hits: Vec<RobotSearchHit> = results
                                        .into_iter()
                                        .map(|r| RobotSearchHit {
                                            segment_id: r.segment.id,
                                            pane_id: r.segment.pane_id,
                                            seq: r.segment.seq,
                                            captured_at: r.segment.captured_at,
                                            score: r.score,
                                            snippet: r.snippet,
                                            content: if snippets {
                                                None // Don't include full content when snippets are requested
                                            } else {
                                                Some(r.segment.content)
                                            },
                                        })
                                        .collect();

                                    let data = RobotSearchData {
                                        query,
                                        results: hits,
                                        total_hits,
                                        limit,
                                        pane_filter: pane,
                                        since_filter: since,
                                    };
                                    let response = RobotResponse::success(data, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;
                                }
                                Err(e) => {
                                    // Map storage errors to robot error codes
                                    let (code, hint) = match &e {
                                        wa_core::Error::Storage(
                                            wa_core::StorageError::FtsQueryError(_),
                                        ) => (
                                            ROBOT_ERR_FTS_QUERY,
                                            Some("Check FTS5 query syntax. Supported: words, \"phrases\", prefix*, AND/OR/NOT".to_string()),
                                        ),
                                        _ => (ROBOT_ERR_STORAGE, None),
                                    };
                                    let response =
                                        RobotResponse::<RobotSearchData>::error_with_code(
                                            code,
                                            format!("{e}"),
                                            hint,
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                }
                            }
                        }
                        RobotCommands::SearchExplain { query, pane } => {
                            let layout = match config.workspace_layout(Some(&workspace_root)) {
                                Ok(l) => l,
                                Err(e) => {
                                    let response =
                                        RobotResponse::<RobotSearchExplainData>::error_with_code(
                                            ROBOT_ERR_CONFIG,
                                            format!("Failed to get workspace layout: {e}"),
                                            Some("Check --workspace or WA_WORKSPACE".to_string()),
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            let db_path = layout.db_path.to_string_lossy();
                            let storage = match wa_core::storage::StorageHandle::new(&db_path).await
                            {
                                Ok(s) => s,
                                Err(e) => {
                                    let response =
                                        RobotResponse::<RobotSearchExplainData>::error_with_code(
                                            ROBOT_ERR_STORAGE,
                                            format!("Failed to open storage: {e}"),
                                            Some(
                                                "Is the database initialized? Run 'wa watch' first."
                                                    .to_string(),
                                            ),
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            match wa_core::search_explain::build_explain_context(
                                &storage, &query, pane,
                            )
                            .await
                            {
                                Ok(ctx) => {
                                    let result = wa_core::search_explain::explain_search(&ctx);
                                    let data = RobotSearchExplainData {
                                        query,
                                        pane_filter: pane,
                                        total_panes: result.total_panes,
                                        observed_panes: result.observed_panes,
                                        ignored_panes: result.ignored_panes,
                                        total_segments: result.total_segments,
                                        reasons: result.reasons,
                                    };
                                    let response = RobotResponse::success(data, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;
                                }
                                Err(e) => {
                                    let response =
                                        RobotResponse::<RobotSearchExplainData>::error_with_code(
                                            ROBOT_ERR_STORAGE,
                                            format!("Search explain failed: {e}"),
                                            None,
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                }
                            }
                        }
                        RobotCommands::Events {
                            limit,
                            pane,
                            rule_id,
                            event_type,
                            triage_state,
                            label,
                            unhandled,
                            since,
                            would_handle,
                            dry_run,
                            command,
                        } => {
                            // Get workspace layout for DB path
                            let layout = match config.workspace_layout(Some(&workspace_root)) {
                                Ok(l) => l,
                                Err(e) => {
                                    let response =
                                        RobotResponse::<RobotEventsData>::error_with_code(
                                            ROBOT_ERR_CONFIG,
                                            format!("Failed to get workspace layout: {e}"),
                                            Some("Check --workspace or WA_WORKSPACE".to_string()),
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            // Open storage handle
                            let db_path = layout.db_path.to_string_lossy();
                            let storage = match wa_core::storage::StorageHandle::new(&db_path).await
                            {
                                Ok(s) => s,
                                Err(e) => {
                                    let response = RobotResponse::<RobotEventsData>::error_with_code(
                                        ROBOT_ERR_STORAGE,
                                        format!("Failed to open storage: {e}"),
                                        Some("Is the database initialized? Run 'wa watch' first.".to_string()),
                                        elapsed_ms(start),
                                    );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            // Mutating subcommands (bd-2gce)
                            if let Some(cmd) = command {
                                use wa_core::storage::{AuditActionRecord, EventAnnotations};
                                let now = now_ms_i64();

                                let (event_id, changed) = match cmd {
                                    RobotEventsCommands::Annotate {
                                        event_id,
                                        note,
                                        clear,
                                        by,
                                    } => {
                                        if clear == note.is_some() {
                                            let response = RobotResponse::<RobotEventMutationData>::error_with_code(
                                                ROBOT_ERR_INVALID_ARGS,
                                                "Invalid annotate params: specify exactly one of --note or --clear".to_string(),
                                                Some("Example: wa robot events annotate 123 --note \"Investigating\"".to_string()),
                                                elapsed_ms(start),
                                            );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }

                                        if let Err(e) =
                                            storage.set_event_note(event_id, note, by.clone()).await
                                        {
                                            let response = RobotResponse::<RobotEventMutationData>::error_with_code(
                                                ROBOT_ERR_STORAGE,
                                                format!("Failed to update note: {e}"),
                                                None,
                                                elapsed_ms(start),
                                            );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }

                                        let audit = AuditActionRecord {
                                            id: 0,
                                            ts: now,
                                            actor_kind: "robot".to_string(),
                                            actor_id: by.clone(),
                                            correlation_id: None,
                                            pane_id: None,
                                            domain: None,
                                            action_kind: "event.annotate".to_string(),
                                            policy_decision: "allow".to_string(),
                                            decision_reason: Some(
                                                "Robot updated event note".to_string(),
                                            ),
                                            rule_id: None,
                                            input_summary: Some(if clear {
                                                format!(
                                                    "wa robot events annotate {event_id} --clear"
                                                )
                                            } else {
                                                format!(
                                                    "wa robot events annotate {event_id} --note <redacted>"
                                                )
                                            }),
                                            verification_summary: None,
                                            decision_context: None,
                                            result: "success".to_string(),
                                        };
                                        if let Err(e) =
                                            storage.record_audit_action_redacted(audit).await
                                        {
                                            tracing::warn!(
                                                "Failed to record event annotation audit: {e}"
                                            );
                                        }

                                        (event_id, None)
                                    }
                                    RobotEventsCommands::Triage {
                                        event_id,
                                        state,
                                        clear,
                                        by,
                                    } => {
                                        if clear == state.is_some() {
                                            let response = RobotResponse::<RobotEventMutationData>::error_with_code(
                                                ROBOT_ERR_INVALID_ARGS,
                                                "Invalid triage params: specify exactly one of --state or --clear".to_string(),
                                                Some("Example: wa robot events triage 123 --state investigating".to_string()),
                                                elapsed_ms(start),
                                            );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }

                                        let changed = match storage
                                            .set_event_triage_state(
                                                event_id,
                                                state.clone(),
                                                by.clone(),
                                            )
                                            .await
                                        {
                                            Ok(v) => v,
                                            Err(e) => {
                                                let response = RobotResponse::<
                                                    RobotEventMutationData,
                                                >::error_with_code(
                                                    ROBOT_ERR_STORAGE,
                                                    format!("Failed to update triage state: {e}"),
                                                    None,
                                                    elapsed_ms(start),
                                                );
                                                print_robot_response(&response, format, stats)?;
                                                return Ok(());
                                            }
                                        };

                                        let audit = AuditActionRecord {
                                            id: 0,
                                            ts: now,
                                            actor_kind: "robot".to_string(),
                                            actor_id: by.clone(),
                                            correlation_id: None,
                                            pane_id: None,
                                            domain: None,
                                            action_kind: "event.triage".to_string(),
                                            policy_decision: "allow".to_string(),
                                            decision_reason: Some(
                                                "Robot updated event triage state".to_string(),
                                            ),
                                            rule_id: None,
                                            input_summary: Some(if clear {
                                                format!("wa robot events triage {event_id} --clear")
                                            } else {
                                                format!(
                                                    "wa robot events triage {event_id} --state {}",
                                                    state.unwrap_or_default()
                                                )
                                            }),
                                            verification_summary: None,
                                            decision_context: None,
                                            result: if changed {
                                                "success".to_string()
                                            } else {
                                                "noop".to_string()
                                            },
                                        };
                                        if let Err(e) =
                                            storage.record_audit_action_redacted(audit).await
                                        {
                                            tracing::warn!(
                                                "Failed to record event triage audit: {e}"
                                            );
                                        }

                                        (event_id, Some(changed))
                                    }
                                    RobotEventsCommands::Label {
                                        event_id,
                                        add,
                                        remove,
                                        list,
                                        by,
                                    } => {
                                        let mut ops = 0;
                                        if add.is_some() {
                                            ops += 1;
                                        }
                                        if remove.is_some() {
                                            ops += 1;
                                        }
                                        if list {
                                            ops += 1;
                                        }
                                        if ops != 1 {
                                            let response = RobotResponse::<RobotEventMutationData>::error_with_code(
                                                ROBOT_ERR_INVALID_ARGS,
                                                "Invalid label params: specify exactly one of --add, --remove, or --list".to_string(),
                                                Some("Example: wa robot events label 123 --add urgent".to_string()),
                                                elapsed_ms(start),
                                            );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }

                                        let changed = if let Some(label) = add.clone() {
                                            let inserted = match storage
                                                .add_event_label(
                                                    event_id,
                                                    label.clone(),
                                                    by.clone(),
                                                )
                                                .await
                                            {
                                                Ok(v) => v,
                                                Err(e) => {
                                                    let response = RobotResponse::<
                                                        RobotEventMutationData,
                                                    >::error_with_code(
                                                        ROBOT_ERR_STORAGE,
                                                        format!("Failed to add label: {e}"),
                                                        None,
                                                        elapsed_ms(start),
                                                    );
                                                    print_robot_response(&response, format, stats)?;
                                                    return Ok(());
                                                }
                                            };

                                            let audit = AuditActionRecord {
                                                id: 0,
                                                ts: now,
                                                actor_kind: "robot".to_string(),
                                                actor_id: by.clone(),
                                                correlation_id: None,
                                                pane_id: None,
                                                domain: None,
                                                action_kind: "event.label.add".to_string(),
                                                policy_decision: "allow".to_string(),
                                                decision_reason: Some(
                                                    "Robot added event label".to_string(),
                                                ),
                                                rule_id: None,
                                                input_summary: Some(format!(
                                                    "wa robot events label {event_id} --add {label}"
                                                )),
                                                verification_summary: None,
                                                decision_context: None,
                                                result: if inserted {
                                                    "success".to_string()
                                                } else {
                                                    "noop".to_string()
                                                },
                                            };
                                            if let Err(e) =
                                                storage.record_audit_action_redacted(audit).await
                                            {
                                                tracing::warn!(
                                                    "Failed to record event label audit: {e}"
                                                );
                                            }

                                            Some(inserted)
                                        } else if let Some(label) = remove.clone() {
                                            let removed = match storage
                                                .remove_event_label(event_id, label.clone())
                                                .await
                                            {
                                                Ok(v) => v,
                                                Err(e) => {
                                                    let response = RobotResponse::<
                                                        RobotEventMutationData,
                                                    >::error_with_code(
                                                        ROBOT_ERR_STORAGE,
                                                        format!("Failed to remove label: {e}"),
                                                        None,
                                                        elapsed_ms(start),
                                                    );
                                                    print_robot_response(&response, format, stats)?;
                                                    return Ok(());
                                                }
                                            };

                                            let audit = AuditActionRecord {
                                                id: 0,
                                                ts: now,
                                                actor_kind: "robot".to_string(),
                                                actor_id: by.clone(),
                                                correlation_id: None,
                                                pane_id: None,
                                                domain: None,
                                                action_kind: "event.label.remove".to_string(),
                                                policy_decision: "allow".to_string(),
                                                decision_reason: Some(
                                                    "Robot removed event label".to_string(),
                                                ),
                                                rule_id: None,
                                                input_summary: Some(format!(
                                                    "wa robot events label {event_id} --remove {label}"
                                                )),
                                                verification_summary: None,
                                                decision_context: None,
                                                result: if removed {
                                                    "success".to_string()
                                                } else {
                                                    "noop".to_string()
                                                },
                                            };
                                            if let Err(e) =
                                                storage.record_audit_action_redacted(audit).await
                                            {
                                                tracing::warn!(
                                                    "Failed to record event label audit: {e}"
                                                );
                                            }

                                            Some(removed)
                                        } else {
                                            None
                                        };

                                        (event_id, changed)
                                    }
                                };

                                let annotations: EventAnnotations = match storage
                                    .get_event_annotations(event_id)
                                    .await
                                {
                                    Ok(Some(a)) => a,
                                    Ok(None) => {
                                        let response = RobotResponse::<RobotEventMutationData>::error_with_code(
                                                "robot.event_not_found",
                                                format!("Event {event_id} not found"),
                                                Some("Use 'wa robot events' to list events and IDs".to_string()),
                                                elapsed_ms(start),
                                            );
                                        print_robot_response(&response, format, stats)?;
                                        return Ok(());
                                    }
                                    Err(e) => {
                                        let response = RobotResponse::<RobotEventMutationData>::error_with_code(
                                                ROBOT_ERR_STORAGE,
                                                format!("Failed to fetch annotations: {e}"),
                                                None,
                                                elapsed_ms(start),
                                            );
                                        print_robot_response(&response, format, stats)?;
                                        return Ok(());
                                    }
                                };

                                let data = RobotEventMutationData {
                                    event_id,
                                    changed,
                                    annotations,
                                };
                                let response = RobotResponse::success(data, elapsed_ms(start));
                                print_robot_response(&response, format, stats)?;
                                return Ok(());
                            }

                            // Build event query
                            let query = wa_core::storage::EventQuery {
                                limit: Some(limit),
                                pane_id: pane,
                                rule_id: rule_id.clone(),
                                event_type: event_type.clone(),
                                triage_state: triage_state.clone(),
                                label: label.clone(),
                                unhandled_only: unhandled,
                                since,
                                until: None,
                            };

                            // Query events
                            match storage.get_events(query).await {
                                Ok(events) => {
                                    let include_preview = would_handle || dry_run;
                                    let rule_index = if include_preview {
                                        let patterns_root = resolved_config_path
                                            .as_deref()
                                            .and_then(|p| p.parent());
                                        match wa_core::patterns::PatternEngine::from_config_with_root(
                                            &config.patterns,
                                            patterns_root,
                                        ) {
                                            Ok(engine) => {
                                                let mut index = std::collections::HashMap::new();
                                                for rule in engine.rules() {
                                                    index.insert(rule.id.clone(), rule.clone());
                                                }
                                                Some(index)
                                            }
                                            Err(err) => {
                                                tracing::warn!(
                                                    error = %err,
                                                    "Failed to load pattern engine for previews"
                                                );
                                                None
                                            }
                                        }
                                    } else {
                                        None
                                    };
                                    let total_count = events.len();
                                    let mut items: Vec<RobotEventItem> =
                                        Vec::with_capacity(events.len());
                                    for e in events {
                                        let annotations = match storage
                                            .get_event_annotations(e.id)
                                            .await
                                        {
                                            Ok(Some(a)) => Some(a),
                                            Ok(None) => None,
                                            Err(err) => {
                                                tracing::warn!(error = %err, event_id = e.id, "Failed to load event annotations");
                                                None
                                            }
                                        };
                                        // Derive pack_id from rule_id (e.g., "codex.usage.reached" -> "builtin:codex")
                                        let pack_id = e.rule_id.split('.').next().map_or_else(
                                            || "builtin:unknown".to_string(),
                                            |agent| format!("builtin:{agent}"),
                                        );
                                        let preview = if include_preview {
                                            let rule = rule_index
                                                .as_ref()
                                                .and_then(|index| index.get(&e.rule_id));
                                            build_event_would_handle(&e, rule, &config)
                                        } else {
                                            None
                                        };
                                        items.push(RobotEventItem {
                                            id: e.id,
                                            pane_id: e.pane_id,
                                            rule_id: e.rule_id,
                                            pack_id,
                                            event_type: e.event_type,
                                            severity: e.severity,
                                            confidence: e.confidence,
                                            extracted: e.extracted,
                                            annotations,
                                            captured_at: e.detected_at,
                                            handled_at: e.handled_at,
                                            workflow_id: e.handled_by_workflow_id,
                                            would_handle_with: preview,
                                        });
                                    }

                                    let data = RobotEventsData {
                                        events: items,
                                        total_count,
                                        limit,
                                        pane_filter: pane,
                                        rule_id_filter: rule_id,
                                        event_type_filter: event_type,
                                        triage_state_filter: triage_state,
                                        label_filter: label,
                                        unhandled_only: unhandled,
                                        since_filter: since,
                                        would_handle: include_preview,
                                        dry_run,
                                    };
                                    let response = RobotResponse::success(data, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;
                                }
                                Err(e) => {
                                    let response =
                                        RobotResponse::<RobotEventsData>::error_with_code(
                                            ROBOT_ERR_STORAGE,
                                            format!("Failed to query events: {e}"),
                                            None,
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                }
                            }
                        }
                        RobotCommands::Workflow { command } => {
                            match command {
                                RobotWorkflowCommands::Run {
                                    name,
                                    pane_id,
                                    force,
                                    dry_run,
                                } => {
                                    use std::sync::Arc;
                                    use wa_core::policy::{PolicyEngine, PolicyGatedInjector};
                                    use wa_core::storage::StorageHandle;
                                    use wa_core::workflows::{
                                        PaneWorkflowLockManager, WorkflowEngine,
                                        WorkflowExecutionResult, WorkflowRunner,
                                        WorkflowRunnerConfig,
                                    };

                                    // Handle dry-run mode
                                    if dry_run {
                                        let command_ctx = wa_core::dry_run::CommandContext::new(
                                            "workflow run",
                                            true,
                                        );
                                        let wezterm = wa_core::wezterm::default_wezterm_handle();
                                        let pane_info = wezterm.get_pane(pane_id).await.ok();
                                        let report = build_workflow_dry_run_report(
                                            &command_ctx,
                                            &name,
                                            pane_id,
                                            pane_info.as_ref(),
                                            &config,
                                        );
                                        let response = RobotResponse::success(
                                            report.redacted(),
                                            elapsed_ms(start),
                                        );
                                        print_robot_response(&response, format, stats)?;
                                        return Ok(());
                                    }

                                    // Verify pane exists
                                    let wezterm = wa_core::wezterm::default_wezterm_handle();
                                    match wezterm.list_panes().await {
                                        Ok(panes) => {
                                            if !panes.iter().any(|p| p.pane_id == pane_id) {
                                                let response =
                                                    RobotResponse::<RobotWorkflowData>::error_with_code(
                                                        "robot.pane_not_found",
                                                        format!("Pane {pane_id} does not exist"),
                                                        Some(
                                                            "Use 'wa robot state' to list available panes."
                                                                .to_string(),
                                                        ),
                                                        elapsed_ms(start),
                                                    );
                                                print_robot_response(&response, format, stats)?;
                                                return Ok(());
                                            }
                                        }
                                        Err(e) => {
                                            let (code, hint) = map_wezterm_error_to_robot(&e);
                                            let response =
                                                RobotResponse::<RobotWorkflowData>::error_with_code(
                                                    code,
                                                    format!("{e}"),
                                                    hint,
                                                    elapsed_ms(start),
                                                );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }
                                    }

                                    // Set up workflow infrastructure
                                    let db_path = &ctx.effective.paths.db_path;
                                    let storage = match StorageHandle::new(db_path).await {
                                        Ok(s) => Arc::new(s),
                                        Err(e) => {
                                            let response =
                                                RobotResponse::<RobotWorkflowData>::error_with_code(
                                                    "robot.storage_error",
                                                    format!("Failed to open storage: {e}"),
                                                    Some(
                                                        "Check database path and permissions."
                                                            .to_string(),
                                                    ),
                                                    elapsed_ms(start),
                                                );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }
                                    };

                                    let engine = WorkflowEngine::new(10);
                                    let lock_manager = Arc::new(PaneWorkflowLockManager::new());

                                    // Create policy engine from safety config
                                    let policy_engine = PolicyEngine::new(
                                        config.safety.rate_limit_per_pane,
                                        config.safety.rate_limit_global,
                                        false, // Don't require prompt active for robot mode
                                    );

                                    // Create policy-gated injector with WezTerm client
                                    let wezterm_handle = wa_core::wezterm::default_wezterm_handle();
                                    let injector = Arc::new(tokio::sync::Mutex::new(
                                        PolicyGatedInjector::with_storage(
                                            policy_engine,
                                            wezterm_handle,
                                            storage.as_ref().clone(),
                                        ),
                                    ));
                                    let runner_config = WorkflowRunnerConfig::default();
                                    let runner = WorkflowRunner::new(
                                        engine,
                                        lock_manager,
                                        Arc::clone(&storage),
                                        injector,
                                        runner_config,
                                    );

                                    // Look up workflow by name
                                    let workflow = runner.find_workflow_by_name(&name);
                                    let _ = force; // Will be used when implementing "already handled" bypass

                                    if let Some(wf) = workflow {
                                        // Generate execution ID
                                        let now_ms = std::time::SystemTime::now()
                                            .duration_since(std::time::UNIX_EPOCH)
                                            .unwrap_or_default()
                                            .as_millis();
                                        let execution_id = format!("robot-{name}-{now_ms}");

                                        // Run the workflow
                                        let result = runner
                                            .run_workflow(pane_id, wf, &execution_id, 0)
                                            .await;

                                        let (
                                            status,
                                            message,
                                            result_value,
                                            steps_executed,
                                            step_index,
                                        ) = match result {
                                            WorkflowExecutionResult::Completed {
                                                result,
                                                steps_executed,
                                                ..
                                            } => (
                                                "completed",
                                                None,
                                                Some(result),
                                                Some(steps_executed),
                                                None,
                                            ),
                                            WorkflowExecutionResult::Aborted {
                                                reason,
                                                step_index,
                                                ..
                                            } => (
                                                "aborted",
                                                Some(reason),
                                                None,
                                                None,
                                                Some(step_index),
                                            ),
                                            WorkflowExecutionResult::PolicyDenied {
                                                reason,
                                                step_index,
                                                ..
                                            } => (
                                                "policy_denied",
                                                Some(reason),
                                                None,
                                                None,
                                                Some(step_index),
                                            ),
                                            WorkflowExecutionResult::Error { error, .. } => (
                                                "error",
                                                Some(error),
                                                None,
                                                None,
                                                None, // Error variant doesn't track step_index
                                            ),
                                        };

                                        let workflow_elapsed = elapsed_ms(start);
                                        let data = RobotWorkflowData {
                                            workflow_name: name.clone(),
                                            pane_id,
                                            execution_id: Some(execution_id),
                                            status: status.to_string(),
                                            message,
                                            result: result_value,
                                            steps_executed,
                                            step_index,
                                            elapsed_ms: Some(workflow_elapsed),
                                        };

                                        let response = if status == "completed" {
                                            RobotResponse::success(data, workflow_elapsed)
                                        } else if status == "policy_denied" {
                                            RobotResponse::<RobotWorkflowData>::error_with_code(
                                                "robot.policy_denied",
                                                format!("Workflow '{name}' denied by policy"),
                                                Some(
                                                    "Check safety configuration or use --dry-run."
                                                        .to_string(),
                                                ),
                                                workflow_elapsed,
                                            )
                                        } else {
                                            let status_message =
                                                data.message.as_deref().unwrap_or("failed");
                                            RobotResponse::<RobotWorkflowData>::error_with_code(
                                                &format!("robot.workflow_{status}"),
                                                format!("Workflow '{name}' {status_message}"),
                                                None,
                                                workflow_elapsed,
                                            )
                                        };
                                        print_robot_response(&response, format, stats)?;
                                    } else {
                                        // No workflow registered with this name
                                        let response =
                                            RobotResponse::<RobotWorkflowData>::error_with_code(
                                                "robot.workflow_not_found",
                                                format!("Workflow '{name}' not found"),
                                                Some(
                                                    "No workflows registered in standalone mode. \
                                                     Use 'wa watch --auto-handle' for event-driven workflows."
                                                        .to_string(),
                                                ),
                                                elapsed_ms(start),
                                            );
                                        tracing::debug!(
                                            workflow = %name,
                                            pane_id,
                                            "Workflow not found"
                                        );
                                        print_robot_response(&response, format, stats)?;
                                    }

                                    // Clean shutdown of storage
                                    if let Err(e) = storage.shutdown().await {
                                        tracing::warn!("Failed to shutdown storage cleanly: {e}");
                                    }
                                }
                                RobotWorkflowCommands::List => {
                                    // List available workflows
                                    // In standalone robot mode, workflows are defined but not
                                    // registered. List the built-in workflow definitions.
                                    let workflows: Vec<RobotWorkflowInfo> = vec![
                                        RobotWorkflowInfo {
                                            name: "handle_compaction".to_string(),
                                            description: Some(
                                                "Re-inject critical context after conversation \
                                                 compaction"
                                                    .to_string(),
                                            ),
                                            enabled: true,
                                            trigger_event_types: Some(vec![
                                                "compaction_warning".to_string(),
                                            ]),
                                            requires_pane: Some(true),
                                        },
                                        RobotWorkflowInfo {
                                            name: "handle_usage_limits".to_string(),
                                            description: Some(
                                                "Handle API usage limit reached events".to_string(),
                                            ),
                                            enabled: true,
                                            trigger_event_types: Some(vec![
                                                "usage_limit".to_string(),
                                            ]),
                                            requires_pane: Some(true),
                                        },
                                        RobotWorkflowInfo {
                                            name: "handle_session_end".to_string(),
                                            description: Some(
                                                "Capture and store structured session summary on \
                                                 agent session end"
                                                    .to_string(),
                                            ),
                                            enabled: true,
                                            trigger_event_types: Some(vec![
                                                "session_end".to_string(),
                                            ]),
                                            requires_pane: Some(true),
                                        },
                                        RobotWorkflowInfo {
                                            name: "handle_auth_required".to_string(),
                                            description: Some(
                                                "Handle authentication prompts requiring user \
                                                 intervention or automated login"
                                                    .to_string(),
                                            ),
                                            enabled: true,
                                            trigger_event_types: Some(vec![
                                                "auth_required".to_string(),
                                            ]),
                                            requires_pane: Some(true),
                                        },
                                        RobotWorkflowInfo {
                                            name: "handle_claude_code_limits".to_string(),
                                            description: Some(
                                                "Safe-pause on Claude Code usage/rate limits \
                                                 with recovery plan"
                                                    .to_string(),
                                            ),
                                            enabled: true,
                                            trigger_event_types: Some(vec![
                                                "usage.warning".to_string(),
                                                "usage.reached".to_string(),
                                            ]),
                                            requires_pane: Some(true),
                                        },
                                        RobotWorkflowInfo {
                                            name: "handle_gemini_quota".to_string(),
                                            description: Some(
                                                "Safe-pause on Gemini quota/usage limits \
                                                 with recovery plan"
                                                    .to_string(),
                                            ),
                                            enabled: true,
                                            trigger_event_types: Some(vec![
                                                "usage.warning".to_string(),
                                                "usage.reached".to_string(),
                                            ]),
                                            requires_pane: Some(true),
                                        },
                                    ];

                                    let total = workflows.len();
                                    let data = RobotWorkflowListData {
                                        workflows,
                                        total,
                                        enabled_count: Some(total),
                                    };
                                    let response = RobotResponse::success(data, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;
                                }
                                RobotWorkflowCommands::Status {
                                    execution_id,
                                    pane,
                                    active,
                                    verbose,
                                } => {
                                    // Get workspace layout for DB path
                                    let layout =
                                        match config.workspace_layout(Some(&workspace_root)) {
                                            Ok(l) => l,
                                            Err(e) => {
                                                let response = RobotResponse::<
                                                    RobotWorkflowStatusData,
                                                >::error_with_code(
                                                    ROBOT_ERR_CONFIG,
                                                    format!("Failed to get workspace layout: {e}"),
                                                    None,
                                                    elapsed_ms(start),
                                                );
                                                print_robot_response(&response, format, stats)?;
                                                return Ok(());
                                            }
                                        };

                                    // Open storage handle
                                    let db_path = layout.db_path.to_string_lossy();
                                    let storage = match wa_core::storage::StorageHandle::new(
                                        &db_path,
                                    )
                                    .await
                                    {
                                        Ok(s) => s,
                                        Err(e) => {
                                            let response = RobotResponse::<
                                                    RobotWorkflowStatusData,
                                                >::error_with_code(
                                                    ROBOT_ERR_STORAGE,
                                                    format!("Failed to open storage: {e}"),
                                                    Some(
                                                        "Is the database initialized? Run 'wa watch' first."
                                                            .to_string(),
                                                    ),
                                                    elapsed_ms(start),
                                                );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }
                                    };

                                    // Validate arguments
                                    if execution_id.is_none() && !active && pane.is_none() {
                                        let response = RobotResponse::<
                                            RobotWorkflowStatusData,
                                        >::error_with_code(
                                            "E_MISSING_ARGUMENT",
                                            "Must provide execution_id, --pane, or --active"
                                                .to_string(),
                                            Some(
                                                "Specify an execution ID, or use --pane <id> to list workflows for a pane, or --active to list all active workflows."
                                                    .to_string(),
                                            ),
                                            elapsed_ms(start),
                                        );
                                        print_robot_response(&response, format, stats)?;
                                        return Ok(());
                                    }

                                    if execution_id.is_none() {
                                        if let Some(pane_id) = pane {
                                            match storage.get_pane(pane_id).await {
                                                Ok(Some(_)) => {}
                                                Ok(None) => {
                                                    let response = RobotResponse::<
                                                        RobotWorkflowStatusListData,
                                                    >::error_with_code(
                                                        "E_PANE_NOT_FOUND",
                                                        format!(
                                                            "No pane found with ID: {pane_id}"
                                                        ),
                                                        Some(
                                                            "Check the pane ID or run 'wa robot state' to list panes."
                                                                .to_string(),
                                                        ),
                                                        elapsed_ms(start),
                                                    );
                                                    print_robot_response(&response, format, stats)?;
                                                    return Ok(());
                                                }
                                                Err(e) => {
                                                    let response = RobotResponse::<
                                                        RobotWorkflowStatusListData,
                                                    >::error_with_code(
                                                        ROBOT_ERR_STORAGE,
                                                        format!(
                                                            "Failed to query pane metadata: {e}"
                                                        ),
                                                        None,
                                                        elapsed_ms(start),
                                                    );
                                                    print_robot_response(&response, format, stats)?;
                                                    return Ok(());
                                                }
                                            }
                                        }
                                    }

                                    // Query by execution_id if provided
                                    if let Some(exec_id) = &execution_id {
                                        match storage.get_workflow(exec_id).await {
                                            Ok(Some(record)) => {
                                                let (step_logs, latest_log) = if verbose > 0 {
                                                    match storage.get_step_logs(exec_id).await {
                                                        Ok(logs) => {
                                                            let latest = logs.last().cloned();
                                                            let mapped = logs
                                                                .into_iter()
                                                                .map(|log| RobotWorkflowStepLog {
                                                                    step_index: log.step_index,
                                                                    step_name: log.step_name,
                                                                    result_type: log.result_type,
                                                                    step_id: log.step_id,
                                                                    step_kind: log.step_kind,
                                                                    result_data: log
                                                                        .result_data
                                                                        .and_then(|s| {
                                                                            serde_json::from_str(&s)
                                                                                .ok()
                                                                        }),
                                                                    policy_summary: log
                                                                        .policy_summary
                                                                        .and_then(|s| {
                                                                            serde_json::from_str(&s)
                                                                                .ok()
                                                                        }),
                                                                    verification_refs: log
                                                                        .verification_refs
                                                                        .and_then(|s| {
                                                                            serde_json::from_str(&s)
                                                                                .ok()
                                                                        }),
                                                                    error_code: log.error_code,
                                                                    started_at: log.started_at,
                                                                    completed_at: Some(
                                                                        log.completed_at,
                                                                    ),
                                                                    duration_ms: Some(
                                                                        log.duration_ms,
                                                                    ),
                                                                })
                                                                .collect();
                                                            (Some(mapped), latest)
                                                        }
                                                        Err(_) => (None, None),
                                                    }
                                                } else {
                                                    let latest = storage
                                                        .get_latest_step_log(exec_id)
                                                        .await
                                                        .unwrap_or_default();
                                                    (None, latest)
                                                };

                                                let (action_plan, plan_step_name, total_steps) =
                                                    match storage.get_action_plan(exec_id).await {
                                                        Ok(Some(plan_record)) => {
                                                            let parsed_plan =
                                                                serde_json::from_str::<
                                                                    wa_core::plan::ActionPlan,
                                                                >(
                                                                    &plan_record.plan_json
                                                                )
                                                                .ok();
                                                            let step_name = parsed_plan
                                                                .as_ref()
                                                                .and_then(|plan| {
                                                                    plan.steps
                                                                        .get(record.current_step)
                                                                })
                                                                .map(|step| {
                                                                    step.description.clone()
                                                                });
                                                            let total_steps = parsed_plan
                                                                .as_ref()
                                                                .and_then(|plan| {
                                                                    let count = plan.steps.len();
                                                                    if count > 0 {
                                                                        Some(count)
                                                                    } else {
                                                                        None
                                                                    }
                                                                });

                                                            let action_plan = if verbose > 0 {
                                                                let plan_value = parsed_plan
                                                                    .as_ref()
                                                                    .and_then(|plan| {
                                                                        serde_json::to_value(plan)
                                                                            .ok()
                                                                    })
                                                                    .or_else(|| {
                                                                        serde_json::from_str(
                                                                            &plan_record.plan_json,
                                                                        )
                                                                        .ok()
                                                                    });
                                                                Some(RobotWorkflowActionPlan {
                                                                    plan_id: plan_record.plan_id,
                                                                    plan_hash: plan_record
                                                                        .plan_hash,
                                                                    plan: plan_value,
                                                                    created_at: Some(
                                                                        plan_record.created_at,
                                                                    ),
                                                                })
                                                            } else {
                                                                None
                                                            };

                                                            (action_plan, step_name, total_steps)
                                                        }
                                                        _ => (None, None, None),
                                                    };

                                                let step_name = plan_step_name.or_else(|| {
                                                    latest_log
                                                        .as_ref()
                                                        .map(|log| log.step_name.clone())
                                                });
                                                let last_step_result = latest_log
                                                    .as_ref()
                                                    .map(|log| log.result_type.clone());

                                                // Calculate elapsed_ms
                                                let now = std::time::SystemTime::now()
                                                    .duration_since(std::time::UNIX_EPOCH)
                                                    .unwrap_or_default()
                                                    .as_millis()
                                                    as i64;
                                                let elapsed = if record.completed_at.is_some() {
                                                    record
                                                        .completed_at
                                                        .map(|c| (c - record.started_at) as u64)
                                                } else {
                                                    Some((now - record.started_at) as u64)
                                                };

                                                let data = RobotWorkflowStatusData {
                                                    execution_id: record.id,
                                                    workflow_name: record.workflow_name,
                                                    pane_id: Some(record.pane_id),
                                                    trigger_event_id: record.trigger_event_id,
                                                    status: record.status,
                                                    step_name,
                                                    elapsed_ms: elapsed,
                                                    last_step_result,
                                                    current_step: Some(record.current_step),
                                                    total_steps,
                                                    wait_condition: record.wait_condition,
                                                    context: record.context,
                                                    result: record.result,
                                                    error: record.error,
                                                    started_at: Some(record.started_at as u64),
                                                    updated_at: Some(record.updated_at as u64),
                                                    completed_at: record
                                                        .completed_at
                                                        .map(|c| c as u64),
                                                    step_logs,
                                                    action_plan,
                                                };

                                                let response =
                                                    RobotResponse::success(data, elapsed_ms(start));
                                                print_robot_response(&response, format, stats)?;
                                            }
                                            Ok(None) => {
                                                let response = RobotResponse::<
                                                    RobotWorkflowStatusData,
                                                >::error_with_code(
                                                    "E_EXECUTION_NOT_FOUND",
                                                    format!(
                                                        "No workflow execution found with ID: {exec_id}"
                                                    ),
                                                    Some(
                                                        "Check the execution ID is correct. Use 'wa robot workflow status --active' to list running workflows."
                                                            .to_string(),
                                                    ),
                                                    elapsed_ms(start),
                                                );
                                                print_robot_response(&response, format, stats)?;
                                            }
                                            Err(e) => {
                                                let response = RobotResponse::<
                                                    RobotWorkflowStatusData,
                                                >::error_with_code(
                                                    ROBOT_ERR_STORAGE,
                                                    format!("Failed to query workflow: {e}"),
                                                    None,
                                                    elapsed_ms(start),
                                                );
                                                print_robot_response(&response, format, stats)?;
                                            }
                                        }
                                    } else {
                                        // Query active/by-pane workflows
                                        let records = if active {
                                            storage.find_incomplete_workflows().await
                                        } else if let Some(pane_id) = pane {
                                            let query = wa_core::storage::ExportQuery {
                                                pane_id: Some(pane_id),
                                                limit: Some(50),
                                                ..Default::default()
                                            };
                                            storage.export_workflows(query).await
                                        } else {
                                            storage.find_incomplete_workflows().await
                                        };

                                        match records {
                                            Ok(mut workflows) => {
                                                // Filter by pane if specified
                                                if let Some(pane_id) = pane {
                                                    workflows.retain(|w| w.pane_id == pane_id);
                                                }

                                                let executions: Vec<RobotWorkflowStatusData> =
                                                    workflows
                                                        .into_iter()
                                                        .map(|record| {
                                                            let now = std::time::SystemTime::now()
                                                                .duration_since(
                                                                    std::time::UNIX_EPOCH,
                                                                )
                                                                .unwrap_or_default()
                                                                .as_millis()
                                                                as i64;
                                                            let elapsed =
                                                                if record.completed_at.is_some() {
                                                                    record.completed_at.map(|c| {
                                                                        (c - record.started_at)
                                                                            as u64
                                                                    })
                                                                } else {
                                                                    Some(
                                                                        (now - record.started_at)
                                                                            as u64,
                                                                    )
                                                                };

                                                            RobotWorkflowStatusData {
                                                                execution_id: record.id,
                                                                workflow_name: record.workflow_name,
                                                                pane_id: Some(record.pane_id),
                                                                trigger_event_id: record
                                                                    .trigger_event_id,
                                                                status: record.status,
                                                                step_name: None,
                                                                elapsed_ms: elapsed,
                                                                last_step_result: None,
                                                                current_step: Some(
                                                                    record.current_step,
                                                                ),
                                                                total_steps: None,
                                                                wait_condition: record
                                                                    .wait_condition,
                                                                context: record.context,
                                                                result: record.result,
                                                                error: record.error,
                                                                started_at: Some(
                                                                    record.started_at as u64,
                                                                ),
                                                                updated_at: Some(
                                                                    record.updated_at as u64,
                                                                ),
                                                                completed_at: record
                                                                    .completed_at
                                                                    .map(|c| c as u64),
                                                                step_logs: None, // Not included in list mode
                                                                action_plan: None,
                                                            }
                                                        })
                                                        .collect();

                                                let count = executions.len();
                                                let data = RobotWorkflowStatusListData {
                                                    executions,
                                                    pane_filter: pane,
                                                    active_only: if active {
                                                        Some(true)
                                                    } else {
                                                        None
                                                    },
                                                    count,
                                                };

                                                let response =
                                                    RobotResponse::success(data, elapsed_ms(start));
                                                print_robot_response(&response, format, stats)?;
                                            }
                                            Err(e) => {
                                                let response = RobotResponse::<
                                                    RobotWorkflowStatusListData,
                                                >::error_with_code(
                                                    ROBOT_ERR_STORAGE,
                                                    format!("Failed to query workflows: {e}"),
                                                    None,
                                                    elapsed_ms(start),
                                                );
                                                print_robot_response(&response, format, stats)?;
                                            }
                                        }
                                    }

                                    // Clean shutdown of storage
                                    if let Err(e) = storage.shutdown().await {
                                        tracing::warn!("Failed to shutdown storage cleanly: {e}");
                                    }
                                }
                                RobotWorkflowCommands::Abort {
                                    execution_id,
                                    reason,
                                    force,
                                } => {
                                    use wa_core::policy::{PolicyEngine, PolicyGatedInjector};
                                    use wa_core::storage::StorageHandle;
                                    use wa_core::workflows::{
                                        PaneWorkflowLockManager, WorkflowEngine, WorkflowRunner,
                                        WorkflowRunnerConfig,
                                    };

                                    // Set up storage
                                    let db_path = &ctx.effective.paths.db_path;
                                    let storage = match StorageHandle::new(db_path).await {
                                        Ok(s) => Arc::new(s),
                                        Err(e) => {
                                            let response =
                                                RobotResponse::<RobotWorkflowAbortData>::error_with_code(
                                                    ROBOT_ERR_STORAGE,
                                                    format!("Failed to open storage: {e}"),
                                                    Some(
                                                        "Check database path and permissions."
                                                            .to_string(),
                                                    ),
                                                    elapsed_ms(start),
                                                );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }
                                    };

                                    // Set up minimal workflow infrastructure for abort
                                    let engine = WorkflowEngine::new(10);
                                    let lock_manager = Arc::new(PaneWorkflowLockManager::new());
                                    let policy_engine = PolicyEngine::new(
                                        config.safety.rate_limit_per_pane,
                                        config.safety.rate_limit_global,
                                        false,
                                    );
                                    let wezterm_handle = wa_core::wezterm::default_wezterm_handle();
                                    let injector = Arc::new(tokio::sync::Mutex::new(
                                        PolicyGatedInjector::with_storage(
                                            policy_engine,
                                            wezterm_handle,
                                            storage.as_ref().clone(),
                                        ),
                                    ));
                                    let runner_config = WorkflowRunnerConfig::default();
                                    let runner = WorkflowRunner::new(
                                        engine,
                                        lock_manager,
                                        Arc::clone(&storage),
                                        injector,
                                        runner_config,
                                    );

                                    // Execute the abort
                                    match runner
                                        .abort_execution(&execution_id, reason.as_deref(), force)
                                        .await
                                    {
                                        Ok(result) => {
                                            let data = RobotWorkflowAbortData {
                                                execution_id: result.execution_id,
                                                aborted: result.aborted,
                                                forced: force,
                                                workflow_name: Some(result.workflow_name),
                                                previous_status: Some(result.previous_status),
                                                reason: result.reason,
                                                aborted_at: result.aborted_at,
                                                error_reason: result.error_reason,
                                            };
                                            let response =
                                                RobotResponse::success(data, elapsed_ms(start));
                                            print_robot_response(&response, format, stats)?;
                                        }
                                        Err(e) => {
                                            let (code, hint) = match &e {
                                                wa_core::Error::Workflow(
                                                    wa_core::error::WorkflowError::NotFound(_),
                                                ) => (
                                                    "E_EXECUTION_NOT_FOUND",
                                                    Some(
                                                        "Check the execution ID is correct. Use \
                                                         'wa robot workflow status --active' to \
                                                         list running workflows."
                                                            .to_string(),
                                                    ),
                                                ),
                                                _ => (ROBOT_ERR_STORAGE, None),
                                            };
                                            let response =
                                                RobotResponse::<RobotWorkflowAbortData>::error_with_code(
                                                    code,
                                                    format!("Failed to abort workflow: {e}"),
                                                    hint,
                                                    elapsed_ms(start),
                                                );
                                            print_robot_response(&response, format, stats)?;
                                        }
                                    }

                                    // Clean shutdown of storage
                                    if let Err(e) = storage.shutdown().await {
                                        tracing::warn!("Failed to shutdown storage cleanly: {e}");
                                    }
                                }
                            }
                        }
                        RobotCommands::Rules { command } => {
                            use wa_core::patterns::{AgentType, PatternEngine};

                            let patterns_root =
                                resolved_config_path.as_deref().and_then(|p| p.parent());
                            let engine = match PatternEngine::from_config_with_root(
                                &config.patterns,
                                patterns_root,
                            ) {
                                Ok(engine) => engine,
                                Err(err) => {
                                    let response = RobotResponse::<()>::error_with_code(
                                        ROBOT_ERR_CONFIG,
                                        format!("Failed to load pattern packs: {err}"),
                                        Some("Check [patterns] in wa.toml.".to_string()),
                                        elapsed_ms(start),
                                    );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            match command {
                                RobotRulesCommands::List {
                                    pack,
                                    agent_type,
                                    verbose,
                                } => {
                                    // Parse agent type filter if provided
                                    let agent_filter: Option<AgentType> =
                                        agent_type.as_ref().and_then(|s| match s.as_str() {
                                            "codex" => Some(AgentType::Codex),
                                            "claude_code" => Some(AgentType::ClaudeCode),
                                            "gemini" => Some(AgentType::Gemini),
                                            "wezterm" => Some(AgentType::Wezterm),
                                            _ => None,
                                        });

                                    let rules: Vec<RobotRuleItem> = engine
                                        .rules()
                                        .iter()
                                        .filter(|rule| {
                                            if let Some(ref pack_filter) = pack {
                                                let rule_pack =
                                                    engine.pack_for_rule(&rule.id).unwrap_or("");
                                                if rule_pack != pack_filter.as_str() {
                                                    return false;
                                                }
                                            }
                                            if let Some(ref agent) = agent_filter {
                                                if rule.agent_type != *agent {
                                                    return false;
                                                }
                                            }
                                            true
                                        })
                                        .map(|rule| RobotRuleItem {
                                            id: rule.id.clone(),
                                            agent_type: format!("{}", rule.agent_type),
                                            event_type: rule.event_type.clone(),
                                            severity: format!("{:?}", rule.severity).to_lowercase(),
                                            description: if verbose > 0 {
                                                Some(rule.description.clone())
                                            } else {
                                                None
                                            },
                                            workflow: rule.workflow.clone(),
                                            anchor_count: rule.anchors.len(),
                                            has_regex: rule.regex.is_some(),
                                        })
                                        .collect();

                                    let data = RobotRulesListData {
                                        rules,
                                        pack_filter: pack,
                                        agent_type_filter: agent_type,
                                    };
                                    let response = RobotResponse::success(data, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;
                                }
                                RobotRulesCommands::Test { text, trace, pack } => {
                                    // Run detection on the provided text
                                    let detections = engine.detect(&text);

                                    let matches: Vec<RobotRuleMatchItem> = detections
                                        .iter()
                                        .filter(|d| {
                                            if let Some(ref pack_filter) = pack {
                                                let rule_pack =
                                                    engine.pack_for_rule(&d.rule_id).unwrap_or("");
                                                rule_pack == pack_filter.as_str()
                                            } else {
                                                true
                                            }
                                        })
                                        .map(|d| RobotRuleMatchItem {
                                            rule_id: d.rule_id.clone(),
                                            agent_type: format!("{}", d.agent_type),
                                            event_type: d.event_type.clone(),
                                            severity: format!("{:?}", d.severity).to_lowercase(),
                                            confidence: d.confidence,
                                            matched_text: d.matched_text.clone(),
                                            extracted: if d.extracted.is_null()
                                                || d.extracted
                                                    .as_object()
                                                    .is_some_and(serde_json::Map::is_empty)
                                            {
                                                None
                                            } else {
                                                Some(d.extracted.clone())
                                            },
                                            trace: if trace {
                                                // Trace output would include match evidence
                                                // For now, provide basic info
                                                Some(RobotRuleTraceInfo {
                                                    anchors_checked: true,
                                                    regex_matched: !d.matched_text.is_empty(),
                                                })
                                            } else {
                                                None
                                            },
                                        })
                                        .collect();

                                    let data = RobotRulesTestData {
                                        text_length: text.len(),
                                        match_count: matches.len(),
                                        matches,
                                    };
                                    let response = RobotResponse::success(data, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;
                                }
                                RobotRulesCommands::Show { rule_id } => {
                                    // Find the specific rule
                                    if let Some(rule) =
                                        engine.rules().iter().find(|r| r.id == rule_id)
                                    {
                                        let data = RobotRuleDetailData {
                                            id: rule.id.clone(),
                                            agent_type: format!("{}", rule.agent_type),
                                            event_type: rule.event_type.clone(),
                                            severity: format!("{:?}", rule.severity).to_lowercase(),
                                            description: rule.description.clone(),
                                            anchors: rule.anchors.clone(),
                                            regex: rule.regex.clone(),
                                            workflow: rule.workflow.clone(),
                                            remediation: rule.remediation.clone(),
                                            manual_fix: rule.manual_fix.clone(),
                                            learn_more_url: rule.learn_more_url.clone(),
                                        };
                                        let response =
                                            RobotResponse::success(data, elapsed_ms(start));
                                        print_robot_response(&response, format, stats)?;
                                    } else {
                                        let response =
                                            RobotResponse::<RobotRuleDetailData>::error_with_code(
                                                "robot.rule_not_found",
                                                format!("Rule '{}' not found", rule_id),
                                                Some("Use 'wa robot rules list' to see available rules".to_string()),
                                                elapsed_ms(start),
                                            );
                                        print_robot_response(&response, format, stats)?;
                                    }
                                }
                                RobotRulesCommands::Lint {
                                    pack,
                                    fixtures,
                                    skip_regex_check,
                                    strict,
                                } => {
                                    let all_rules = engine.rules();
                                    let rules: Vec<&wa_core::patterns::RuleDef> = all_rules
                                        .iter()
                                        .filter(|r| {
                                            if let Some(ref pack_filter) = pack {
                                                let rule_pack =
                                                    engine.pack_for_rule(&r.id).unwrap_or("");
                                                rule_pack == pack_filter.as_str()
                                            } else {
                                                true
                                            }
                                        })
                                        .collect();
                                    let mut errors: Vec<RobotLintIssue> = Vec::new();
                                    let mut warnings: Vec<RobotLintIssue> = Vec::new();

                                    // 1. Validate rule ID naming conventions
                                    for rule in &rules {
                                        let has_valid_prefix =
                                            RULE_ID_PREFIXES.iter().any(|p| rule.id.starts_with(p));
                                        if !has_valid_prefix {
                                            errors.push(RobotLintIssue {
                                                rule_id: rule.id.clone(),
                                                category: "naming".to_string(),
                                                message: format!(
                                                    "Rule ID must start with one of: {}",
                                                    RULE_ID_PREFIXES.join(", ")
                                                ),
                                                suggestion: Some(format!(
                                                    "Rename to '{}.{}'",
                                                    rule.agent_type,
                                                    rule.id
                                                        .split('.')
                                                        .skip(1)
                                                        .collect::<Vec<_>>()
                                                        .join(".")
                                                )),
                                            });
                                        }

                                        // Check ID matches agent_type
                                        let expected_prefix = format!("{}.", rule.agent_type);
                                        if !rule.id.starts_with(&expected_prefix) {
                                            errors.push(RobotLintIssue {
                                                rule_id: rule.id.clone(),
                                                category: "naming".to_string(),
                                                message: format!(
                                                    "Rule ID prefix '{}' does not match agent_type '{}'",
                                                    rule.id.split('.').next().unwrap_or(""),
                                                    rule.agent_type
                                                ),
                                                suggestion: Some(format!(
                                                    "Use '{}{}'",
                                                    expected_prefix,
                                                    rule.id.split('.').skip(1).collect::<Vec<_>>().join(".")
                                                )),
                                            });
                                        }

                                        // 2. Validate regex patterns (if not skipped)
                                        if !skip_regex_check {
                                            if let Some(ref regex_str) = rule.regex {
                                                // Check for dangerous patterns
                                                if regex_str.contains(".*.*.*") {
                                                    warnings.push(RobotLintIssue {
                                                        rule_id: rule.id.clone(),
                                                        category: "regex".to_string(),
                                                        message: "Regex contains nested wildcards (potential ReDoS)".to_string(),
                                                        suggestion: Some("Consider using non-greedy quantifiers or simplifying pattern".to_string()),
                                                    });
                                                }
                                                // Check for excessive length
                                                if regex_str.len() > 500 {
                                                    warnings.push(RobotLintIssue {
                                                        rule_id: rule.id.clone(),
                                                        category: "regex".to_string(),
                                                        message: format!("Regex is {} chars (consider splitting)", regex_str.len()),
                                                        suggestion: Some("Break into multiple rules or simplify the pattern".to_string()),
                                                    });
                                                }
                                                // Check for unescaped special chars that might be mistakes
                                                if regex_str.contains("  ") {
                                                    warnings.push(RobotLintIssue {
                                                        rule_id: rule.id.clone(),
                                                        category: "regex".to_string(),
                                                        message: "Regex contains consecutive spaces (intentional?)".to_string(),
                                                        suggestion: Some("Use \\s+ for flexible whitespace matching".to_string()),
                                                    });
                                                }
                                            }
                                        }
                                    }

                                    // 3. Check fixture coverage if requested
                                    let fixture_coverage = if fixtures {
                                        let corpus_base =
                                            std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                                                .parent()
                                                .unwrap_or_else(|| std::path::Path::new("."))
                                                .join("wa-core")
                                                .join("tests")
                                                .join("corpus");

                                        let mut rules_with_fixtures: HashSet<String> =
                                            HashSet::new();
                                        let mut total_fixtures = 0;

                                        collect_fixture_rule_ids(
                                            &corpus_base,
                                            &mut rules_with_fixtures,
                                            &mut total_fixtures,
                                        );

                                        // Find rules without any fixture coverage
                                        let rules_without: Vec<String> = rules
                                            .iter()
                                            .filter(|r| !rules_with_fixtures.contains(&r.id))
                                            .map(|r| r.id.clone())
                                            .collect();

                                        // Add warnings for rules without fixtures
                                        for rule_id in &rules_without {
                                            warnings.push(RobotLintIssue {
                                                rule_id: rule_id.clone(),
                                                category: "fixture".to_string(),
                                                message: "No corpus fixture found for this rule".to_string(),
                                                suggestion: Some(format!(
                                                    "Add tests/corpus/<agent>/{}.txt and .expect.json",
                                                    rule_id.split('.').next_back().unwrap_or("unknown")
                                                )),
                                            });
                                        }

                                        Some(RobotFixtureCoverage {
                                            rules_with_fixtures: rules_with_fixtures.len(),
                                            rules_without_fixtures: rules_without,
                                            total_fixtures,
                                        })
                                    } else {
                                        None
                                    };

                                    let passed =
                                        errors.is_empty() && (!strict || warnings.is_empty());

                                    let data = RobotRulesLintData {
                                        total_rules: rules.len(),
                                        rules_checked: rules.len(),
                                        errors,
                                        warnings,
                                        fixture_coverage,
                                        passed,
                                    };

                                    let response = RobotResponse::success(data, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;

                                    // Exit non-zero if not passed
                                    if !passed {
                                        std::process::exit(1);
                                    }
                                }
                            }
                        }
                        RobotCommands::Why { code } => {
                            // Explain an error code using built-in templates
                            use wa_core::explanations::{get_explanation, list_template_ids};

                            if let Some(tmpl) = get_explanation(&code) {
                                // Extract category from code (e.g., "deny.alt_screen" -> "deny")
                                let category =
                                    code.split('.').next().unwrap_or("unknown").to_string();

                                let data = RobotWhyData {
                                    code: code.clone(),
                                    category,
                                    title: tmpl.scenario.to_string(),
                                    explanation: tmpl.detailed.to_string(),
                                    suggestions: if tmpl.suggestions.is_empty() {
                                        None
                                    } else {
                                        Some(
                                            tmpl.suggestions
                                                .iter()
                                                .map(|s| (*s).to_string())
                                                .collect(),
                                        )
                                    },
                                    see_also: if tmpl.see_also.is_empty() {
                                        None
                                    } else {
                                        Some(
                                            tmpl.see_also
                                                .iter()
                                                .map(|s| (*s).to_string())
                                                .collect(),
                                        )
                                    },
                                };
                                let response = RobotResponse::success(data, elapsed_ms(start));
                                print_robot_response(&response, format, stats)?;
                            } else {
                                // Code not found - list available codes as hint
                                let available = list_template_ids();
                                let hint = if available.is_empty() {
                                    "No explanation templates available.".to_string()
                                } else {
                                    format!(
                                        "Available codes: {}",
                                        available[..available.len().min(10)].join(", ")
                                    )
                                };
                                let response = RobotResponse::<RobotWhyData>::error_with_code(
                                    "robot.code_not_found",
                                    format!("Unknown error code: {code}"),
                                    Some(hint),
                                    elapsed_ms(start),
                                );
                                print_robot_response(&response, format, stats)?;
                            }
                        }
                        RobotCommands::Approve {
                            code,
                            pane,
                            fingerprint,
                            dry_run,
                        } => {
                            // Get workspace layout for db path and workspace_id
                            let layout = match config.workspace_layout(Some(&workspace_root)) {
                                Ok(l) => l,
                                Err(e) => {
                                    let response =
                                        RobotResponse::<RobotApproveData>::error_with_code(
                                            ROBOT_ERR_CONFIG,
                                            format!("Failed to get workspace layout: {e}"),
                                            Some("Check --workspace or WA_WORKSPACE".to_string()),
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            // Open storage handle
                            let db_path = layout.db_path.to_string_lossy();
                            let storage = match wa_core::storage::StorageHandle::new(&db_path).await
                            {
                                Ok(s) => s,
                                Err(e) => {
                                    let response =
                                        RobotResponse::<RobotApproveData>::error_with_code(
                                            ROBOT_ERR_STORAGE,
                                            format!("Failed to open storage: {e}"),
                                            Some(
                                                "Is the database initialized? Run 'wa watch' first."
                                                    .to_string(),
                                            ),
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            // Get workspace ID for scoping
                            let workspace_id = layout.root.to_string_lossy().to_string();

                            match evaluate_robot_approve(
                                &storage,
                                &workspace_id,
                                &code,
                                pane,
                                fingerprint.as_deref(),
                                dry_run,
                            )
                            .await
                            {
                                Ok(data) => {
                                    let response = RobotResponse::success(data, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;
                                }
                                Err(err) => {
                                    let response =
                                        RobotResponse::<RobotApproveData>::error_with_code(
                                            err.code,
                                            err.message,
                                            err.hint,
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                }
                            }
                        }
                        RobotCommands::Accounts { command } => {
                            // Get workspace layout for db path
                            let layout = match config.workspace_layout(Some(&workspace_root)) {
                                Ok(l) => l,
                                Err(e) => {
                                    let response =
                                        RobotResponse::<RobotAccountsListData>::error_with_code(
                                            ROBOT_ERR_CONFIG,
                                            format!("Failed to get workspace layout: {e}"),
                                            Some("Check --workspace or WA_WORKSPACE".to_string()),
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            match command {
                                RobotAccountsCommands::List { service, pick } => {
                                    // Open storage handle
                                    let db_path = layout.db_path.to_string_lossy();
                                    let storage = match wa_core::storage::StorageHandle::new(
                                        &db_path,
                                    )
                                    .await
                                    {
                                        Ok(s) => s,
                                        Err(e) => {
                                            let response =
                                                    RobotResponse::<RobotAccountsListData>::error_with_code(
                                                        ROBOT_ERR_STORAGE,
                                                        format!("Failed to open storage: {e}"),
                                                        Some(
                                                            "Is the database initialized? Run 'wa watch' first."
                                                                .to_string(),
                                                        ),
                                                        elapsed_ms(start),
                                                    );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }
                                    };

                                    // Fetch accounts
                                    let accounts = match storage
                                        .get_accounts_by_service(&service)
                                        .await
                                    {
                                        Ok(a) => a,
                                        Err(e) => {
                                            let response =
                                                RobotResponse::<RobotAccountsListData>::error_with_code(
                                                    ROBOT_ERR_STORAGE,
                                                    format!("Failed to fetch accounts: {e}"),
                                                    None,
                                                    elapsed_ms(start),
                                                );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }
                                    };

                                    // Build pick preview if requested
                                    let pick_preview = if pick {
                                        let sel_config =
                                            wa_core::accounts::AccountSelectionConfig::default();
                                        let result = wa_core::accounts::select_account(
                                            &accounts,
                                            &sel_config,
                                        );
                                        Some(RobotAccountPickPreview {
                                            selected_account_id: result
                                                .selected
                                                .as_ref()
                                                .map(|a| a.account_id.clone()),
                                            selected_name: result
                                                .selected
                                                .as_ref()
                                                .and_then(|a| a.name.clone()),
                                            selection_reason: result.explanation.selection_reason,
                                            threshold_percent: sel_config.threshold_percent,
                                            candidates_count: result.explanation.candidates.len(),
                                            filtered_count: result.explanation.filtered_out.len(),
                                        })
                                    } else {
                                        None
                                    };

                                    let total = accounts.len();
                                    let account_infos: Vec<RobotAccountInfo> = accounts
                                        .into_iter()
                                        .map(|a| RobotAccountInfo {
                                            account_id: a.account_id,
                                            service: a.service,
                                            name: a.name,
                                            percent_remaining: a.percent_remaining,
                                            reset_at: a.reset_at,
                                            tokens_used: a.tokens_used,
                                            tokens_remaining: a.tokens_remaining,
                                            tokens_limit: a.tokens_limit,
                                            last_refreshed_at: a.last_refreshed_at,
                                            last_used_at: a.last_used_at,
                                        })
                                        .collect();

                                    let data = RobotAccountsListData {
                                        accounts: account_infos,
                                        total,
                                        service,
                                        pick_preview,
                                    };
                                    let response = RobotResponse::success(data, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;

                                    // Clean shutdown
                                    if let Err(e) = storage.shutdown().await {
                                        tracing::warn!("Failed to shutdown storage cleanly: {e}");
                                    }
                                }
                                RobotAccountsCommands::Refresh { service } => {
                                    // Parse CautService
                                    let caut_service = match service.as_str() {
                                        "openai" => wa_core::caut::CautService::OpenAI,
                                        other => {
                                            let response =
                                                RobotResponse::<RobotAccountsRefreshData>::error_with_code(
                                                    "robot.invalid_service",
                                                    format!("Unknown service: {other}"),
                                                    Some(
                                                        "Supported services: openai".to_string(),
                                                    ),
                                                    elapsed_ms(start),
                                                );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }
                                    };

                                    // Rate-limit: check last refresh time in DB
                                    let db_path = layout.db_path.to_string_lossy();
                                    {
                                        if let Ok(storage_check) =
                                            wa_core::storage::StorageHandle::new(&db_path).await
                                        {
                                            if let Ok(accounts) = storage_check
                                                .get_accounts_by_service(&service)
                                                .await
                                            {
                                                let now_check = std::time::SystemTime::now()
                                                    .duration_since(std::time::UNIX_EPOCH)
                                                    .unwrap_or_default()
                                                    .as_millis()
                                                    as i64;
                                                let most_recent = accounts
                                                    .iter()
                                                    .map(|a| a.last_refreshed_at)
                                                    .max()
                                                    .unwrap_or(0);
                                                if let Some((secs_ago, wait_secs)) =
                                                    check_refresh_cooldown(
                                                        most_recent,
                                                        now_check,
                                                        ROBOT_REFRESH_COOLDOWN_MS,
                                                    )
                                                {
                                                    let response = RobotResponse::<
                                                        RobotAccountsRefreshData,
                                                    >::error_with_code(
                                                        "robot.rate_limited",
                                                        format!(
                                                            "Refresh rate limited: last refresh was {secs_ago}s ago (cooldown: {}s)",
                                                            ROBOT_REFRESH_COOLDOWN_MS / 1000
                                                        ),
                                                        Some(format!(
                                                            "Wait {wait_secs}s before refreshing again, or use 'wa robot accounts list' to see cached data."
                                                        )),
                                                        elapsed_ms(start),
                                                    );
                                                    print_robot_response(&response, format, stats)?;
                                                    let _ = storage_check.shutdown().await;
                                                    return Ok(());
                                                }
                                            }
                                            let _ = storage_check.shutdown().await;
                                        }
                                    }

                                    // Call caut refresh
                                    let caut = wa_core::caut::CautClient::new();
                                    let refresh_result = match caut.refresh(caut_service).await {
                                        Ok(r) => r,
                                        Err(e) => {
                                            let response =
                                                RobotResponse::<RobotAccountsRefreshData>::error_with_code(
                                                    "robot.caut_error",
                                                    format!("caut refresh failed: {e}"),
                                                    Some(
                                                        e.remediation().summary.to_string(),
                                                    ),
                                                    elapsed_ms(start),
                                                );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }
                                    };

                                    // Open storage to persist refreshed data
                                    let db_path = layout.db_path.to_string_lossy();
                                    let storage = match wa_core::storage::StorageHandle::new(
                                        &db_path,
                                    )
                                    .await
                                    {
                                        Ok(s) => s,
                                        Err(e) => {
                                            let response =
                                                    RobotResponse::<RobotAccountsRefreshData>::error_with_code(
                                                        ROBOT_ERR_STORAGE,
                                                        format!("Failed to open storage: {e}"),
                                                        Some(
                                                            "Is the database initialized? Run 'wa watch' first."
                                                                .to_string(),
                                                        ),
                                                        elapsed_ms(start),
                                                    );
                                            print_robot_response(&response, format, stats)?;
                                            return Ok(());
                                        }
                                    };

                                    // Convert and upsert each account
                                    let now_ms = std::time::SystemTime::now()
                                        .duration_since(std::time::UNIX_EPOCH)
                                        .unwrap_or_default()
                                        .as_millis()
                                        as i64;

                                    let mut account_infos = Vec::new();
                                    for usage in &refresh_result.accounts {
                                        let record = wa_core::accounts::AccountRecord::from_caut(
                                            usage,
                                            caut_service,
                                            now_ms,
                                        );
                                        if let Err(e) = storage.upsert_account(record.clone()).await
                                        {
                                            tracing::warn!(
                                                "Failed to upsert account {}: {e}",
                                                record.account_id
                                            );
                                        }
                                        account_infos.push(RobotAccountInfo {
                                            account_id: record.account_id,
                                            service: record.service,
                                            name: record.name,
                                            percent_remaining: record.percent_remaining,
                                            reset_at: record.reset_at,
                                            tokens_used: record.tokens_used,
                                            tokens_remaining: record.tokens_remaining,
                                            tokens_limit: record.tokens_limit,
                                            last_refreshed_at: record.last_refreshed_at,
                                            last_used_at: record.last_used_at,
                                        });
                                    }

                                    let data = RobotAccountsRefreshData {
                                        service,
                                        refreshed_count: account_infos.len(),
                                        refreshed_at: refresh_result.refreshed_at,
                                        accounts: account_infos,
                                    };
                                    let response = RobotResponse::success(data, elapsed_ms(start));
                                    print_robot_response(&response, format, stats)?;

                                    // Clean shutdown
                                    if let Err(e) = storage.shutdown().await {
                                        tracing::warn!("Failed to shutdown storage cleanly: {e}");
                                    }
                                }
                            }
                        }
                        RobotCommands::Reservations { command } => {
                            // Get workspace layout for db path
                            let layout = match config.workspace_layout(Some(&workspace_root)) {
                                Ok(l) => l,
                                Err(e) => {
                                    let response =
                                        RobotResponse::<RobotReservationsListData>::error_with_code(
                                            ROBOT_ERR_CONFIG,
                                            format!("Failed to get workspace layout: {e}"),
                                            Some("Check --workspace or WA_WORKSPACE".to_string()),
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            let db_path = layout.db_path.to_string_lossy();
                            let storage = match wa_core::storage::StorageHandle::new(&db_path).await
                            {
                                Ok(s) => s,
                                Err(e) => {
                                    let response =
                                            RobotResponse::<RobotReservationsListData>::error_with_code(
                                                ROBOT_ERR_STORAGE,
                                                format!("Failed to open storage: {e}"),
                                                Some(
                                                    "Is the database initialized? Run 'wa watch' first."
                                                        .to_string(),
                                                ),
                                                elapsed_ms(start),
                                            );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            match command {
                                RobotReservationCommands::Reserve {
                                    pane_id,
                                    ttl,
                                    owner_kind,
                                    owner_id,
                                    reason,
                                } => {
                                    let ttl_ms = (ttl * 1000) as i64;
                                    match storage
                                        .create_reservation(
                                            pane_id,
                                            &owner_kind,
                                            &owner_id,
                                            reason.as_deref(),
                                            ttl_ms,
                                        )
                                        .await
                                    {
                                        Ok(r) => {
                                            let data = RobotReserveData {
                                                reservation: RobotReservationInfo {
                                                    id: r.id,
                                                    pane_id: r.pane_id,
                                                    owner_kind: r.owner_kind,
                                                    owner_id: r.owner_id,
                                                    reason: r.reason,
                                                    created_at: r.created_at,
                                                    expires_at: r.expires_at,
                                                    released_at: r.released_at,
                                                    status: r.status,
                                                },
                                            };
                                            let response =
                                                RobotResponse::success(data, elapsed_ms(start));
                                            print_robot_response(&response, format, stats)?;
                                        }
                                        Err(e) => {
                                            let response =
                                                RobotResponse::<RobotReserveData>::error_with_code(
                                                    "robot.reservation_conflict",
                                                    format!(
                                                        "Failed to create reservation: {e}"
                                                    ),
                                                    Some(
                                                        "Pane may already be reserved. Use 'wa robot reservations list' to check."
                                                            .to_string(),
                                                    ),
                                                    elapsed_ms(start),
                                                );
                                            print_robot_response(&response, format, stats)?;
                                        }
                                    }
                                }
                                RobotReservationCommands::Release { reservation_id } => {
                                    match storage.release_reservation(reservation_id).await {
                                        Ok(released) => {
                                            let data = RobotReleaseData {
                                                reservation_id,
                                                released,
                                            };
                                            let response =
                                                RobotResponse::success(data, elapsed_ms(start));
                                            print_robot_response(&response, format, stats)?;
                                        }
                                        Err(e) => {
                                            let response =
                                                RobotResponse::<RobotReleaseData>::error_with_code(
                                                    ROBOT_ERR_STORAGE,
                                                    format!("Failed to release reservation: {e}"),
                                                    None,
                                                    elapsed_ms(start),
                                                );
                                            print_robot_response(&response, format, stats)?;
                                        }
                                    }
                                }
                                RobotReservationCommands::List => {
                                    // Expire stale reservations first
                                    if let Err(e) = storage.expire_stale_reservations().await {
                                        tracing::warn!("Failed to expire stale reservations: {e}");
                                    }

                                    match storage.list_active_reservations().await {
                                        Ok(reservations) => {
                                            let total = reservations.len();
                                            let infos: Vec<RobotReservationInfo> = reservations
                                                .into_iter()
                                                .map(|r| RobotReservationInfo {
                                                    id: r.id,
                                                    pane_id: r.pane_id,
                                                    owner_kind: r.owner_kind,
                                                    owner_id: r.owner_id,
                                                    reason: r.reason,
                                                    created_at: r.created_at,
                                                    expires_at: r.expires_at,
                                                    released_at: r.released_at,
                                                    status: r.status,
                                                })
                                                .collect();
                                            let data = RobotReservationsListData {
                                                reservations: infos,
                                                total,
                                            };
                                            let response =
                                                RobotResponse::success(data, elapsed_ms(start));
                                            print_robot_response(&response, format, stats)?;
                                        }
                                        Err(e) => {
                                            let response =
                                                RobotResponse::<RobotReservationsListData>::error_with_code(
                                                    ROBOT_ERR_STORAGE,
                                                    format!(
                                                        "Failed to list reservations: {e}"
                                                    ),
                                                    None,
                                                    elapsed_ms(start),
                                                );
                                            print_robot_response(&response, format, stats)?;
                                        }
                                    }
                                }
                            }

                            // Clean shutdown
                            if let Err(e) = storage.shutdown().await {
                                tracing::warn!("Failed to shutdown storage cleanly: {e}");
                            }
                        }
                        RobotCommands::Health => {
                            let layout = match config.workspace_layout(Some(&workspace_root)) {
                                Ok(l) => l,
                                Err(e) => {
                                    let response =
                                        RobotResponse::<serde_json::Value>::error_with_code(
                                            ROBOT_ERR_CONFIG,
                                            format!("Failed to get workspace layout: {e}"),
                                            Some("Check --workspace or WA_WORKSPACE".to_string()),
                                            elapsed_ms(start),
                                        );
                                    print_robot_response(&response, format, stats)?;
                                    return Ok(());
                                }
                            };

                            // Try IPC first (watcher is running)
                            let mut payload = serde_json::json!({
                                "version": wa_core::VERSION,
                            });

                            #[cfg(unix)]
                            {
                                let client = wa_core::ipc::IpcClient::new(&layout.ipc_socket_path);
                                match client.status().await {
                                    Ok(response) if response.ok => {
                                        payload["watcher_running"] = serde_json::json!(true);
                                        if let Some(ref data) = response.data {
                                            if let Some(health) = data.get("health") {
                                                payload["health"] = health.clone();
                                                // Add stuck pane diagnostics
                                                if let Ok(snapshot) = serde_json::from_value::<
                                                    wa_core::crash::HealthSnapshot,
                                                >(
                                                    health.clone()
                                                ) {
                                                    let diags = wa_core::output::HealthSnapshotRenderer::diagnostic_checks(&snapshot);
                                                    let diag_json: Vec<serde_json::Value> = diags
                                                        .iter()
                                                        .map(|d| {
                                                            serde_json::json!({
                                                                "name": d.name,
                                                                "status": format!("{:?}", d.status),
                                                                "detail": d.detail,
                                                            })
                                                        })
                                                        .collect();
                                                    payload["diagnostics"] =
                                                        serde_json::json!(diag_json);
                                                }
                                            }
                                            if let Some(uptime) = data.get("uptime_ms") {
                                                payload["uptime_ms"] = uptime.clone();
                                            }
                                        }
                                    }
                                    Ok(_) => {
                                        payload["watcher_running"] = serde_json::json!(false);
                                        payload["watcher_error"] =
                                            serde_json::json!("watcher returned error");
                                    }
                                    Err(e) => {
                                        payload["watcher_running"] = serde_json::json!(false);
                                        payload["watcher_error"] = serde_json::json!(e.to_string());
                                    }
                                }
                            }

                            #[cfg(not(unix))]
                            {
                                let _ = &layout;
                                payload["watcher_running"] = serde_json::json!(false);
                                payload["watcher_error"] =
                                    serde_json::json!("IPC not available on this platform");
                            }

                            // Fallback: try global snapshot
                            if payload.get("health").is_none() {
                                if let Some(snapshot) = wa_core::crash::HealthSnapshot::get_global()
                                {
                                    payload["health"] = serde_json::to_value(&snapshot)
                                        .unwrap_or(serde_json::Value::Null);
                                    let diags =
                                        wa_core::output::HealthSnapshotRenderer::diagnostic_checks(
                                            &snapshot,
                                        );
                                    let diag_json: Vec<serde_json::Value> = diags
                                        .iter()
                                        .map(|d| {
                                            serde_json::json!({
                                                "name": d.name,
                                                "status": format!("{:?}", d.status),
                                                "detail": d.detail,
                                            })
                                        })
                                        .collect();
                                    payload["diagnostics"] = serde_json::json!(diag_json);
                                }
                            }

                            // Latest crash bundle
                            if let Some(crash) =
                                wa_core::crash::latest_crash_bundle(&layout.crash_dir)
                            {
                                let mut crash_info = serde_json::json!({
                                    "bundle_path": crash.path.display().to_string(),
                                });
                                if let Some(ref report) = crash.report {
                                    crash_info["message"] = serde_json::json!(report.message);
                                    crash_info["timestamp"] = serde_json::json!(report.timestamp);
                                }
                                payload["latest_crash"] = crash_info;
                            }

                            let response = RobotResponse::success(payload, elapsed_ms(start));
                            print_robot_response(&response, format, stats)?;
                        }
                        RobotCommands::Help | RobotCommands::QuickStart => {
                            unreachable!("handled above")
                        }
                    }
                }
            }
        }

        Some(Commands::Search {
            command,
            query,
            format,
            limit,
            pane,
            bookmark,
            bookmark_tag,
            since,
            suggest,
        }) => {
            use wa_core::output::{
                OutputFormat, RenderContext, SearchResultRenderer, SearchSuggestRenderer,
                detect_format,
            };

            let output_format = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            // Get workspace layout for DB path
            let layout = match config.workspace_layout(Some(&workspace_root)) {
                Ok(l) => l,
                Err(e) => {
                    if output_format.is_json() {
                        println!(
                            r#"{{"ok": false, "error": "Failed to get workspace layout: {}", "version": "{}"}}"#,
                            e,
                            wa_core::VERSION
                        );
                    } else {
                        eprintln!("Error: Failed to get workspace layout: {e}");
                        eprintln!("Check --workspace or WA_WORKSPACE");
                    }
                    std::process::exit(1);
                }
            };

            // Open storage handle
            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => s,
                Err(e) => {
                    if output_format.is_json() {
                        println!(
                            r#"{{"ok": false, "error": "Failed to open storage: {}", "version": "{}"}}"#,
                            e,
                            wa_core::VERSION
                        );
                    } else {
                        eprintln!("Error: Failed to open storage: {e}");
                        eprintln!("Is the database initialized? Run 'wa watch' first.");
                    }
                    std::process::exit(1);
                }
            };

            match command {
                Some(SearchCommands::Fts { command }) => match command {
                    FtsCommands::Verify => match storage.get_indexing_health().await {
                        Ok(report) => {
                            if output_format.is_json() {
                                let payload = serde_json::json!({
                                    "ok": true,
                                    "report": report,
                                    "version": wa_core::VERSION,
                                });
                                println!(
                                    "{}",
                                    serde_json::to_string_pretty(&payload).unwrap_or_default()
                                );
                            } else {
                                let status = if report.healthy {
                                    "healthy"
                                } else {
                                    "unhealthy"
                                };
                                println!("FTS index health: {status}");
                                println!("  Total segments: {}", report.total_segments);
                                println!("  Total FTS rows: {}", report.total_fts_rows);
                                println!("  Inconsistent panes: {}", report.inconsistent_panes);
                                if !report.healthy || cli.verbose > 0 {
                                    for pane in &report.panes {
                                        if !pane.fts_consistent || cli.verbose > 0 {
                                            println!(
                                                "  Pane {}: segments={} fts_rows={} consistent={}",
                                                pane.pane_id,
                                                pane.segment_count,
                                                pane.fts_row_count,
                                                pane.fts_consistent
                                            );
                                        }
                                    }
                                }
                            }
                        }
                        Err(e) => {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "FTS verify failed: {}", "version": "{}"}}"#,
                                    e,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: FTS verify failed: {e}");
                            }
                            std::process::exit(1);
                        }
                    },
                    FtsCommands::Rebuild => {
                        if !output_format.is_json() {
                            println!("Rebuilding FTS index...");
                        }
                        let config = wa_core::storage::FtsSyncConfig::default();
                        match storage.rebuild_fts(config).await {
                            Ok(result) => {
                                if output_format.is_json() {
                                    let payload = serde_json::json!({
                                        "ok": true,
                                        "result": result,
                                        "version": wa_core::VERSION,
                                    });
                                    println!(
                                        "{}",
                                        serde_json::to_string_pretty(&payload).unwrap_or_default()
                                    );
                                } else {
                                    println!(
                                        "FTS rebuild complete: panes_processed={} segments_indexed={} duration_ms={}",
                                        result.panes_processed,
                                        result.segments_indexed,
                                        result.duration_ms
                                    );
                                    if !result.warnings.is_empty() {
                                        println!("Warnings:");
                                        for warning in &result.warnings {
                                            println!("  - {warning}");
                                        }
                                    }
                                }
                            }
                            Err(e) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "FTS rebuild failed: {}", "version": "{}"}}"#,
                                        e,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: FTS rebuild failed: {e}");
                                }
                                std::process::exit(1);
                            }
                        }
                    }
                },
                Some(SearchCommands::Save {
                    name,
                    query,
                    pane,
                    limit,
                    since,
                }) => {
                    if limit == 0 {
                        if output_format.is_json() {
                            println!(
                                r#"{{"ok": false, "error": "Limit must be greater than 0.", "version": "{}"}}"#,
                                wa_core::VERSION
                            );
                        } else {
                            eprintln!("Error: Limit must be greater than 0.");
                        }
                        std::process::exit(1);
                    }

                    let lints = wa_core::storage::lint_fts_query(&query);
                    if search_lints_have_errors(&lints) {
                        if output_format.is_json() {
                            let payload = serde_json::json!({
                                "ok": false,
                                "error": "Invalid search query.",
                                "lint": lints,
                                "version": wa_core::VERSION,
                            });
                            println!(
                                "{}",
                                serde_json::to_string_pretty(&payload).unwrap_or_default()
                            );
                        } else {
                            eprintln!("Error: Invalid search query.");
                            eprint!("{}", format_search_lints_plain(&lints));
                        }
                        std::process::exit(1);
                    }
                    if !lints.is_empty() && !output_format.is_json() {
                        eprint!("{}", format_search_lints_plain(&lints));
                    }

                    match storage.get_saved_search_by_name(&name).await {
                        Ok(Some(_)) => {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "Saved search already exists: {}", "version": "{}"}}"#,
                                    name,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: Saved search already exists: {name}");
                            }
                            std::process::exit(1);
                        }
                        Ok(None) => {}
                        Err(e) => {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "Failed to load saved searches: {}", "version": "{}"}}"#,
                                    e,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: Failed to load saved searches: {e}");
                            }
                            std::process::exit(1);
                        }
                    }

                    let limit_i64 = i64::try_from(limit)
                        .ok()
                        .filter(|v| *v > 0)
                        .unwrap_or(wa_core::storage::SAVED_SEARCH_DEFAULT_LIMIT);
                    let since_mode = if since.is_some() {
                        wa_core::storage::SAVED_SEARCH_SINCE_MODE_FIXED
                    } else {
                        wa_core::storage::SAVED_SEARCH_SINCE_MODE_LAST_RUN
                    };
                    let record = wa_core::storage::SavedSearchRecord::new(
                        name.clone(),
                        query.clone(),
                        pane,
                        limit_i64,
                        since_mode.to_string(),
                        since,
                    );

                    match storage.insert_saved_search(record.clone()).await {
                        Ok(()) => {
                            if output_format.is_json() {
                                let payload = serde_json::json!({
                                    "ok": true,
                                    "saved_search": record,
                                    "version": wa_core::VERSION,
                                });
                                println!(
                                    "{}",
                                    serde_json::to_string_pretty(&payload).unwrap_or_default()
                                );
                            } else {
                                println!("Saved search '{name}' created.");
                            }
                        }
                        Err(e) => {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "Failed to save search: {}", "version": "{}"}}"#,
                                    e,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: Failed to save search: {e}");
                            }
                            std::process::exit(1);
                        }
                    }
                }
                Some(SearchCommands::Saved { command }) => match command {
                    SavedSearchCommands::List => match storage.list_saved_searches().await {
                        Ok(searches) => {
                            if output_format.is_json() {
                                let payload = serde_json::json!({
                                    "ok": true,
                                    "saved_searches": searches,
                                    "total": searches.len(),
                                    "version": wa_core::VERSION,
                                });
                                println!(
                                    "{}",
                                    serde_json::to_string_pretty(&payload).unwrap_or_default()
                                );
                            } else {
                                print!("{}", format_saved_searches_plain(&searches));
                            }
                        }
                        Err(e) => {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "Failed to list saved searches: {}", "version": "{}"}}"#,
                                    e,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: Failed to list saved searches: {e}");
                            }
                            std::process::exit(1);
                        }
                    },
                    SavedSearchCommands::Run { name } => {
                        let saved = match storage.get_saved_search_by_name(&name).await {
                            Ok(Some(search)) => search,
                            Ok(None) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Saved search not found: {}", "version": "{}"}}"#,
                                        name,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Saved search not found: {name}");
                                }
                                std::process::exit(1);
                            }
                            Err(e) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Failed to load saved search: {}", "version": "{}"}}"#,
                                        e,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Failed to load saved search: {e}");
                                }
                                std::process::exit(1);
                            }
                        };

                        let now_ms_i64 = i64::try_from(now_ms()).unwrap_or(i64::MAX);

                        let lints = wa_core::storage::lint_fts_query(&saved.query);
                        if search_lints_have_errors(&lints) {
                            let summary = lints
                                .iter()
                                .find(|lint| {
                                    lint.severity == wa_core::storage::SearchLintSeverity::Error
                                })
                                .map(|lint| lint.message.clone())
                                .unwrap_or_else(|| "Invalid search query.".to_string());
                            let stored_error = format!("Invalid search query: {summary}");
                            if let Err(e) = storage
                                .update_saved_search_run(
                                    &saved.id,
                                    now_ms_i64,
                                    None,
                                    Some(stored_error.clone()),
                                )
                                .await
                            {
                                tracing::warn!("Failed to update saved search run: {e}");
                            }

                            if output_format.is_json() {
                                let payload = serde_json::json!({
                                    "ok": false,
                                    "error": "Invalid search query.",
                                    "lint": lints,
                                    "version": wa_core::VERSION,
                                });
                                println!(
                                    "{}",
                                    serde_json::to_string_pretty(&payload).unwrap_or_default()
                                );
                            } else {
                                eprintln!("Error: Invalid search query.");
                                eprint!("{}", format_search_lints_plain(&lints));
                            }
                            std::process::exit(1);
                        }
                        if !lints.is_empty() && !output_format.is_json() {
                            eprint!("{}", format_search_lints_plain(&lints));
                        }

                        let limit = if saved.limit > 0 {
                            saved.limit as usize
                        } else {
                            wa_core::storage::SAVED_SEARCH_DEFAULT_LIMIT as usize
                        };
                        let since = if saved.since_mode
                            == wa_core::storage::SAVED_SEARCH_SINCE_MODE_FIXED
                        {
                            saved.since_ms
                        } else {
                            saved.last_run_at
                        };

                        let options = wa_core::storage::SearchOptions {
                            limit: Some(limit),
                            pane_id: saved.pane_id,
                            since,
                            until: None,
                            include_snippets: Some(true),
                            snippet_max_tokens: Some(30),
                            highlight_prefix: Some(">>".to_string()),
                            highlight_suffix: Some("<<".to_string()),
                        };

                        match storage.search_with_results(&saved.query, options).await {
                            Ok(results) => {
                                if let Err(e) = storage
                                    .update_saved_search_run(
                                        &saved.id,
                                        now_ms_i64,
                                        Some(results.len() as i64),
                                        None,
                                    )
                                    .await
                                {
                                    tracing::warn!("Failed to update saved search run: {e}");
                                }

                                let ctx = RenderContext::new(output_format)
                                    .verbose(cli.verbose)
                                    .limit(limit);
                                let output =
                                    SearchResultRenderer::render(&results, &saved.query, &ctx);
                                print!("{output}");
                            }
                            Err(e) => {
                                let error_msg = format!("Search failed: {e}");
                                if let Err(e) = storage
                                    .update_saved_search_run(
                                        &saved.id,
                                        now_ms_i64,
                                        None,
                                        Some(error_msg.clone()),
                                    )
                                    .await
                                {
                                    tracing::warn!("Failed to update saved search run: {e}");
                                }

                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Search failed: {}", "version": "{}"}}"#,
                                        e,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Search failed: {e}");
                                    if e.to_string().contains("fts5")
                                        || e.to_string().contains("syntax")
                                    {
                                        eprintln!("Check your FTS query syntax.");
                                    }
                                }
                                std::process::exit(1);
                            }
                        }
                    }
                    SavedSearchCommands::Schedule { name, interval_ms } => {
                        if interval_ms < 1000 {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "interval_ms must be >= 1000", "version": "{}"}}"#,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: interval_ms must be >= 1000");
                            }
                            std::process::exit(1);
                        }

                        let saved = match storage.get_saved_search_by_name(&name).await {
                            Ok(Some(search)) => search,
                            Ok(None) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Saved search not found: {}", "version": "{}"}}"#,
                                        name,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Saved search not found: {name}");
                                }
                                std::process::exit(1);
                            }
                            Err(e) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Failed to load saved search: {}", "version": "{}"}}"#,
                                        e,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Failed to load saved search: {e}");
                                }
                                std::process::exit(1);
                            }
                        };

                        if let Err(e) = storage
                            .update_saved_search_schedule(&saved.id, true, Some(interval_ms))
                            .await
                        {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "Failed to update schedule: {}", "version": "{}"}}"#,
                                    e,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: Failed to update schedule: {e}");
                            }
                            std::process::exit(1);
                        }

                        let updated = match storage.get_saved_search_by_name(&name).await {
                            Ok(Some(search)) => search,
                            Ok(None) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Saved search not found: {}", "version": "{}"}}"#,
                                        name,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Saved search not found: {name}");
                                }
                                std::process::exit(1);
                            }
                            Err(e) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Failed to load saved search: {}", "version": "{}"}}"#,
                                        e,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Failed to load saved search: {e}");
                                }
                                std::process::exit(1);
                            }
                        };
                        if output_format.is_json() {
                            let payload = serde_json::json!({
                                "ok": true,
                                "saved_search": updated,
                                "version": wa_core::VERSION,
                            });
                            println!(
                                "{}",
                                serde_json::to_string_pretty(&payload).unwrap_or_default()
                            );
                        } else {
                            println!("Scheduled saved search '{name}' every {interval_ms}ms.");
                        }
                    }
                    SavedSearchCommands::Unschedule { name } => {
                        let saved = match storage.get_saved_search_by_name(&name).await {
                            Ok(Some(search)) => search,
                            Ok(None) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Saved search not found: {}", "version": "{}"}}"#,
                                        name,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Saved search not found: {name}");
                                }
                                std::process::exit(1);
                            }
                            Err(e) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Failed to load saved search: {}", "version": "{}"}}"#,
                                        e,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Failed to load saved search: {e}");
                                }
                                std::process::exit(1);
                            }
                        };

                        if let Err(e) = storage
                            .update_saved_search_schedule(&saved.id, false, None)
                            .await
                        {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "Failed to update schedule: {}", "version": "{}"}}"#,
                                    e,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: Failed to update schedule: {e}");
                            }
                            std::process::exit(1);
                        }

                        let updated = match storage.get_saved_search_by_name(&name).await {
                            Ok(Some(search)) => search,
                            Ok(None) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Saved search not found: {}", "version": "{}"}}"#,
                                        name,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Saved search not found: {name}");
                                }
                                std::process::exit(1);
                            }
                            Err(e) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Failed to load saved search: {}", "version": "{}"}}"#,
                                        e,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Failed to load saved search: {e}");
                                }
                                std::process::exit(1);
                            }
                        };
                        if output_format.is_json() {
                            let payload = serde_json::json!({
                                "ok": true,
                                "saved_search": updated,
                                "version": wa_core::VERSION,
                            });
                            println!(
                                "{}",
                                serde_json::to_string_pretty(&payload).unwrap_or_default()
                            );
                        } else {
                            println!("Unscheduled saved search '{name}'.");
                        }
                    }
                    SavedSearchCommands::Enable { name } => {
                        let saved = match storage.get_saved_search_by_name(&name).await {
                            Ok(Some(search)) => search,
                            Ok(None) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Saved search not found: {}", "version": "{}"}}"#,
                                        name,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Saved search not found: {name}");
                                }
                                std::process::exit(1);
                            }
                            Err(e) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Failed to load saved search: {}", "version": "{}"}}"#,
                                        e,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Failed to load saved search: {e}");
                                }
                                std::process::exit(1);
                            }
                        };

                        let interval = match saved.schedule_interval_ms {
                            Some(v) => v,
                            None => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Saved search has no schedule interval; use 'wa search saved schedule'.", "version": "{}"}}"#,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!(
                                        "Error: Saved search has no schedule interval; use 'wa search saved schedule'."
                                    );
                                }
                                std::process::exit(1);
                            }
                        };

                        if let Err(e) = storage
                            .update_saved_search_schedule(&saved.id, true, Some(interval))
                            .await
                        {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "Failed to update schedule: {}", "version": "{}"}}"#,
                                    e,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: Failed to update schedule: {e}");
                            }
                            std::process::exit(1);
                        }

                        let updated = match storage.get_saved_search_by_name(&name).await {
                            Ok(Some(search)) => search,
                            Ok(None) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Saved search not found: {}", "version": "{}"}}"#,
                                        name,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Saved search not found: {name}");
                                }
                                std::process::exit(1);
                            }
                            Err(e) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Failed to load saved search: {}", "version": "{}"}}"#,
                                        e,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Failed to load saved search: {e}");
                                }
                                std::process::exit(1);
                            }
                        };
                        if output_format.is_json() {
                            let payload = serde_json::json!({
                                "ok": true,
                                "saved_search": updated,
                                "version": wa_core::VERSION,
                            });
                            println!(
                                "{}",
                                serde_json::to_string_pretty(&payload).unwrap_or_default()
                            );
                        } else {
                            println!("Enabled scheduling for saved search '{name}'.");
                        }
                    }
                    SavedSearchCommands::Disable { name } => {
                        let saved = match storage.get_saved_search_by_name(&name).await {
                            Ok(Some(search)) => search,
                            Ok(None) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Saved search not found: {}", "version": "{}"}}"#,
                                        name,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Saved search not found: {name}");
                                }
                                std::process::exit(1);
                            }
                            Err(e) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Failed to load saved search: {}", "version": "{}"}}"#,
                                        e,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Failed to load saved search: {e}");
                                }
                                std::process::exit(1);
                            }
                        };

                        if let Err(e) = storage
                            .update_saved_search_schedule(
                                &saved.id,
                                false,
                                saved.schedule_interval_ms,
                            )
                            .await
                        {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "Failed to update schedule: {}", "version": "{}"}}"#,
                                    e,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: Failed to update schedule: {e}");
                            }
                            std::process::exit(1);
                        }

                        let updated = match storage.get_saved_search_by_name(&name).await {
                            Ok(Some(search)) => search,
                            Ok(None) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Saved search not found: {}", "version": "{}"}}"#,
                                        name,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Saved search not found: {name}");
                                }
                                std::process::exit(1);
                            }
                            Err(e) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Failed to load saved search: {}", "version": "{}"}}"#,
                                        e,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Failed to load saved search: {e}");
                                }
                                std::process::exit(1);
                            }
                        };
                        if output_format.is_json() {
                            let payload = serde_json::json!({
                                "ok": true,
                                "saved_search": updated,
                                "version": wa_core::VERSION,
                            });
                            println!(
                                "{}",
                                serde_json::to_string_pretty(&payload).unwrap_or_default()
                            );
                        } else {
                            println!("Disabled scheduling for saved search '{name}'.");
                        }
                    }
                    SavedSearchCommands::Delete { name } => {
                        match storage.delete_saved_search(&name).await {
                            Ok(deleted) => {
                                if deleted == 0 {
                                    if output_format.is_json() {
                                        println!(
                                            r#"{{"ok": false, "error": "Saved search not found: {}", "version": "{}"}}"#,
                                            name,
                                            wa_core::VERSION
                                        );
                                    } else {
                                        eprintln!("Error: Saved search not found: {name}");
                                    }
                                    std::process::exit(1);
                                }

                                if output_format.is_json() {
                                    let payload = serde_json::json!({
                                        "ok": true,
                                        "deleted": true,
                                        "name": name,
                                        "version": wa_core::VERSION,
                                    });
                                    println!(
                                        "{}",
                                        serde_json::to_string_pretty(&payload).unwrap_or_default()
                                    );
                                } else {
                                    println!("Deleted saved search '{name}'.");
                                }
                            }
                            Err(e) => {
                                if output_format.is_json() {
                                    println!(
                                        r#"{{"ok": false, "error": "Failed to delete saved search: {}", "version": "{}"}}"#,
                                        e,
                                        wa_core::VERSION
                                    );
                                } else {
                                    eprintln!("Error: Failed to delete saved search: {e}");
                                }
                                std::process::exit(1);
                            }
                        }
                    }
                },
                None if suggest => {
                    let partial = query.as_deref().unwrap_or("");
                    let suggestions = wa_core::storage::search_query_suggestions(partial, limit);
                    let ctx = RenderContext::new(output_format)
                        .limit(limit)
                        .verbose(cli.verbose);
                    println!(
                        "{}",
                        SearchSuggestRenderer::render(&suggestions, partial, &ctx)
                    );
                }
                None => {
                    let query = match query {
                        Some(q) => q,
                        None => {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "Missing search query.", "version": "{}"}}"#,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: Missing search query.");
                                eprintln!("Try: wa search \"error\"");
                            }
                            std::process::exit(1);
                        }
                    };

                    let mut bookmark_pane_ids = match resolve_bookmark_pane_ids(
                        &storage,
                        bookmark.as_deref(),
                        bookmark_tag.as_deref(),
                    )
                    .await
                    {
                        Ok(ids) => ids,
                        Err(err) => {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "{}", "version": "{}"}}"#,
                                    err,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: {err}");
                            }
                            std::process::exit(1);
                        }
                    };

                    if let Some(filter_pane_id) = pane
                        && let Some(ref mut pane_ids) = bookmark_pane_ids
                    {
                        pane_ids.retain(|pane_id| *pane_id == filter_pane_id);
                    }

                    let redacted_query = redact_for_output(&query);
                    tracing::info!(
                        "Searching for '{}' (limit={}, pane={:?}, bookmark={:?}, bookmark_tag={:?})",
                        redacted_query,
                        limit,
                        pane,
                        bookmark,
                        bookmark_tag
                    );

                    let lints = wa_core::storage::lint_fts_query(&query);
                    if search_lints_have_errors(&lints) {
                        if output_format.is_json() {
                            let payload = serde_json::json!({
                                "ok": false,
                                "error": "Invalid search query.",
                                "lint": lints,
                                "version": wa_core::VERSION,
                            });
                            println!(
                                "{}",
                                serde_json::to_string_pretty(&payload).unwrap_or_default()
                            );
                        } else {
                            eprintln!("Error: Invalid search query.");
                            eprint!("{}", format_search_lints_plain(&lints));
                        }
                        std::process::exit(1);
                    }
                    if !lints.is_empty() && !output_format.is_json() {
                        eprint!("{}", format_search_lints_plain(&lints));
                    }

                    let mut pane_candidates = bookmark_pane_ids.map(|pane_ids| {
                        let mut ids: Vec<u64> = pane_ids.into_iter().collect();
                        ids.sort_unstable();
                        ids
                    });
                    if pane_candidates.is_none()
                        && let Some(filter_pane_id) = pane
                    {
                        pane_candidates = Some(vec![filter_pane_id]);
                    }

                    // Build base search options
                    let base_options = wa_core::storage::SearchOptions {
                        limit: Some(limit),
                        pane_id: None,
                        since,
                        until: None,
                        include_snippets: Some(true),
                        snippet_max_tokens: Some(30),
                        highlight_prefix: Some(">>".to_string()),
                        highlight_suffix: Some("<<".to_string()),
                    };

                    let search_results = if let Some(candidate_panes) = pane_candidates {
                        if candidate_panes.is_empty() {
                            Ok(Vec::new())
                        } else if candidate_panes.len() == 1 {
                            let mut options = base_options.clone();
                            options.pane_id = Some(candidate_panes[0]);
                            storage.search_with_results(&query, options).await
                        } else {
                            let mut combined = Vec::new();
                            for candidate_pane in candidate_panes {
                                let mut options = base_options.clone();
                                options.pane_id = Some(candidate_pane);
                                let mut pane_results = match storage
                                    .search_with_results(&query, options)
                                    .await
                                {
                                    Ok(results) => results,
                                    Err(e) => {
                                        if output_format.is_json() {
                                            println!(
                                                r#"{{"ok": false, "error": "Search failed: {}", "version": "{}"}}"#,
                                                e,
                                                wa_core::VERSION
                                            );
                                        } else {
                                            eprintln!("Error: Search failed: {e}");
                                        }
                                        std::process::exit(1);
                                    }
                                };
                                combined.append(&mut pane_results);
                            }
                            combined.sort_by(|left, right| {
                                left.score
                                    .total_cmp(&right.score)
                                    .then_with(|| {
                                        left.segment.captured_at.cmp(&right.segment.captured_at)
                                    })
                                    .then_with(|| left.segment.id.cmp(&right.segment.id))
                            });
                            combined.truncate(limit);
                            Ok(combined)
                        }
                    } else {
                        storage.search_with_results(&query, base_options).await
                    };

                    match search_results {
                        Ok(results) => {
                            let ctx = RenderContext::new(output_format)
                                .verbose(cli.verbose)
                                .limit(limit);
                            let output = SearchResultRenderer::render(&results, &query, &ctx);
                            print!("{output}");
                        }
                        Err(e) => {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "Search failed: {}", "version": "{}"}}"#,
                                    e,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: Search failed: {e}");
                                if e.to_string().contains("fts5")
                                    || e.to_string().contains("syntax")
                                {
                                    eprintln!("Check your FTS query syntax.");
                                }
                            }
                            std::process::exit(1);
                        }
                    }
                }
            }
        }

        Some(Commands::List { json }) => {
            let wezterm = wa_core::wezterm::default_wezterm_handle();
            let panes = match wezterm.list_panes().await {
                Ok(panes) => panes,
                Err(e) => {
                    eprintln!("Failed to list panes: {e}");
                    return Err(e.into());
                }
            };

            let filter = &config.ingest.panes;
            let states: Vec<PaneState> = panes
                .iter()
                .map(|p| PaneState::from_pane_info(p, filter))
                .collect();

            if json {
                println!("{}", serde_json::to_string_pretty(&states)?);
            } else if states.is_empty() {
                println!("No panes found");
            } else {
                let observed_count = states.iter().filter(|s| s.observed).count();
                let ignored_count = states.len() - observed_count;
                println!("Panes ({observed_count} observed, {ignored_count} ignored):");
                println!(
                    "  {:>4}  {:>10}  {:<20}  {:<40}  DOMAIN",
                    "ID", "STATUS", "TITLE", "CWD"
                );
                println!("  {}", "-".repeat(100));
                for state in &states {
                    println!("{}", state.format_human());
                }
            }
        }

        Some(Commands::Panes { command }) => match command {
            PanesCommands::Priority {
                pane_id,
                weight,
                ttl_secs,
                clear,
                json,
            } => {
                #[cfg(unix)]
                {
                    let client = wa_core::ipc::IpcClient::new(&layout.ipc_socket_path);

                    let response = if clear {
                        client.clear_pane_priority(pane_id).await
                    } else {
                        let Some(weight) = weight else {
                            eprintln!("Error: missing --weight (or use --clear)");
                            std::process::exit(2);
                        };
                        let ttl_ms = ttl_secs.saturating_mul(1000);
                        client
                            .set_pane_priority(pane_id, weight, Some(ttl_ms))
                            .await
                    };

                    match response {
                        Ok(response) => {
                            if json {
                                println!("{}", serde_json::to_string_pretty(&response)?);
                            } else if response.ok {
                                if clear {
                                    println!("Cleared pane {pane_id} priority override");
                                } else {
                                    let Some(weight) = weight else {
                                        // Should be unreachable due to earlier validation.
                                        eprintln!("Error: missing --weight");
                                        std::process::exit(2);
                                    };
                                    if ttl_secs == 0 {
                                        println!(
                                            "Set pane {pane_id} priority override to {weight} (until cleared)"
                                        );
                                    } else {
                                        println!(
                                            "Set pane {pane_id} priority override to {weight} (ttl {ttl_secs}s)"
                                        );
                                    }
                                }
                            } else {
                                eprintln!(
                                    "Error: {}",
                                    response
                                        .error
                                        .clone()
                                        .unwrap_or_else(|| "request failed".to_string())
                                );
                                if let Some(hint) = response.hint {
                                    eprintln!("Hint: {hint}");
                                }
                                std::process::exit(1);
                            }
                        }
                        Err(err) => {
                            eprintln!("Error: {err}");
                            eprintln!("Hint: start the watcher with `wa watch` in this workspace.");
                            std::process::exit(1);
                        }
                    }
                }
                #[cfg(not(unix))]
                {
                    eprintln!("Error: IPC is not supported on this platform");
                    std::process::exit(1);
                }
            }
            PanesCommands::Bookmark { action } => {
                let db_path = layout.db_path.to_string_lossy();
                let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                    Ok(s) => s,
                    Err(e) => {
                        eprintln!("Error: Failed to open storage: {e}");
                        std::process::exit(1);
                    }
                };

                match action {
                    BookmarkAction::Add {
                        pane_id,
                        alias,
                        tags,
                        description,
                        json,
                    } => {
                        let tags_vec = tags.map(|t| {
                            t.split(',')
                                .map(|s| s.trim().to_string())
                                .filter(|s| !s.is_empty())
                                .collect::<Vec<_>>()
                        });
                        let now = wa_core::storage::now_ms();
                        let record = wa_core::storage::PaneBookmarkRecord {
                            id: 0,
                            pane_id,
                            alias: alias.clone(),
                            tags: tags_vec,
                            description,
                            created_at: now,
                            updated_at: now,
                        };
                        match storage.insert_pane_bookmark(record).await {
                            Ok(id) => {
                                if json {
                                    println!(
                                        r#"{{"ok": true, "id": {}, "alias": "{}"}}"#,
                                        id, alias
                                    );
                                } else {
                                    println!("Bookmarked pane {pane_id} as \"{alias}\"");
                                }
                            }
                            Err(e) => {
                                let msg = format!("{e}");
                                if msg.contains("UNIQUE constraint") {
                                    eprintln!(
                                        "Error: alias \"{alias}\" already exists. Remove it first."
                                    );
                                } else {
                                    eprintln!("Error: {e}");
                                }
                                std::process::exit(1);
                            }
                        }
                    }
                    BookmarkAction::List { tag, json } => {
                        let bookmarks = if let Some(ref tag) = tag {
                            storage.list_pane_bookmarks_by_tag(tag).await
                        } else {
                            storage.list_pane_bookmarks().await
                        };
                        match bookmarks {
                            Ok(list) => {
                                if json {
                                    println!("{}", serde_json::to_string_pretty(&list)?);
                                } else if list.is_empty() {
                                    if let Some(ref tag) = tag {
                                        println!("No bookmarks with tag \"{tag}\"");
                                    } else {
                                        println!(
                                            "No bookmarks. Add one with: wa panes bookmark add <pane_id> --alias <name>"
                                        );
                                    }
                                } else {
                                    for bm in &list {
                                        let tags_str = bm
                                            .tags
                                            .as_ref()
                                            .map(|t| t.join(", "))
                                            .unwrap_or_default();
                                        let desc = bm.description.as_deref().unwrap_or("");
                                        if tags_str.is_empty() && desc.is_empty() {
                                            println!("  {}  pane {}", bm.alias, bm.pane_id);
                                        } else if desc.is_empty() {
                                            println!(
                                                "  {}  pane {} [{}]",
                                                bm.alias, bm.pane_id, tags_str
                                            );
                                        } else {
                                            println!(
                                                "  {}  pane {} [{}] {}",
                                                bm.alias, bm.pane_id, tags_str, desc
                                            );
                                        }
                                    }
                                    println!("\n{} bookmark(s)", list.len());
                                }
                            }
                            Err(e) => {
                                eprintln!("Error: {e}");
                                std::process::exit(1);
                            }
                        }
                    }
                    BookmarkAction::Remove { alias, json } => {
                        match storage.delete_pane_bookmark(&alias).await {
                            Ok(true) => {
                                if json {
                                    println!(r#"{{"ok": true, "alias": "{}"}}"#, alias);
                                } else {
                                    println!("Removed bookmark \"{alias}\"");
                                }
                            }
                            Ok(false) => {
                                eprintln!("Error: bookmark \"{alias}\" not found");
                                std::process::exit(1);
                            }
                            Err(e) => {
                                eprintln!("Error: {e}");
                                std::process::exit(1);
                            }
                        }
                    }
                }
            }
        },

        Some(Commands::Show { pane_id, output }) => {
            tracing::info!("Showing pane {} (output={})", pane_id, output);
            let wezterm = wa_core::wezterm::default_wezterm_handle();
            match wezterm.get_pane(pane_id).await {
                Ok(pane) => {
                    println!("Pane {}", pane.pane_id);
                    println!(
                        "  Tab: {}  Window: {}  Domain: {}",
                        pane.tab_id,
                        pane.window_id,
                        pane.effective_domain()
                    );
                    if let Some(title) = &pane.title {
                        println!("  Title: {title}");
                    }
                    if let Some(ws) = &pane.workspace {
                        println!("  Workspace: {ws}");
                    }
                    let cwd_info = pane.parsed_cwd();
                    if !cwd_info.path.is_empty() {
                        println!("  CWD: {}", cwd_info.path);
                    }
                    println!(
                        "  Size: {}x{}",
                        pane.effective_cols(),
                        pane.effective_rows()
                    );
                    if let (Some(x), Some(y)) = (pane.cursor_x, pane.cursor_y) {
                        println!("  Cursor: ({x}, {y})");
                    }
                    if pane.is_active {
                        println!("  Active: yes");
                    }
                    if pane.is_zoomed {
                        println!("  Zoomed: yes");
                    }
                    if let Some(tty) = &pane.tty_name {
                        println!("  TTY: {tty}");
                    }
                    if output {
                        match wezterm.get_text(pane_id, false).await {
                            Ok(text) => {
                                println!("\n--- Output ---");
                                print!("{text}");
                            }
                            Err(e) => {
                                eprintln!("Failed to get pane output: {e}");
                            }
                        }
                    }
                }
                Err(e) => {
                    eprintln!("Error: {e}");
                    std::process::exit(1);
                }
            }
        }

        Some(Commands::Send {
            pane_id,
            text,
            no_paste,
            no_newline,
            dry_run,
            wait_for,
            timeout_secs,
            wait_for_regex,
        }) => {
            use wa_core::output::{OutputFormat, detect_format};

            let output_format = detect_format();
            let emit_json = matches!(output_format, OutputFormat::Json)
                || (matches!(output_format, OutputFormat::Auto)
                    && !std::io::stdout().is_terminal());
            let redacted_text = redact_for_output(&text);
            let redacted_wait_for = wait_for.as_ref().map(|p| redact_for_output(p));

            let mut command = if dry_run {
                format!("wa send --pane {pane_id} \"{redacted_text}\" --dry-run")
            } else {
                format!("wa send --pane {pane_id} \"{redacted_text}\"")
            };
            if no_paste {
                command.push_str(" --no-paste");
            }
            if no_newline {
                command.push_str(" --no-newline");
            }
            if let Some(pattern) = &redacted_wait_for {
                command.push_str(" --wait-for \"");
                command.push_str(pattern);
                command.push('"');
                if wait_for_regex {
                    command.push_str(" --wait-for-regex");
                }
                command.push_str(&format!(" --timeout-secs {timeout_secs}"));
            }
            let command_ctx = wa_core::dry_run::CommandContext::new(command, dry_run);

            if command_ctx.is_dry_run() {
                let wezterm = wa_core::wezterm::default_wezterm_handle();
                let pane_info = wezterm.get_pane(pane_id).await.ok();
                let db_path = layout.db_path.to_string_lossy();
                let storage = wa_core::storage::StorageHandle::new(&db_path).await.ok();
                let resolution = resolve_pane_capabilities(
                    pane_id,
                    storage.as_ref(),
                    Some(layout.ipc_socket_path.as_path()),
                )
                .await;
                let mut report = build_send_dry_run_report(
                    &command_ctx,
                    pane_id,
                    pane_info.as_ref(),
                    Some(&resolution.capabilities),
                    &text,
                    no_paste,
                    wait_for.as_deref(),
                    timeout_secs,
                    &config,
                    wa_core::policy::ActorKind::Human,
                );
                report.warnings.extend(resolution.warnings);
                if emit_json {
                    println!("{}", serde_json::to_string_pretty(&report.redacted())?);
                } else {
                    println!("{}", wa_core::dry_run::format_human(&report));
                }
            } else {
                tracing::info!(
                    "Sending to pane {} (no_paste={}): {}",
                    pane_id,
                    no_paste,
                    redacted_text
                );
                let emit_error = |message: &str, hint: Option<&str>| {
                    if emit_json {
                        println!(
                            "{}",
                            serde_json::json!({
                                "ok": false,
                                "error": message,
                                "hint": hint,
                                "version": wa_core::VERSION,
                            })
                        );
                    } else {
                        eprintln!("Error: {message}");
                        if let Some(hint) = hint {
                            eprintln!("{hint}");
                        }
                    }
                };

                let db_path = layout.db_path.to_string_lossy();
                let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                    Ok(s) => s,
                    Err(e) => {
                        emit_error(
                            &format!("Failed to open storage: {e}"),
                            Some("Is the database initialized? Run 'wa watch' first."),
                        );
                        return Ok(());
                    }
                };

                let wezterm = wa_core::wezterm::default_wezterm_handle();
                let pane_info = match wezterm.get_pane(pane_id).await {
                    Ok(info) => info,
                    Err(e) => {
                        let (_code, hint) = map_wezterm_error_to_robot(&e);
                        emit_error(&format!("{e}"), hint.as_deref());
                        return Ok(());
                    }
                };
                let domain = pane_info.inferred_domain();

                let mut engine = wa_core::policy::PolicyEngine::new(
                    config.safety.rate_limit_per_pane,
                    config.safety.rate_limit_global,
                    config.safety.require_prompt_active,
                )
                .with_command_gate_config(config.safety.command_gate.clone())
                .with_policy_rules(config.safety.rules.clone());

                let resolution = resolve_pane_capabilities(
                    pane_id,
                    Some(&storage),
                    Some(layout.ipc_socket_path.as_path()),
                )
                .await;
                let capabilities = resolution.capabilities;

                let summary = engine.redact_secrets(&text);
                let input = wa_core::policy::PolicyInput::new(
                    wa_core::policy::ActionKind::SendText,
                    wa_core::policy::ActorKind::Human,
                )
                .with_pane(pane_id)
                .with_domain(domain.clone())
                .with_capabilities(capabilities)
                .with_text_summary(&summary)
                .with_command_text(&text);

                let mut decision = engine.authorize(&input);
                if decision.requires_approval() {
                    let store = wa_core::approval::ApprovalStore::new(
                        &storage,
                        config.safety.approval.clone(),
                        workspace_root.to_string_lossy().to_string(),
                    );
                    decision = match store
                        .attach_to_decision(decision, &input, Some(summary.clone()))
                        .await
                    {
                        Ok(updated) => updated,
                        Err(e) => {
                            emit_error(&format!("Failed to issue approval token: {e}"), None);
                            return Ok(());
                        }
                    };
                }

                let mut injection = match decision {
                    wa_core::policy::PolicyDecision::Allow { .. } => {
                        let send_result = wezterm
                            .send_text_with_options(pane_id, &text, no_paste, no_newline)
                            .await;
                        match send_result {
                            Ok(()) => wa_core::policy::InjectionResult::Allowed {
                                decision,
                                summary: summary.clone(),
                                pane_id,
                                action: wa_core::policy::ActionKind::SendText,
                                audit_action_id: None,
                            },
                            Err(e) => wa_core::policy::InjectionResult::Error {
                                error: e.to_string(),
                                pane_id,
                                action: wa_core::policy::ActionKind::SendText,
                                audit_action_id: None,
                            },
                        }
                    }
                    wa_core::policy::PolicyDecision::Deny { .. } => {
                        wa_core::policy::InjectionResult::Denied {
                            decision,
                            summary: summary.clone(),
                            pane_id,
                            action: wa_core::policy::ActionKind::SendText,
                            audit_action_id: None,
                        }
                    }
                    wa_core::policy::PolicyDecision::RequireApproval { .. } => {
                        wa_core::policy::InjectionResult::RequiresApproval {
                            decision,
                            summary: summary.clone(),
                            pane_id,
                            action: wa_core::policy::ActionKind::SendText,
                            audit_action_id: None,
                        }
                    }
                };

                let mut audit_record = injection.to_audit_record(
                    wa_core::policy::ActorKind::Human,
                    None,
                    Some(domain.clone()),
                );
                audit_record.input_summary = Some(wa_core::policy::build_send_text_audit_summary(
                    &text, None, None,
                ));
                match storage.record_audit_action_redacted(audit_record).await {
                    Ok(audit_id) => {
                        injection.set_audit_action_id(audit_id);
                    }
                    Err(e) => {
                        tracing::warn!(pane_id, "Failed to record audit: {e}");
                    }
                }

                let mut wait_for_data = None;
                let mut verification_error = None;
                if injection.is_allowed() {
                    if let Some(pattern) = &wait_for {
                        let matcher = if wait_for_regex {
                            match fancy_regex::Regex::new(pattern) {
                                Ok(compiled) => {
                                    Some(wa_core::wezterm::WaitMatcher::regex(compiled))
                                }
                                Err(e) => {
                                    verification_error =
                                        Some(format!("Invalid wait-for regex: {e}"));
                                    None
                                }
                            }
                        } else {
                            Some(wa_core::wezterm::WaitMatcher::substring(pattern))
                        };

                        if let Some(matcher) = matcher {
                            let options = wa_core::wezterm::WaitOptions {
                                tail_lines: 200,
                                escapes: false,
                                ..wa_core::wezterm::WaitOptions::default()
                            };
                            let source =
                                wa_core::wezterm::WeztermHandleSource::new(Arc::clone(&wezterm));
                            let waiter =
                                wa_core::wezterm::PaneWaiter::new(&source).with_options(options);
                            let timeout = std::time::Duration::from_secs(timeout_secs);
                            match waiter.wait_for(pane_id, &matcher, timeout).await {
                                Ok(wa_core::wezterm::WaitResult::Matched { elapsed_ms, polls }) => {
                                    let pattern_out = redacted_wait_for
                                        .clone()
                                        .unwrap_or_else(|| pattern.clone());
                                    wait_for_data = Some(RobotWaitForData {
                                        pane_id,
                                        pattern: pattern_out,
                                        matched: true,
                                        elapsed_ms,
                                        polls,
                                        is_regex: wait_for_regex,
                                    });
                                }
                                Ok(wa_core::wezterm::WaitResult::TimedOut {
                                    elapsed_ms,
                                    polls,
                                    ..
                                }) => {
                                    let pattern_out = redacted_wait_for
                                        .clone()
                                        .unwrap_or_else(|| pattern.clone());
                                    wait_for_data = Some(RobotWaitForData {
                                        pane_id,
                                        pattern: pattern_out,
                                        matched: false,
                                        elapsed_ms,
                                        polls,
                                        is_regex: wait_for_regex,
                                    });
                                    verification_error =
                                        Some(format!("Timeout waiting for pattern '{pattern}'"));
                                }
                                Err(e) => {
                                    verification_error = Some(format!("wait-for failed: {e}"));
                                }
                            }
                        }
                    }
                }

                let data = HumanSendData {
                    pane_id,
                    injection,
                    wait_for: wait_for_data,
                    verification_error,
                    no_paste,
                    no_newline,
                };

                if emit_json {
                    println!("{}", serde_json::to_string_pretty(&data)?);
                } else {
                    println!(
                        "{}",
                        format_send_result_human(
                            &data,
                            &redacted_text,
                            redacted_wait_for.as_deref()
                        )
                    );
                }
            }
        }

        Some(Commands::GetText { pane_id, escapes }) => {
            tracing::info!("Getting text from pane {} (escapes={})", pane_id, escapes);
            let wezterm = wa_core::wezterm::default_wezterm_handle();
            match wezterm.get_text(pane_id, escapes).await {
                Ok(text) => {
                    print!("{text}");
                }
                Err(e) => {
                    eprintln!("Error: {e}");
                    std::process::exit(1);
                }
            }
        }

        Some(Commands::Workflow { command }) => {
            match command {
                WorkflowCommands::List => {
                    use std::sync::Arc;
                    use wa_core::workflows::{HandleCompaction, Workflow};

                    let workflows: Vec<Arc<dyn Workflow>> = vec![
                        Arc::new(
                            HandleCompaction::new()
                                .with_prompt_config(config.workflows.compaction_prompts.clone()),
                        ),
                        Arc::new(wa_core::workflows::HandleUsageLimits::new()),
                        Arc::new(wa_core::workflows::HandleSessionEnd::new()),
                        Arc::new(wa_core::workflows::HandleAuthRequired::new()),
                        Arc::new(wa_core::workflows::HandleClaudeCodeLimits::new()),
                        Arc::new(wa_core::workflows::HandleGeminiQuota::new()),
                    ];

                    println!(
                        "{:<30} {:<8} {:<7} {}",
                        "NAME", "STEPS", "PANE?", "DESCRIPTION"
                    );
                    for wf in &workflows {
                        let steps = wf.steps();
                        println!(
                            "{:<30} {:<8} {:<7} {}",
                            wf.name(),
                            steps.len(),
                            "yes",
                            wf.description()
                        );
                    }
                    println!("\n{} workflow(s) available.", workflows.len());
                }
                WorkflowCommands::Run {
                    name,
                    pane,
                    dry_run,
                } => {
                    let command = if dry_run {
                        format!("wa workflow run {name} --pane {pane} --dry-run")
                    } else {
                        format!("wa workflow run {name} --pane {pane}")
                    };
                    let command_ctx = wa_core::dry_run::CommandContext::new(command, dry_run);

                    if command_ctx.is_dry_run() {
                        use wa_core::output::{OutputFormat, detect_format};

                        let output_format = detect_format();
                        let emit_json = matches!(output_format, OutputFormat::Json)
                            || (matches!(output_format, OutputFormat::Auto)
                                && !std::io::stdout().is_terminal());

                        let wezterm = wa_core::wezterm::default_wezterm_handle();
                        let pane_info = wezterm.get_pane(pane).await.ok();
                        let report = build_workflow_dry_run_report(
                            &command_ctx,
                            &name,
                            pane,
                            pane_info.as_ref(),
                            &config,
                        );
                        if emit_json {
                            println!("{}", serde_json::to_string_pretty(&report.redacted())?);
                        } else {
                            println!("{}", wa_core::dry_run::format_human(&report));
                        }
                    } else {
                        use std::sync::Arc;
                        use wa_core::policy::{PolicyEngine, PolicyGatedInjector};
                        use wa_core::storage::StorageHandle;
                        use wa_core::workflows::{
                            PaneWorkflowLockManager, WorkflowEngine, WorkflowExecutionResult,
                            WorkflowRunner, WorkflowRunnerConfig,
                        };

                        tracing::info!("Running workflow '{}' on pane {}", name, pane);

                        // Verify pane exists
                        let wezterm = wa_core::wezterm::default_wezterm_handle();
                        match wezterm.list_panes().await {
                            Ok(panes) => {
                                if !panes.iter().any(|p| p.pane_id == pane) {
                                    eprintln!("Error: Pane {pane} does not exist.");
                                    eprintln!("Hint: Use 'wa status' to list available panes.");
                                    std::process::exit(1);
                                }
                            }
                            Err(e) => {
                                eprintln!("Error: Failed to query WezTerm panes: {e}");
                                eprintln!(
                                    "Hint: Ensure WezTerm is running and wezterm CLI is in PATH."
                                );
                                std::process::exit(1);
                            }
                        }

                        // Set up workflow infrastructure
                        let db_path = layout.db_path.to_string_lossy();
                        let storage = match StorageHandle::new(&db_path).await {
                            Ok(s) => Arc::new(s),
                            Err(e) => {
                                eprintln!("Error: Failed to open storage: {e}");
                                eprintln!("Hint: Check database path and permissions.");
                                std::process::exit(1);
                            }
                        };

                        let engine = WorkflowEngine::new(10);
                        let lock_manager = Arc::new(PaneWorkflowLockManager::new());

                        // Human mode requires prompt active
                        let policy_engine = PolicyEngine::new(
                            config.safety.rate_limit_per_pane,
                            config.safety.rate_limit_global,
                            true, // Require prompt active for human mode
                        );

                        let wezterm_handle = wa_core::wezterm::default_wezterm_handle();
                        let injector =
                            Arc::new(tokio::sync::Mutex::new(PolicyGatedInjector::with_storage(
                                policy_engine,
                                wezterm_handle,
                                storage.as_ref().clone(),
                            )));
                        let runner_config = WorkflowRunnerConfig::default();
                        let runner = WorkflowRunner::new(
                            engine,
                            lock_manager,
                            Arc::clone(&storage),
                            injector,
                            runner_config,
                        );

                        // Register built-in workflows
                        runner.register_workflow(Arc::new(
                            wa_core::workflows::HandleCompaction::new()
                                .with_prompt_config(config.workflows.compaction_prompts.clone()),
                        ));
                        runner.register_workflow(Arc::new(
                            wa_core::workflows::HandleUsageLimits::new(),
                        ));
                        runner.register_workflow(Arc::new(
                            wa_core::workflows::HandleSessionEnd::new(),
                        ));
                        runner.register_workflow(Arc::new(
                            wa_core::workflows::HandleAuthRequired::new(),
                        ));
                        runner.register_workflow(Arc::new(
                            wa_core::workflows::HandleClaudeCodeLimits::new(),
                        ));
                        runner.register_workflow(Arc::new(
                            wa_core::workflows::HandleGeminiQuota::new(),
                        ));

                        // Look up workflow
                        let workflow = runner.find_workflow_by_name(&name);

                        if let Some(wf) = workflow {
                            println!("Workflow: {} ({})", wf.name(), wf.description());
                            println!("Target pane: {pane}");
                            println!("Steps: {}", wf.step_count());
                            println!();

                            // Generate execution ID
                            let now_ms = std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap_or_default()
                                .as_millis();
                            let execution_id = format!("human-{name}-{now_ms}");

                            // Run the workflow
                            let run_start = std::time::Instant::now();
                            let result = runner.run_workflow(pane, wf, &execution_id, 0).await;
                            let elapsed = run_start.elapsed();

                            match result {
                                WorkflowExecutionResult::Completed { steps_executed, .. } => {
                                    println!(
                                        "Result: completed ({} step(s) in {:.1}s)",
                                        steps_executed,
                                        elapsed.as_secs_f64()
                                    );
                                    println!("Execution ID: {execution_id}");
                                }
                                WorkflowExecutionResult::Aborted {
                                    reason, step_index, ..
                                } => {
                                    eprintln!("Result: aborted at step {step_index}");
                                    eprintln!("Reason: {reason}");
                                    eprintln!("Execution ID: {execution_id}");
                                    eprintln!(
                                        "\nHint: Use 'wa workflow status {execution_id}' for details."
                                    );
                                }
                                WorkflowExecutionResult::PolicyDenied {
                                    reason,
                                    step_index,
                                    ..
                                } => {
                                    eprintln!("Result: denied by policy at step {step_index}");
                                    eprintln!("Reason: {reason}");
                                    eprintln!("Execution ID: {execution_id}");
                                    eprintln!(
                                        "\nHint: Check safety configuration or use --dry-run to preview."
                                    );
                                }
                                WorkflowExecutionResult::Error { error, .. } => {
                                    eprintln!("Result: error");
                                    eprintln!("Error: {error}");
                                    eprintln!("Execution ID: {execution_id}");
                                }
                            }
                        } else {
                            eprintln!("Error: Workflow '{name}' not found.");
                            eprintln!("Hint: Use 'wa workflow list' to see available workflows.");
                            std::process::exit(1);
                        }

                        if let Err(e) = storage.shutdown().await {
                            tracing::warn!("Failed to shutdown storage cleanly: {e}");
                        }
                    }
                }
                WorkflowCommands::Status {
                    execution_id,
                    verbose,
                } => {
                    tracing::info!("Getting status for execution {}", execution_id);

                    let layout = match config.workspace_layout(Some(&workspace_root)) {
                        Ok(l) => l,
                        Err(e) => {
                            eprintln!("Failed to get workspace layout: {e}");
                            return Ok(());
                        }
                    };

                    let db_path = layout.db_path.to_string_lossy();
                    let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                        Ok(s) => s,
                        Err(e) => {
                            eprintln!("Failed to open storage: {e}");
                            return Ok(());
                        }
                    };

                    match storage.get_workflow(&execution_id).await {
                        Ok(Some(record)) => {
                            println!("Workflow: {} ({})", record.workflow_name, record.id);
                            println!("Status: {}", record.status);
                            println!("Pane: {}", record.pane_id);
                            if let Some(event_id) = record.trigger_event_id {
                                println!("Trigger event: {event_id}");
                            }
                            println!("Current step: {}", record.current_step);
                            println!("Started at: {}", record.started_at);
                            println!("Updated at: {}", record.updated_at);
                            if let Some(completed_at) = record.completed_at {
                                println!("Completed at: {completed_at}");
                            }
                            if let Some(error) = record.error.as_ref() {
                                println!("Error: {error}");
                            }

                            if verbose > 0 {
                                match storage.get_action_plan(&execution_id).await {
                                    Ok(Some(plan)) => {
                                        println!("\nAction plan:");
                                        println!("  plan_id: {}", plan.plan_id);
                                        println!("  plan_hash: {}", plan.plan_hash);
                                        println!("  created_at: {}", plan.created_at);
                                        match serde_json::from_str::<serde_json::Value>(
                                            &plan.plan_json,
                                        ) {
                                            Ok(value) => {
                                                if let Ok(pretty) =
                                                    serde_json::to_string_pretty(&value)
                                                {
                                                    println!("{pretty}");
                                                } else {
                                                    println!("{}", plan.plan_json);
                                                }
                                            }
                                            Err(_) => {
                                                println!("{}", plan.plan_json);
                                            }
                                        }
                                    }
                                    Ok(None) => {
                                        println!("\nAction plan: <none>");
                                    }
                                    Err(e) => {
                                        println!("\nAction plan: <error: {e}>");
                                    }
                                }

                                match storage.get_step_logs(&execution_id).await {
                                    Ok(logs) => {
                                        if logs.is_empty() {
                                            println!("\nStep logs: <none>");
                                        } else {
                                            println!("\nStep logs:");
                                            for log in logs {
                                                println!(
                                                    "  [{}] {} ({})",
                                                    log.step_index, log.step_name, log.result_type
                                                );
                                                if let Some(step_id) = log.step_id.as_ref() {
                                                    println!("    step_id: {step_id}");
                                                }
                                                if let Some(step_kind) = log.step_kind.as_ref() {
                                                    println!("    step_kind: {step_kind}");
                                                }
                                                if let Some(code) = log.error_code.as_ref() {
                                                    println!("    error_code: {code}");
                                                }
                                            }
                                        }
                                    }
                                    Err(e) => {
                                        println!("\nStep logs: <error: {e}>");
                                    }
                                }
                            }
                        }
                        Ok(None) => {
                            eprintln!("No workflow execution found with ID: {}", execution_id);
                        }
                        Err(e) => {
                            eprintln!("Failed to query workflow: {e}");
                        }
                    }

                    if let Err(e) = storage.shutdown().await {
                        tracing::warn!("Failed to shutdown storage cleanly: {e}");
                    }
                }
            }
        }

        Some(Commands::Status {
            health,
            format,
            domain,
            agent,
            pane_id,
            bookmark,
            bookmark_tag,
        }) => {
            let watcher_status = {
                #[cfg(unix)]
                {
                    let client = wa_core::ipc::IpcClient::new(&layout.ipc_socket_path);
                    match client.status().await {
                        Ok(response) => {
                            if response.ok {
                                Ok(response.data)
                            } else {
                                Err(response
                                    .error
                                    .unwrap_or_else(|| "unknown watcher error".to_string()))
                            }
                        }
                        Err(err) => Err(err.to_string()),
                    }
                }
                #[cfg(not(unix))]
                {
                    Ok(None)
                }
            };

            if health {
                // Health check mode: JSON status including runtime health snapshot
                let wezterm = wa_core::wezterm::default_wezterm_handle();
                let mut payload = serde_json::json!({
                    "status": "ok",
                    "version": wa_core::VERSION,
                    "wezterm_circuit": wezterm.circuit_status(),
                });
                #[cfg(feature = "vendored")]
                {
                    let local_version = wa_core::vendored::read_local_wezterm_version();
                    let compat = wa_core::vendored::compatibility_report(local_version.as_ref());
                    payload["vendored_compatibility"] =
                        serde_json::to_value(&compat).unwrap_or(serde_json::Value::Null);
                }
                match watcher_status {
                    Ok(Some(status)) => {
                        payload["watcher_running"] = serde_json::Value::Bool(true);
                        if let Some(health_value) = status.get("health") {
                            payload["health"] = health_value.clone();
                        }
                        payload["watcher"] = status;
                    }
                    Ok(None) => {
                        payload["watcher_running"] = serde_json::Value::Bool(false);
                    }
                    Err(err) => {
                        payload["watcher_running"] = serde_json::Value::Bool(false);
                        payload["watcher_error"] = serde_json::Value::String(err);
                    }
                }
                if let Some(crash) = wa_core::crash::latest_crash_bundle(&layout.crash_dir) {
                    let mut crash_info = serde_json::json!({
                        "bundle_path": crash.path.display().to_string(),
                    });
                    if let Some(ref report) = crash.report {
                        crash_info["message"] = serde_json::Value::String(report.message.clone());
                        crash_info["timestamp"] =
                            serde_json::Value::Number(report.timestamp.into());
                        if let Some(ref loc) = report.location {
                            crash_info["location"] = serde_json::Value::String(loc.clone());
                        }
                    }
                    if let Some(ref manifest) = crash.manifest {
                        crash_info["created_at"] =
                            serde_json::Value::String(manifest.created_at.clone());
                    }
                    payload["latest_crash"] = crash_info;
                }
                println!(
                    "{}",
                    serde_json::to_string(&payload).unwrap_or_else(|_| "{}".to_string())
                );
            } else {
                // Rich status mode: pane table + health summary
                use wa_core::output::{
                    HealthSnapshotRenderer, OutputFormat, PaneTableRenderer, RenderContext,
                    detect_format,
                };

                let output_format = match format.to_lowercase().as_str() {
                    "json" => OutputFormat::Json,
                    "plain" => OutputFormat::Plain,
                    _ => detect_format(),
                };

                let watcher_health = watcher_status
                    .ok()
                    .and_then(|status| status)
                    .and_then(|status| status.get("health").cloned())
                    .and_then(|value| {
                        serde_json::from_value::<wa_core::crash::HealthSnapshot>(value).ok()
                    })
                    .or_else(wa_core::crash::HealthSnapshot::get_global);

                let bookmark_pane_ids = if bookmark.is_some() || bookmark_tag.is_some() {
                    let db_path = layout.db_path.to_string_lossy();
                    let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                        Ok(storage) => storage,
                        Err(e) => {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "Failed to open storage: {}", "version": "{}"}}"#,
                                    e,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: Failed to open storage: {e}");
                                eprintln!("Is the database initialized? Run 'wa watch' first.");
                            }
                            std::process::exit(1);
                        }
                    };

                    let resolved = match resolve_bookmark_pane_ids(
                        &storage,
                        bookmark.as_deref(),
                        bookmark_tag.as_deref(),
                    )
                    .await
                    {
                        Ok(ids) => ids,
                        Err(err) => {
                            if output_format.is_json() {
                                println!(
                                    r#"{{"ok": false, "error": "{}", "version": "{}"}}"#,
                                    err,
                                    wa_core::VERSION
                                );
                            } else {
                                eprintln!("Error: {err}");
                            }
                            std::process::exit(1);
                        }
                    };

                    if let Err(e) = storage.shutdown().await {
                        tracing::warn!("Failed to shutdown storage cleanly: {e}");
                    }

                    resolved
                } else {
                    None
                };

                let wezterm = wa_core::wezterm::default_wezterm_handle();
                match wezterm.list_panes().await {
                    Ok(panes) => {
                        let filter = &config.ingest.panes;

                        // Convert to PaneRecord format for rendering
                        #[allow(clippy::cast_possible_truncation)]
                        let now = std::time::SystemTime::now()
                            .duration_since(std::time::UNIX_EPOCH)
                            .unwrap_or_default()
                            .as_millis() as i64;

                        let mut records: Vec<wa_core::storage::PaneRecord> = panes
                            .iter()
                            .filter_map(|p| {
                                let pane_domain = p.inferred_domain();
                                let pane_title = p.title.as_deref().unwrap_or("");
                                let pane_cwd = p.cwd.as_deref().unwrap_or("");

                                // Apply filters
                                if let Some(ref filter_pane_id) = pane_id {
                                    if p.pane_id != *filter_pane_id {
                                        return None;
                                    }
                                }

                                if let Some(ref domain_filter) = domain {
                                    if !glob_match(domain_filter, &pane_domain) {
                                        return None;
                                    }
                                }

                                if let Some(ref bookmark_filters) = bookmark_pane_ids {
                                    if !bookmark_filters.contains(&p.pane_id) {
                                        return None;
                                    }
                                }

                                if let Some(ref agent_filter) = agent {
                                    let title_lower = pane_title.to_lowercase();
                                    let filter_lower = agent_filter.to_lowercase();
                                    let matches = match filter_lower.as_str() {
                                        "codex" => {
                                            title_lower.contains("codex")
                                                || title_lower.contains("openai")
                                        }
                                        "claude_code" | "claude" => title_lower.contains("claude"),
                                        "gemini" => title_lower.contains("gemini"),
                                        _ => title_lower.contains(&filter_lower),
                                    };
                                    if !matches {
                                        return None;
                                    }
                                }

                                let ignore_reason =
                                    filter.check_pane(&pane_domain, pane_title, pane_cwd);

                                Some(wa_core::storage::PaneRecord {
                                    pane_id: p.pane_id,
                                    pane_uuid: None,
                                    domain: pane_domain,
                                    window_id: Some(p.window_id),
                                    tab_id: Some(p.tab_id),
                                    title: p.title.clone(),
                                    cwd: p.cwd.clone(),
                                    tty_name: p.tty_name.clone(),
                                    first_seen_at: now,
                                    last_seen_at: now,
                                    observed: ignore_reason.is_none(),
                                    ignore_reason,
                                    last_decision_at: None,
                                })
                            })
                            .collect();

                        // Sort by pane_id for deterministic output
                        records.sort_by_key(|r| r.pane_id);

                        let ctx = RenderContext::new(output_format).verbose(cli.verbose);
                        let output = PaneTableRenderer::render(&records, &ctx);
                        print!("{output}");

                        // Append health snapshot if daemon is running
                        if let Some(snapshot) = watcher_health {
                            if output_format.is_json() {
                                // In JSON mode, print as separate object
                                let health_json = HealthSnapshotRenderer::render(&snapshot, &ctx);
                                print!("{health_json}");
                            } else {
                                // In text mode, append compact health line
                                println!();
                                let health_output =
                                    HealthSnapshotRenderer::render_compact(&snapshot, &ctx);
                                print!("{health_output}");
                            }
                        }

                        // Show latest crash bundle if any
                        if let Some(crash) = wa_core::crash::latest_crash_bundle(&layout.crash_dir)
                        {
                            if !output_format.is_json() {
                                println!();
                                let msg = crash
                                    .report
                                    .as_ref()
                                    .map(|r| r.message.as_str())
                                    .unwrap_or("unknown");
                                let path = crash.path.display();
                                println!("Last crash: {msg}");
                                println!("  Bundle: {path}");
                            }
                        }

                        match wa_core::backup::scheduled_backup_status(
                            &config.backup.scheduled,
                            &workspace_root,
                            chrono::Local::now(),
                        ) {
                            Ok(status) => {
                                if output_format.is_json() {
                                    let payload = serde_json::json!({ "scheduled_backup": status });
                                    println!(
                                        "{}",
                                        serde_json::to_string(&payload)
                                            .unwrap_or_else(|_| "{}".to_string())
                                    );
                                } else {
                                    println!();
                                    if status.enabled {
                                        println!("Scheduled backup: enabled ({})", status.schedule);
                                        if let Some(last) = status.last_backup_at.as_ref() {
                                            let size = status
                                                .last_backup_size_bytes
                                                .map(format_bytes_compact)
                                                .unwrap_or_else(|| "<unknown>".to_string());
                                            println!("  Last backup: {last} ({size})");
                                        } else {
                                            println!("  Last backup: <none>");
                                        }
                                        if let Some(next) = status.next_backup_at.as_ref() {
                                            println!("  Next backup: {next}");
                                        }
                                        match status.max_backups {
                                            Some(max) => println!(
                                                "  Backups kept: {}/{}",
                                                status.backups_kept, max
                                            ),
                                            None => {
                                                println!("  Backups kept: {}", status.backups_kept);
                                            }
                                        }
                                        println!("  Destination: {}", status.destination);
                                    } else {
                                        println!("Scheduled backup: disabled");
                                        println!("  Destination: {}", status.destination);
                                    }
                                }
                            }
                            Err(err) => {
                                tracing::warn!(error = %err, "Failed to load scheduled backup status");
                            }
                        }
                    }
                    Err(e) => {
                        if let wa_core::Error::Wezterm(
                            wa_core::error::WeztermError::CircuitOpen { retry_after_ms },
                        ) = &e
                        {
                            if output_format.is_json() {
                                let payload = serde_json::json!({
                                    "ok": false,
                                    "error": format!(
                                        "WezTerm circuit breaker open; retry in {retry_after_ms} ms"
                                    ),
                                    "circuit": wezterm.circuit_status(),
                                    "version": wa_core::VERSION,
                                });
                                println!(
                                    "{}",
                                    serde_json::to_string(&payload)
                                        .unwrap_or_else(|_| "{}".to_string())
                                );
                            } else {
                                eprintln!(
                                    "Error: WezTerm circuit breaker open; retry in {retry_after_ms} ms."
                                );
                                eprintln!("Is WezTerm running and responsive?");
                            }
                            std::process::exit(1);
                        }
                        if output_format.is_json() {
                            println!(
                                r#"{{"ok": false, "error": "Failed to list panes: {}", "version": "{}"}}"#,
                                e,
                                wa_core::VERSION
                            );
                        } else {
                            eprintln!("Error: Failed to list panes: {e}");
                            eprintln!("Is WezTerm running?");
                            std::process::exit(1);
                        }
                    }
                }
            }
        }

        Some(Commands::Events {
            format,
            limit,
            pane_id,
            rule_id,
            event_type,
            unhandled,
            command,
        }) => {
            use wa_core::output::{EventListRenderer, OutputFormat, RenderContext, detect_format};

            let output_format = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            let die = |msg: &str, hint: Option<&str>| -> ! {
                if output_format.is_json() {
                    let mut payload = serde_json::json!({
                        "ok": false,
                        "error": msg,
                        "version": wa_core::VERSION,
                    });
                    if let Some(h) = hint {
                        payload["hint"] = serde_json::Value::String(h.to_string());
                    }
                    println!(
                        "{}",
                        serde_json::to_string(&payload).unwrap_or_else(|_| "{}".to_string())
                    );
                } else {
                    eprintln!("Error: {msg}");
                    if let Some(h) = hint {
                        eprintln!("{h}");
                    }
                }
                std::process::exit(1);
            };

            // Get workspace layout for DB path
            let layout = match config.workspace_layout(Some(&workspace_root)) {
                Ok(l) => l,
                Err(e) => {
                    die(
                        &format!("Failed to get workspace layout: {e}"),
                        Some("Check --workspace or WA_WORKSPACE"),
                    );
                }
            };

            // Open storage handle
            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => s,
                Err(e) => {
                    die(
                        &format!("Failed to open storage: {e}"),
                        Some("Is the database initialized? Run 'wa watch' first."),
                    );
                }
            };

            // Mutating subcommands
            if let Some(cmd) = command {
                use wa_core::storage::AuditActionRecord;

                let now = now_ms_i64();

                #[derive(serde::Serialize)]
                struct EventsMutateResponse {
                    ok: bool,
                    event_id: i64,
                    #[serde(skip_serializing_if = "Option::is_none")]
                    changed: Option<bool>,
                    annotations: wa_core::storage::EventAnnotations,
                    version: &'static str,
                }

                let (event_id, changed) = match cmd {
                    EventsCommands::Annotate {
                        event_id,
                        note,
                        clear,
                        by,
                    } => {
                        if clear == note.is_some() {
                            die(
                                "Invalid annotate params: specify exactly one of --note or --clear",
                                Some("Example: wa events annotate 123 --note \"Investigating\""),
                            );
                        }

                        if let Err(e) = storage.set_event_note(event_id, note, by.clone()).await {
                            die(&format!("Failed to update note: {e}"), None);
                        }

                        let audit = AuditActionRecord {
                            id: 0,
                            ts: now,
                            actor_kind: "human".to_string(),
                            actor_id: by.clone(),
                            correlation_id: None,
                            pane_id: None,
                            domain: None,
                            action_kind: "event.annotate".to_string(),
                            policy_decision: "allow".to_string(),
                            decision_reason: Some("Human updated event note".to_string()),
                            rule_id: None,
                            input_summary: Some(if clear {
                                format!("wa events annotate {event_id} --clear")
                            } else {
                                format!("wa events annotate {event_id} --note <redacted>")
                            }),
                            verification_summary: None,
                            decision_context: None,
                            result: "success".to_string(),
                        };
                        if let Err(e) = storage.record_audit_action_redacted(audit).await {
                            tracing::warn!("Failed to record event annotation audit: {e}");
                        }

                        (event_id, None)
                    }
                    EventsCommands::Triage {
                        event_id,
                        state,
                        clear,
                        by,
                    } => {
                        if clear == state.is_some() {
                            die(
                                "Invalid triage params: specify exactly one of --state or --clear",
                                Some("Example: wa events triage 123 --state investigating"),
                            );
                        }

                        let changed = match storage
                            .set_event_triage_state(event_id, state.clone(), by.clone())
                            .await
                        {
                            Ok(v) => v,
                            Err(e) => die(&format!("Failed to update triage state: {e}"), None),
                        };

                        let audit = AuditActionRecord {
                            id: 0,
                            ts: now,
                            actor_kind: "human".to_string(),
                            actor_id: by.clone(),
                            correlation_id: None,
                            pane_id: None,
                            domain: None,
                            action_kind: "event.triage".to_string(),
                            policy_decision: "allow".to_string(),
                            decision_reason: Some("Human updated event triage state".to_string()),
                            rule_id: None,
                            input_summary: Some(if clear {
                                format!("wa events triage {event_id} --clear")
                            } else {
                                format!(
                                    "wa events triage {event_id} --state {}",
                                    state.unwrap_or_default()
                                )
                            }),
                            verification_summary: None,
                            decision_context: None,
                            result: if changed {
                                "success".to_string()
                            } else {
                                "noop".to_string()
                            },
                        };
                        if let Err(e) = storage.record_audit_action_redacted(audit).await {
                            tracing::warn!("Failed to record event triage audit: {e}");
                        }

                        (event_id, Some(changed))
                    }
                    EventsCommands::Label {
                        event_id,
                        add,
                        remove,
                        list,
                        by,
                    } => {
                        let mut ops = 0;
                        if add.is_some() {
                            ops += 1;
                        }
                        if remove.is_some() {
                            ops += 1;
                        }
                        if list {
                            ops += 1;
                        }
                        if ops != 1 {
                            die(
                                "Invalid label params: specify exactly one of --add, --remove, or --list",
                                Some("Example: wa events label 123 --add urgent"),
                            );
                        }

                        let changed = if let Some(label) = add.clone() {
                            let inserted = match storage
                                .add_event_label(event_id, label.clone(), by.clone())
                                .await
                            {
                                Ok(v) => v,
                                Err(e) => die(&format!("Failed to add label: {e}"), None),
                            };

                            let audit = AuditActionRecord {
                                id: 0,
                                ts: now,
                                actor_kind: "human".to_string(),
                                actor_id: by.clone(),
                                correlation_id: None,
                                pane_id: None,
                                domain: None,
                                action_kind: "event.label.add".to_string(),
                                policy_decision: "allow".to_string(),
                                decision_reason: Some("Human added event label".to_string()),
                                rule_id: None,
                                input_summary: Some(format!(
                                    "wa events label {event_id} --add {label}"
                                )),
                                verification_summary: None,
                                decision_context: None,
                                result: if inserted {
                                    "success".to_string()
                                } else {
                                    "noop".to_string()
                                },
                            };
                            if let Err(e) = storage.record_audit_action_redacted(audit).await {
                                tracing::warn!("Failed to record event label audit: {e}");
                            }

                            Some(inserted)
                        } else if let Some(label) = remove.clone() {
                            let removed =
                                match storage.remove_event_label(event_id, label.clone()).await {
                                    Ok(v) => v,
                                    Err(e) => die(&format!("Failed to remove label: {e}"), None),
                                };

                            let audit = AuditActionRecord {
                                id: 0,
                                ts: now,
                                actor_kind: "human".to_string(),
                                actor_id: by.clone(),
                                correlation_id: None,
                                pane_id: None,
                                domain: None,
                                action_kind: "event.label.remove".to_string(),
                                policy_decision: "allow".to_string(),
                                decision_reason: Some("Human removed event label".to_string()),
                                rule_id: None,
                                input_summary: Some(format!(
                                    "wa events label {event_id} --remove {label}"
                                )),
                                verification_summary: None,
                                decision_context: None,
                                result: if removed {
                                    "success".to_string()
                                } else {
                                    "noop".to_string()
                                },
                            };
                            if let Err(e) = storage.record_audit_action_redacted(audit).await {
                                tracing::warn!("Failed to record event label audit: {e}");
                            }

                            Some(removed)
                        } else {
                            None
                        };

                        (event_id, changed)
                    }
                };

                let annotations = match storage.get_event_annotations(event_id).await {
                    Ok(Some(a)) => a,
                    Ok(None) => die(
                        &format!("Event {event_id} not found"),
                        Some("Use 'wa events --format json' to list events and IDs."),
                    ),
                    Err(e) => die(&format!("Failed to fetch annotations: {e}"), None),
                };

                if output_format.is_json() {
                    let response = EventsMutateResponse {
                        ok: true,
                        event_id,
                        changed,
                        annotations,
                        version: wa_core::VERSION,
                    };
                    println!(
                        "{}",
                        serde_json::to_string(&response).unwrap_or_else(|_| "{}".to_string())
                    );
                } else {
                    println!("Updated event {event_id}");
                }

                return Ok(());
            }

            // Build event query
            let query = wa_core::storage::EventQuery {
                limit: Some(limit),
                pane_id,
                rule_id: rule_id.clone(),
                event_type: event_type.clone(),
                triage_state: None,
                label: None,
                unhandled_only: unhandled,
                since: None,
                until: None,
            };

            // Fetch active mutes for noise control annotations
            let now_events = now_ms_i64();
            let active_mutes = storage
                .list_active_mutes(now_events)
                .await
                .unwrap_or_default();
            let muted_keys: std::collections::HashSet<String> = active_mutes
                .iter()
                .map(|m| m.identity_key.clone())
                .collect();

            // Query events
            match storage.get_events(query).await {
                Ok(events) => {
                    let ctx = RenderContext::new(output_format)
                        .verbose(cli.verbose)
                        .limit(limit);
                    let output = EventListRenderer::render_with_noise_info(
                        &events,
                        &ctx,
                        &muted_keys,
                        active_mutes.len(),
                    );
                    print!("{output}");

                    if cli.verbose > 0 && !output_format.is_json() {
                        let display_events = if limit > 0 && events.len() > limit {
                            &events[..limit]
                        } else {
                            &events[..]
                        };
                        let clip = |s: &str, max: usize| -> String {
                            let mut out: String = s.chars().take(max).collect();
                            if s.chars().count() > max {
                                out.push_str("...");
                            }
                            out
                        };
                        let mut lines: Vec<String> = Vec::new();
                        for event in display_events {
                            match storage.get_event_annotations(event.id).await {
                                Ok(Some(annotations)) => {
                                    if annotations.triage_state.is_none()
                                        && annotations.note.is_none()
                                        && annotations.labels.is_empty()
                                    {
                                        continue;
                                    }
                                    let triage =
                                        annotations.triage_state.unwrap_or_else(|| "-".to_string());
                                    let labels = if annotations.labels.is_empty() {
                                        "-".to_string()
                                    } else {
                                        annotations.labels.join(",")
                                    };
                                    let note = annotations.note.unwrap_or_else(|| "-".to_string());
                                    lines.push(format!(
                                        "  {:>5}  {:12}  {:18}  {}",
                                        event.id,
                                        clip(&triage, 12),
                                        clip(&labels, 18),
                                        clip(&note, 48),
                                    ));
                                }
                                Ok(None) => {}
                                Err(err) => {
                                    tracing::warn!(
                                        error = %err,
                                        event_id = event.id,
                                        "Failed to load event annotations"
                                    );
                                }
                            }
                        }
                        if !lines.is_empty() {
                            println!("Annotations (verbose):");
                            println!("  event  triage        labels              note");
                            for line in lines {
                                println!("{line}");
                            }
                        }
                    }
                }
                Err(e) => {
                    die(&format!("Failed to query events: {e}"), None);
                }
            }
        }

        Some(Commands::Timeline {
            last,
            pane,
            r#type,
            format,
            limit,
        }) => {
            use wa_core::output::{OutputFormat, RenderContext, TimelineRenderer, detect_format};
            use wa_core::storage::TimelineQuery;

            let output_format = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            let die = |msg: &str, hint: Option<&str>| -> ! {
                if output_format.is_json() {
                    let mut payload = serde_json::json!({
                        "ok": false,
                        "error": msg,
                        "version": wa_core::VERSION,
                    });
                    if let Some(h) = hint {
                        payload["hint"] = serde_json::Value::String(h.to_string());
                    }
                    println!(
                        "{}",
                        serde_json::to_string(&payload).unwrap_or_else(|_| "{}".to_string())
                    );
                } else {
                    eprintln!("Error: {msg}");
                    if let Some(h) = hint {
                        eprintln!("{h}");
                    }
                }
                std::process::exit(1);
            };

            // Parse --last duration
            let duration_ms = match parse_duration_to_ms(&last) {
                Some(ms) => ms,
                None => {
                    die(
                        &format!("Invalid duration '{last}'. Use e.g. 30s, 5m, 1h, 7d, 2w."),
                        Some("Example: wa timeline --last 2h"),
                    );
                }
            };

            let now = now_ms_i64();
            let start = now - duration_ms;

            // Build timeline query
            let mut query = TimelineQuery::new()
                .with_range(start, now)
                .with_pagination(limit, 0);

            if !pane.is_empty() {
                query = query.with_panes(pane);
            }

            if !r#type.is_empty() {
                query.event_types = Some(r#type);
            }

            // Open storage
            let layout = match config.workspace_layout(Some(&workspace_root)) {
                Ok(l) => l,
                Err(e) => {
                    die(
                        &format!("Failed to get workspace layout: {e}"),
                        Some("Check --workspace or WA_WORKSPACE"),
                    );
                }
            };

            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => s,
                Err(e) => {
                    die(
                        &format!("Failed to open storage: {e}"),
                        Some("Is the database initialized? Run 'wa watch' first."),
                    );
                }
            };

            // Fetch timeline
            match storage.get_timeline(query).await {
                Ok(timeline) => {
                    let ctx = RenderContext::new(output_format).verbose(cli.verbose);
                    let rendered = TimelineRenderer::render(&timeline, &ctx);
                    print!("{rendered}");
                }
                Err(e) => {
                    die(&format!("Failed to query timeline: {e}"), None);
                }
            }
        }

        Some(Commands::Why {
            template_id,
            category,
            format,
            list,
            recent,
            pane,
            decision_id,
            limit,
        }) => {
            use wa_core::explanations::{
                format_explanation, get_explanation, list_template_ids, list_templates_by_category,
            };
            use wa_core::output::{OutputFormat, detect_format};

            let output_format = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            // --- Recent decision mode: query actual audit trail ---
            if recent || decision_id.is_some() {
                handle_why_recent(
                    &config,
                    &workspace_root,
                    output_format,
                    template_id.as_deref(),
                    pane,
                    decision_id,
                    limit,
                    cli.verbose,
                )
                .await;
                return Ok(());
            }

            // --- Template mode: static explanation lookup ---
            let should_list = list || template_id.is_none();

            if should_list {
                let mut ids: Vec<String> = category.as_deref().map_or_else(
                    || {
                        list_template_ids()
                            .into_iter()
                            .map(ToString::to_string)
                            .collect()
                    },
                    |prefix| {
                        let mut items: Vec<String> = list_templates_by_category(prefix)
                            .into_iter()
                            .map(|t| t.id.to_string())
                            .collect();
                        items.sort();
                        items
                    },
                );

                if output_format.is_json() {
                    #[derive(serde::Serialize)]
                    struct WhyListResponse {
                        ok: bool,
                        templates: Vec<String>,
                        count: usize,
                        category: Option<String>,
                        version: &'static str,
                    }

                    let response = WhyListResponse {
                        ok: true,
                        count: ids.len(),
                        templates: std::mem::take(&mut ids),
                        category,
                        version: wa_core::VERSION,
                    };
                    println!("{}", serde_json::to_string_pretty(&response)?);
                } else {
                    if let Some(prefix) = category.as_deref() {
                        println!("Templates (category={prefix}):");
                    } else {
                        println!("Available explanations:");
                    }
                    if ids.is_empty() {
                        println!("  (none)");
                    } else {
                        for id in ids {
                            println!("  - {id}");
                        }
                    }
                    println!();
                    println!("Usage: wa why <template_id>");
                    println!("       wa why --recent [denied|require_approval] [--pane <id>]");
                }
                return Ok(());
            }

            let id = template_id.unwrap_or_default();
            if let Some(template) = get_explanation(&id) {
                if output_format.is_json() {
                    #[derive(serde::Serialize)]
                    struct WhyTemplateResponse<'a> {
                        ok: bool,
                        template: &'a wa_core::explanations::ExplanationTemplate,
                        version: &'static str,
                    }

                    let response = WhyTemplateResponse {
                        ok: true,
                        template,
                        version: wa_core::VERSION,
                    };
                    println!("{}", serde_json::to_string_pretty(&response)?);
                } else {
                    let formatted = format_explanation(template, None);
                    println!("{formatted}");
                }
            } else {
                if output_format.is_json() {
                    println!(
                        r#"{{"ok": false, "error": "Unknown explanation id: {}", "hint": "Use 'wa why --list' to see available templates.", "version": "{}"}}"#,
                        id,
                        wa_core::VERSION
                    );
                } else {
                    eprintln!("Error: Unknown explanation id: {id}");
                    eprintln!("Use 'wa why --list' to see available templates.");
                }
                std::process::exit(1);
            }
        }

        Some(Commands::Stop { force, timeout }) => {
            use wa_core::lock::check_running;

            let lock_path = &layout.lock_path;

            let Some(meta) = check_running(lock_path) else {
                eprintln!("No watcher running in workspace: {}", layout.root.display());
                std::process::exit(1);
            };

            let pid = meta.pid;
            println!("Stopping watcher (pid {pid}) in {}", layout.root.display());

            #[cfg(unix)]
            {
                use std::time::{Duration, Instant};

                // Send SIGTERM via the `kill` command (no unsafe needed).
                let term_status = std::process::Command::new("kill")
                    .args(["-s", "TERM", &pid.to_string()])
                    .status();

                match term_status {
                    Ok(s) if s.success() => {}
                    Ok(s) => {
                        eprintln!(
                            "Failed to send SIGTERM to pid {pid} (exit code: {}).",
                            s.code().unwrap_or(-1)
                        );
                        eprintln!("The process may have already exited or belong to another user.");
                        std::process::exit(1);
                    }
                    Err(e) => {
                        eprintln!("Failed to run kill command: {e}");
                        std::process::exit(1);
                    }
                }

                // Wait for the lock to be released.
                let deadline = Instant::now() + Duration::from_secs(timeout);
                let mut stopped = false;
                while Instant::now() < deadline {
                    if check_running(lock_path).is_none() {
                        stopped = true;
                        break;
                    }
                    tokio::time::sleep(Duration::from_millis(200)).await;
                }

                if stopped {
                    println!("Watcher stopped gracefully (pid {pid}).");
                } else if force {
                    println!("Graceful shutdown timed out. Sending SIGKILL to pid {pid}.");
                    let kill_status = std::process::Command::new("kill")
                        .args(["-s", "KILL", &pid.to_string()])
                        .status();

                    match kill_status {
                        Ok(s) if s.success() => {}
                        Ok(_) | Err(_) => {
                            eprintln!("Failed to send SIGKILL to pid {pid}.");
                            std::process::exit(1);
                        }
                    }

                    // Wait briefly for SIGKILL to take effect.
                    tokio::time::sleep(Duration::from_millis(500)).await;
                    if check_running(lock_path).is_none() {
                        println!("Watcher killed (pid {pid}).");
                    } else {
                        eprintln!(
                            "Warning: lock still held after SIGKILL. The pid may belong to a different process."
                        );
                        std::process::exit(1);
                    }
                } else {
                    eprintln!(
                        "Graceful shutdown timed out after {timeout}s. Use --force to escalate to SIGKILL."
                    );
                    std::process::exit(1);
                }
            }

            #[cfg(not(unix))]
            {
                let _ = (force, timeout);
                eprintln!("wa stop is only supported on Unix systems.");
                std::process::exit(1);
            }
        }

        Some(Commands::Prepare { command }) => match command {
            PrepareCommands::Send {
                pane_id,
                text,
                format,
                no_paste,
                no_newline,
                wait_for,
                timeout_secs,
                wait_for_regex,
            } => {
                let output_format = resolve_prepare_output_format(&format);
                let db_path = layout.db_path.to_string_lossy();
                let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                    Ok(s) => s,
                    Err(e) => {
                        eprintln!("Error: Failed to open database: {e}");
                        eprintln!("Is the watcher running? Try: wa watch --foreground");
                        std::process::exit(1);
                    }
                };

                let workspace_id = layout.root.to_string_lossy().to_string();
                let now = now_ms_i64();

                let wezterm = wa_core::wezterm::default_wezterm_handle();
                let pane_info = match wezterm.get_pane(pane_id).await {
                    Ok(info) => info,
                    Err(e) => {
                        eprintln!("Error: Failed to query pane {pane_id}: {e}");
                        std::process::exit(1);
                    }
                };
                let domain = pane_info.inferred_domain();

                let resolution = resolve_pane_capabilities(
                    pane_id,
                    Some(&storage),
                    Some(layout.ipc_socket_path.as_path()),
                )
                .await;
                let capabilities = resolution.capabilities;

                let mut engine = wa_core::policy::PolicyEngine::new(
                    config.safety.rate_limit_per_pane,
                    config.safety.rate_limit_global,
                    config.safety.require_prompt_active,
                )
                .with_command_gate_config(config.safety.command_gate.clone())
                .with_policy_rules(config.safety.rules.clone());

                let summary = engine.redact_secrets(&text);
                let mut input = wa_core::policy::PolicyInput::new(
                    wa_core::policy::ActionKind::SendText,
                    wa_core::policy::ActorKind::Human,
                )
                .with_pane(pane_id)
                .with_domain(domain.clone())
                .with_capabilities(capabilities)
                .with_text_summary(&summary)
                .with_command_text(&text);

                if let Some(title) = &pane_info.title {
                    input = input.with_pane_title(title.clone());
                }
                if let Some(cwd) = &pane_info.cwd {
                    input = input.with_pane_cwd(cwd.clone());
                }

                let decision = engine.authorize(&input);
                let (decision, approval_request) = if decision.requires_approval() {
                    let store = wa_core::approval::ApprovalStore::new(
                        &storage,
                        config.safety.approval.clone(),
                        workspace_id.clone(),
                    );
                    let decision = match store
                        .attach_to_decision(decision, &input, Some(summary.clone()))
                        .await
                    {
                        Ok(updated) => updated,
                        Err(e) => {
                            eprintln!("Error: Failed to issue approval token: {e}");
                            std::process::exit(1);
                        }
                    };
                    let approval_request = decision.approval_request().cloned();
                    (decision, approval_request)
                } else {
                    (decision, None)
                };
                if decision.is_denied() {
                    let reason = decision.reason().unwrap_or("denied by policy");
                    eprintln!("Error: Action denied by policy: {reason}");
                    std::process::exit(1);
                }

                let plan = build_prepare_send_plan(
                    &workspace_id,
                    pane_id,
                    &text,
                    no_paste,
                    no_newline,
                    wait_for.as_deref(),
                    wait_for_regex,
                    timeout_secs,
                );
                let plan_hash = plan.compute_hash();
                let plan_id = plan.plan_id.to_string();
                let redacted_plan = redact_prepare_plan(&plan);
                let plan_json =
                    serde_json::to_string(&redacted_plan).unwrap_or_else(|_| "{}".to_string());
                let params = PreparedPlanParams::SendText {
                    pane_id,
                    no_paste,
                    no_newline,
                    wait_for: wait_for.clone(),
                    wait_for_regex,
                    timeout_secs,
                };
                let params_json = serde_json::to_string(&params).ok();
                let pane_uuid = storage
                    .get_pane(pane_id)
                    .await
                    .ok()
                    .flatten()
                    .and_then(|record| record.pane_uuid);

                let expires_at =
                    now.saturating_add(config.safety.approval.token_expiry_secs as i64 * 1000);

                let record = wa_core::storage::PreparedPlanRecord {
                    plan_id: plan_id.clone(),
                    plan_hash: plan_hash.clone(),
                    workspace_id: workspace_id.clone(),
                    action_kind: wa_core::policy::ActionKind::SendText.as_str().to_string(),
                    pane_id: Some(pane_id),
                    pane_uuid,
                    params_json,
                    plan_json,
                    requires_approval: decision.requires_approval(),
                    created_at: now,
                    expires_at,
                    consumed_at: None,
                };

                if let Err(e) = storage.insert_prepared_plan(record).await {
                    eprintln!("Error: Failed to store prepared plan: {e}");
                    std::process::exit(1);
                }

                let prepare_context = build_plan_audit_context(
                    &plan_id,
                    &plan_hash,
                    "prepare",
                    wa_core::policy::ActionKind::SendText.as_str(),
                    Some(pane_id),
                );
                let prepare_audit = wa_core::storage::AuditActionRecord {
                    id: 0,
                    ts: now,
                    actor_kind: "human".to_string(),
                    actor_id: None,
                    correlation_id: Some(plan_hash.clone()),
                    pane_id: Some(pane_id),
                    domain: Some(domain.clone()),
                    action_kind: prepare_audit_action_kind(
                        wa_core::policy::ActionKind::SendText.as_str(),
                    ),
                    policy_decision: decision.as_str().to_string(),
                    decision_reason: decision.reason().map(String::from),
                    rule_id: decision.rule_id().map(String::from),
                    input_summary: Some(summary.clone()),
                    verification_summary: None,
                    decision_context: Some(prepare_context),
                    result: "success".to_string(),
                };
                if let Err(e) = storage.record_audit_action_redacted(prepare_audit).await {
                    eprintln!("Warning: Failed to record prepare audit: {e}");
                }

                let commit_command = if let Some(approval) = &approval_request {
                    format!(
                        "wa commit {plan_id} --approval-code {} --text <TEXT>",
                        approval.allow_once_code
                    )
                } else {
                    format!("wa commit {plan_id} --text <TEXT>")
                };

                if output_format.is_json() {
                    let output = build_prepare_output(
                        &plan,
                        &plan_hash,
                        expires_at,
                        wa_core::policy::ActionKind::SendText.as_str(),
                        Some(pane_id),
                        approval_request.as_ref(),
                        commit_command,
                    );
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&output).unwrap_or_else(|_| "{}".to_string())
                    );
                } else {
                    println!("Plan prepared.");
                    println!("  plan_id: {plan_id}");
                    println!("  plan_hash: {plan_hash}");
                    println!(
                        "  expires_at: {} ({expires_at} ms)",
                        format_epoch_ms(expires_at)
                    );

                    if let Some(approval) = &approval_request {
                        println!();
                        println!("Approval required:");
                        println!("  code: {}", approval.allow_once_code);
                        println!(
                            "  expires_at: {} ({})",
                            format_epoch_ms(approval.expires_at),
                            approval.expires_at
                        );
                    }

                    println!();
                    println!("Commit:");
                    println!("  {commit_command}");

                    println!();
                    println!("Plan preview:");
                    if let Ok(pretty) = serde_json::to_string_pretty(&plan) {
                        println!("{pretty}");
                    } else {
                        println!(
                            "{}",
                            serde_json::to_string(&plan).unwrap_or_else(|_| "{}".to_string())
                        );
                    }
                }
            }
            PrepareCommands::Workflow { command } => match command {
                PrepareWorkflowCommands::Run {
                    name,
                    pane_id,
                    format,
                } => {
                    let output_format = resolve_prepare_output_format(&format);
                    let db_path = layout.db_path.to_string_lossy();
                    let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                        Ok(s) => std::sync::Arc::new(s),
                        Err(e) => {
                            eprintln!("Error: Failed to open database: {e}");
                            eprintln!("Is the watcher running? Try: wa watch --foreground");
                            std::process::exit(1);
                        }
                    };

                    let workspace_id = layout.root.to_string_lossy().to_string();
                    let now = now_ms_i64();
                    let execution_id = format!("prepare-{name}-{now}");

                    let workflow = build_workflow_by_name(&name, &config);
                    let Some(workflow) = workflow else {
                        eprintln!("Error: Workflow '{name}' not found.");
                        eprintln!("Hint: Use 'wa workflow list' to see available workflows.");
                        std::process::exit(1);
                    };

                    let plan = generate_workflow_plan(
                        &storage,
                        &workflow,
                        &workspace_id,
                        pane_id,
                        &execution_id,
                    )
                    .await;

                    let plan_hash = plan.compute_hash();
                    let plan_id = plan.plan_id.to_string();
                    let redacted_plan = redact_prepare_plan(&plan);
                    let plan_json =
                        serde_json::to_string(&redacted_plan).unwrap_or_else(|_| "{}".to_string());

                    let params = PreparedPlanParams::WorkflowRun {
                        workflow_name: name.clone(),
                        pane_id,
                    };
                    let params_json = serde_json::to_string(&params).ok();
                    let pane_uuid = storage
                        .get_pane(pane_id)
                        .await
                        .ok()
                        .flatten()
                        .and_then(|record| record.pane_uuid);

                    let mut engine = wa_core::policy::PolicyEngine::new(
                        config.safety.rate_limit_per_pane,
                        config.safety.rate_limit_global,
                        config.safety.require_prompt_active,
                    )
                    .with_command_gate_config(config.safety.command_gate.clone())
                    .with_policy_rules(config.safety.rules.clone());

                    let input = wa_core::policy::PolicyInput::new(
                        wa_core::policy::ActionKind::WorkflowRun,
                        wa_core::policy::ActorKind::Human,
                    )
                    .with_pane(pane_id)
                    .with_workflow(&name);

                    let decision = engine.authorize(&input);
                    let (decision, approval_request) = if decision.requires_approval() {
                        let store = wa_core::approval::ApprovalStore::new(
                            storage.as_ref(),
                            config.safety.approval.clone(),
                            workspace_id.clone(),
                        );
                        let decision = match store
                            .attach_to_decision(decision, &input, Some(name.clone()))
                            .await
                        {
                            Ok(updated) => updated,
                            Err(e) => {
                                eprintln!("Error: Failed to issue approval token: {e}");
                                std::process::exit(1);
                            }
                        };
                        let approval_request = decision.approval_request().cloned();
                        (decision, approval_request)
                    } else {
                        (decision, None)
                    };
                    if decision.is_denied() {
                        let reason = decision.reason().unwrap_or("denied by policy");
                        eprintln!("Error: Workflow run denied by policy: {reason}");
                        std::process::exit(1);
                    }

                    let expires_at =
                        now.saturating_add(config.safety.approval.token_expiry_secs as i64 * 1000);
                    let record = wa_core::storage::PreparedPlanRecord {
                        plan_id: plan_id.clone(),
                        plan_hash: plan_hash.clone(),
                        workspace_id: workspace_id.clone(),
                        action_kind: wa_core::policy::ActionKind::WorkflowRun
                            .as_str()
                            .to_string(),
                        pane_id: Some(pane_id),
                        pane_uuid,
                        params_json,
                        plan_json,
                        requires_approval: decision.requires_approval(),
                        created_at: now,
                        expires_at,
                        consumed_at: None,
                    };

                    if let Err(e) = storage.insert_prepared_plan(record).await {
                        eprintln!("Error: Failed to store prepared plan: {e}");
                        std::process::exit(1);
                    }

                    let prepare_context = build_plan_audit_context(
                        &plan_id,
                        &plan_hash,
                        "prepare",
                        wa_core::policy::ActionKind::WorkflowRun.as_str(),
                        Some(pane_id),
                    );
                    let prepare_audit = wa_core::storage::AuditActionRecord {
                        id: 0,
                        ts: now,
                        actor_kind: "human".to_string(),
                        actor_id: None,
                        correlation_id: Some(plan_hash.clone()),
                        pane_id: Some(pane_id),
                        domain: None,
                        action_kind: prepare_audit_action_kind(
                            wa_core::policy::ActionKind::WorkflowRun.as_str(),
                        ),
                        policy_decision: decision.as_str().to_string(),
                        decision_reason: decision.reason().map(String::from),
                        rule_id: decision.rule_id().map(String::from),
                        input_summary: Some(format!("workflow={name}")),
                        verification_summary: None,
                        decision_context: Some(prepare_context),
                        result: "success".to_string(),
                    };
                    if let Err(e) = storage.record_audit_action_redacted(prepare_audit).await {
                        eprintln!("Warning: Failed to record prepare audit: {e}");
                    }

                    let commit_command = if let Some(approval) = &approval_request {
                        format!(
                            "wa commit {plan_id} --approval-code {}",
                            approval.allow_once_code
                        )
                    } else {
                        format!("wa commit {plan_id}")
                    };

                    if output_format.is_json() {
                        let output = build_prepare_output(
                            &plan,
                            &plan_hash,
                            expires_at,
                            wa_core::policy::ActionKind::WorkflowRun.as_str(),
                            Some(pane_id),
                            approval_request.as_ref(),
                            commit_command,
                        );
                        println!(
                            "{}",
                            serde_json::to_string_pretty(&output)
                                .unwrap_or_else(|_| "{}".to_string())
                        );
                    } else {
                        println!("Plan prepared.");
                        println!("  plan_id: {plan_id}");
                        println!("  plan_hash: {plan_hash}");
                        println!(
                            "  expires_at: {} ({expires_at} ms)",
                            format_epoch_ms(expires_at)
                        );

                        if let Some(approval) = &approval_request {
                            println!();
                            println!("Approval required:");
                            println!("  code: {}", approval.allow_once_code);
                            println!(
                                "  expires_at: {} ({})",
                                format_epoch_ms(approval.expires_at),
                                approval.expires_at
                            );
                        }

                        println!();
                        println!("Commit:");
                        println!("  {commit_command}");

                        println!();
                        println!("Plan preview:");
                        if let Ok(pretty) = serde_json::to_string_pretty(&plan) {
                            println!("{pretty}");
                        } else {
                            println!(
                                "{}",
                                serde_json::to_string(&plan).unwrap_or_else(|_| "{}".to_string())
                            );
                        }
                    }
                }
            },
        },

        Some(Commands::Commit {
            plan_id,
            text,
            text_file,
            approval_code,
        }) => {
            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => std::sync::Arc::new(s),
                Err(e) => {
                    eprintln!("Error: Failed to open database: {e}");
                    eprintln!("Is the watcher running? Try: wa watch --foreground");
                    std::process::exit(1);
                }
            };

            let workspace_id = layout.root.to_string_lossy().to_string();
            let now = now_ms_i64();

            if text.is_some() && text_file.is_some() {
                eprintln!("Error: Provide only one of --text or --text-file.");
                std::process::exit(1);
            }

            let commit_text = if let Some(path) = text_file.as_ref() {
                match std::fs::read_to_string(path) {
                    Ok(contents) => Some(contents),
                    Err(e) => {
                        eprintln!("Error: Failed to read text file {}: {e}", path.display());
                        std::process::exit(1);
                    }
                }
            } else {
                text.clone()
            };

            let existing = match storage.get_prepared_plan(&plan_id).await {
                Ok(record) => record,
                Err(e) => {
                    eprintln!("Error: Failed to load prepared plan: {e}");
                    std::process::exit(1);
                }
            };

            let record = match require_prepared_plan(existing) {
                Ok(record) => record,
                Err(err) => exit_on_commit_validation_error(err, &plan_id),
            };

            if let Err(err) = validate_prepared_plan_record(&record, &workspace_id, now) {
                exit_on_commit_validation_error(err, &plan_id);
            }

            let params = match parse_prepared_plan_params(&record) {
                Ok(params) => params,
                Err(err) => exit_on_commit_validation_error(err, &plan_id),
            };

            match params {
                PreparedPlanParams::SendText {
                    pane_id,
                    no_paste,
                    no_newline,
                    wait_for,
                    wait_for_regex,
                    timeout_secs,
                } => {
                    if let Err(err) =
                        ensure_action_kind(&record, wa_core::policy::ActionKind::SendText.as_str())
                    {
                        exit_on_commit_validation_error(err, &plan_id);
                    }
                    let Some(text) = commit_text else {
                        eprintln!("Error: --text or --text-file is required for send_text plans.");
                        std::process::exit(1);
                    };

                    let current = storage.get_pane(pane_id).await.ok().flatten();
                    let current_uuid = current.and_then(|pane| pane.pane_uuid);
                    if let Err(err) = ensure_pane_uuid_matches(
                        record.pane_uuid.as_deref(),
                        current_uuid.as_deref(),
                    ) {
                        exit_on_commit_validation_error(err, &plan_id);
                    }

                    let plan = build_prepare_send_plan(
                        &workspace_id,
                        pane_id,
                        &text,
                        no_paste,
                        no_newline,
                        wait_for.as_deref(),
                        wait_for_regex,
                        timeout_secs,
                    );
                    let plan_hash = plan.compute_hash();
                    let correlation_id = plan_hash.clone();
                    let commit_context = build_plan_audit_context(
                        &plan_id,
                        &plan_hash,
                        "commit",
                        wa_core::policy::ActionKind::SendText.as_str(),
                        Some(pane_id),
                    );
                    if let Err(err) = ensure_plan_hash(&record.plan_hash, &plan_hash) {
                        exit_on_commit_validation_error(err, &plan_id);
                    }

                    let wezterm = wa_core::wezterm::default_wezterm_handle();
                    let pane_info = match wezterm.get_pane(pane_id).await {
                        Ok(info) => info,
                        Err(e) => {
                            eprintln!("Error: Failed to query pane {pane_id}: {e}");
                            std::process::exit(1);
                        }
                    };
                    let domain = pane_info.inferred_domain();

                    let resolution = resolve_pane_capabilities(
                        pane_id,
                        Some(storage.as_ref()),
                        Some(layout.ipc_socket_path.as_path()),
                    )
                    .await;
                    let capabilities = resolution.capabilities;

                    let mut engine = wa_core::policy::PolicyEngine::new(
                        config.safety.rate_limit_per_pane,
                        config.safety.rate_limit_global,
                        config.safety.require_prompt_active,
                    )
                    .with_command_gate_config(config.safety.command_gate.clone())
                    .with_policy_rules(config.safety.rules.clone());

                    let summary = engine.redact_secrets(&text);
                    let mut input = wa_core::policy::PolicyInput::new(
                        wa_core::policy::ActionKind::SendText,
                        wa_core::policy::ActorKind::Human,
                    )
                    .with_pane(pane_id)
                    .with_domain(domain.clone())
                    .with_capabilities(capabilities)
                    .with_text_summary(&summary)
                    .with_command_text(&text);
                    if let Some(title) = &pane_info.title {
                        input = input.with_pane_title(title.clone());
                    }
                    if let Some(cwd) = &pane_info.cwd {
                        input = input.with_pane_cwd(cwd.clone());
                    }

                    let mut decision = engine.authorize(&input);
                    if decision.requires_approval() {
                        let Some(code) = approval_code.as_deref() else {
                            eprintln!("Error: Approval required (E_PLAN_APPROVAL_MISSING).");
                            eprintln!("Hint: Use --approval-code from wa prepare.");
                            std::process::exit(1);
                        };
                        let store = wa_core::approval::ApprovalStore::new(
                            storage.as_ref(),
                            config.safety.approval.clone(),
                            workspace_id.clone(),
                        );
                        let approval_context = wa_core::approval::ApprovalAuditContext {
                            correlation_id: Some(correlation_id.clone()),
                            decision_context: Some(build_plan_audit_context(
                                &plan_id,
                                &plan_hash,
                                "approval",
                                wa_core::policy::ActionKind::SendText.as_str(),
                                Some(pane_id),
                            )),
                        };
                        match store
                            .consume_with_context(code, &input, Some(approval_context))
                            .await
                        {
                            Ok(Some(_)) => {
                                decision = wa_core::policy::PolicyDecision::allow_with_rule(
                                    "approval.allow_once",
                                );
                            }
                            Ok(None) => {
                                eprintln!("Error: Invalid or expired approval code.");
                                std::process::exit(1);
                            }
                            Err(e) => {
                                eprintln!("Error: Failed to consume approval: {e}");
                                std::process::exit(1);
                            }
                        }
                    } else if decision.is_denied() {
                        eprintln!("Error: Action denied by policy.");
                        std::process::exit(1);
                    }

                    match storage.consume_prepared_plan(&plan_id, now).await {
                        Ok(Some(_)) => {}
                        Ok(None) => {
                            eprintln!("Error: Plan already consumed or expired.");
                            std::process::exit(1);
                        }
                        Err(e) => {
                            eprintln!("Error: Failed to consume prepared plan: {e}");
                            std::process::exit(1);
                        }
                    }

                    let send_result = wezterm
                        .send_text_with_options(pane_id, &text, no_paste, no_newline)
                        .await;

                    let decision_for_audit = decision.clone();
                    let injection = match send_result {
                        Ok(()) => wa_core::policy::InjectionResult::Allowed {
                            decision,
                            summary: summary.clone(),
                            pane_id,
                            action: wa_core::policy::ActionKind::SendText,
                            audit_action_id: None,
                        },
                        Err(e) => wa_core::policy::InjectionResult::Error {
                            error: e.to_string(),
                            pane_id,
                            action: wa_core::policy::ActionKind::SendText,
                            audit_action_id: None,
                        },
                    };

                    let mut audit_record = injection.to_audit_record(
                        wa_core::policy::ActorKind::Human,
                        None,
                        Some(domain.clone()),
                    );
                    audit_record.correlation_id = Some(correlation_id.clone());
                    audit_record.input_summary = Some(
                        wa_core::policy::build_send_text_audit_summary(&text, None, None),
                    );
                    if let Err(e) = storage.record_audit_action_redacted(audit_record).await {
                        tracing::warn!(pane_id, "Failed to record audit: {e}");
                    }

                    let send_error = injection
                        .error_message()
                        .map(|message| format!("send_error={message}"));
                    let mut wait_summary: Option<String> = None;

                    if injection.is_allowed() {
                        if let Some(pattern) = &wait_for {
                            let matcher = if wait_for_regex {
                                match fancy_regex::Regex::new(pattern) {
                                    Ok(compiled) => {
                                        Some(wa_core::wezterm::WaitMatcher::regex(compiled))
                                    }
                                    Err(e) => {
                                        eprintln!("Warning: Invalid wait-for regex: {e}");
                                        None
                                    }
                                }
                            } else {
                                Some(wa_core::wezterm::WaitMatcher::substring(pattern))
                            };

                            if let Some(matcher) = matcher {
                                let options = wa_core::wezterm::WaitOptions {
                                    tail_lines: 200,
                                    escapes: false,
                                    ..wa_core::wezterm::WaitOptions::default()
                                };
                                let source = wa_core::wezterm::WeztermHandleSource::new(
                                    Arc::clone(&wezterm),
                                );
                                let waiter = wa_core::wezterm::PaneWaiter::new(&source)
                                    .with_options(options);
                                let timeout = std::time::Duration::from_secs(timeout_secs);
                                match waiter.wait_for(pane_id, &matcher, timeout).await {
                                    Ok(wa_core::wezterm::WaitResult::Matched { .. }) => {
                                        println!("Commit succeeded (wait-for matched).");
                                        wait_summary = Some("wait_for=matched".to_string());
                                    }
                                    Ok(wa_core::wezterm::WaitResult::TimedOut { .. }) => {
                                        eprintln!("Commit succeeded but wait-for timed out.");
                                        wait_summary = Some("wait_for=timed_out".to_string());
                                    }
                                    Err(e) => {
                                        eprintln!("Commit succeeded but wait-for failed: {e}");
                                        wait_summary = Some(format!("wait_for=error:{e}"));
                                    }
                                }
                            }
                        } else {
                            println!("Commit succeeded.");
                        }
                    } else {
                        eprintln!("Commit failed: send denied or errored.");
                    }

                    let commit_verification = wait_summary.or(send_error);
                    let commit_result = if injection.is_allowed() {
                        "success"
                    } else {
                        "failed"
                    };
                    let commit_audit = wa_core::storage::AuditActionRecord {
                        id: 0,
                        ts: now,
                        actor_kind: "human".to_string(),
                        actor_id: None,
                        correlation_id: Some(correlation_id.clone()),
                        pane_id: Some(pane_id),
                        domain: Some(domain.clone()),
                        action_kind: commit_audit_action_kind(
                            wa_core::policy::ActionKind::SendText.as_str(),
                        ),
                        policy_decision: decision_for_audit.as_str().to_string(),
                        decision_reason: decision_for_audit.reason().map(String::from),
                        rule_id: decision_for_audit.rule_id().map(String::from),
                        input_summary: Some(summary.clone()),
                        verification_summary: commit_verification,
                        decision_context: Some(commit_context),
                        result: commit_result.to_string(),
                    };
                    if let Err(e) = storage.record_audit_action_redacted(commit_audit).await {
                        tracing::warn!(pane_id, "Failed to record commit audit: {e}");
                    }

                    if !injection.is_allowed() {
                        std::process::exit(1);
                    }
                }
                PreparedPlanParams::WorkflowRun {
                    workflow_name,
                    pane_id,
                } => {
                    if let Err(err) = ensure_action_kind(
                        &record,
                        wa_core::policy::ActionKind::WorkflowRun.as_str(),
                    ) {
                        exit_on_commit_validation_error(err, &plan_id);
                    }
                    let current = storage.get_pane(pane_id).await.ok().flatten();
                    let current_uuid = current.and_then(|pane| pane.pane_uuid);
                    if let Err(err) = ensure_pane_uuid_matches(
                        record.pane_uuid.as_deref(),
                        current_uuid.as_deref(),
                    ) {
                        exit_on_commit_validation_error(err, &plan_id);
                    }

                    let workflow = build_workflow_by_name(&workflow_name, &config);
                    let Some(workflow) = workflow else {
                        eprintln!("Error: Workflow '{workflow_name}' not found.");
                        eprintln!("Hint: Use 'wa workflow list' to see available workflows.");
                        std::process::exit(1);
                    };

                    let execution_id = format!("commit-{workflow_name}-{now}");
                    let plan = generate_workflow_plan(
                        &storage,
                        &workflow,
                        &workspace_id,
                        pane_id,
                        &execution_id,
                    )
                    .await;
                    let plan_hash = plan.compute_hash();
                    let correlation_id = plan_hash.clone();
                    let commit_context = build_plan_audit_context(
                        &plan_id,
                        &plan_hash,
                        "commit",
                        wa_core::policy::ActionKind::WorkflowRun.as_str(),
                        Some(pane_id),
                    );
                    if let Err(err) = ensure_plan_hash(&record.plan_hash, &plan_hash) {
                        exit_on_commit_validation_error(err, &plan_id);
                    }

                    let mut engine = wa_core::policy::PolicyEngine::new(
                        config.safety.rate_limit_per_pane,
                        config.safety.rate_limit_global,
                        config.safety.require_prompt_active,
                    )
                    .with_command_gate_config(config.safety.command_gate.clone())
                    .with_policy_rules(config.safety.rules.clone());

                    let input = wa_core::policy::PolicyInput::new(
                        wa_core::policy::ActionKind::WorkflowRun,
                        wa_core::policy::ActorKind::Human,
                    )
                    .with_pane(pane_id)
                    .with_workflow(&workflow_name);

                    let mut decision = engine.authorize(&input);
                    if decision.requires_approval() {
                        let Some(code) = approval_code.as_deref() else {
                            eprintln!("Error: Approval required (E_PLAN_APPROVAL_MISSING).");
                            eprintln!("Hint: Use --approval-code from wa prepare.");
                            std::process::exit(1);
                        };
                        let store = wa_core::approval::ApprovalStore::new(
                            storage.as_ref(),
                            config.safety.approval.clone(),
                            workspace_id.clone(),
                        );
                        let approval_context = wa_core::approval::ApprovalAuditContext {
                            correlation_id: Some(correlation_id.clone()),
                            decision_context: Some(build_plan_audit_context(
                                &plan_id,
                                &plan_hash,
                                "approval",
                                wa_core::policy::ActionKind::WorkflowRun.as_str(),
                                Some(pane_id),
                            )),
                        };
                        match store
                            .consume_with_context(code, &input, Some(approval_context))
                            .await
                        {
                            Ok(Some(_)) => {
                                decision = wa_core::policy::PolicyDecision::allow_with_rule(
                                    "approval.allow_once",
                                );
                            }
                            Ok(None) => {
                                eprintln!("Error: Invalid or expired approval code.");
                                std::process::exit(1);
                            }
                            Err(e) => {
                                eprintln!("Error: Failed to consume approval: {e}");
                                std::process::exit(1);
                            }
                        }
                    } else if decision.is_denied() {
                        eprintln!("Error: Workflow run denied by policy.");
                        std::process::exit(1);
                    }

                    match storage.consume_prepared_plan(&plan_id, now).await {
                        Ok(Some(_)) => {}
                        Ok(None) => {
                            eprintln!("Error: Plan already consumed or expired.");
                            std::process::exit(1);
                        }
                        Err(e) => {
                            eprintln!("Error: Failed to consume prepared plan: {e}");
                            std::process::exit(1);
                        }
                    }

                    let engine = wa_core::workflows::WorkflowEngine::new(10);
                    let lock_manager =
                        std::sync::Arc::new(wa_core::workflows::PaneWorkflowLockManager::new());
                    let policy_engine = wa_core::policy::PolicyEngine::new(
                        config.safety.rate_limit_per_pane,
                        config.safety.rate_limit_global,
                        true,
                    );
                    let wezterm_handle = wa_core::wezterm::default_wezterm_handle();
                    let injector = std::sync::Arc::new(tokio::sync::Mutex::new(
                        wa_core::policy::PolicyGatedInjector::with_storage(
                            policy_engine,
                            wezterm_handle,
                            storage.as_ref().clone(),
                        ),
                    ));
                    let runner_config = wa_core::workflows::WorkflowRunnerConfig::default();
                    let runner = wa_core::workflows::WorkflowRunner::new(
                        engine,
                        lock_manager,
                        std::sync::Arc::clone(&storage),
                        injector,
                        runner_config,
                    );

                    runner.register_workflow(std::sync::Arc::new(
                        wa_core::workflows::HandleCompaction::new()
                            .with_prompt_config(config.workflows.compaction_prompts.clone()),
                    ));
                    runner.register_workflow(std::sync::Arc::new(
                        wa_core::workflows::HandleUsageLimits::new(),
                    ));
                    runner.register_workflow(std::sync::Arc::new(
                        wa_core::workflows::HandleSessionEnd::new(),
                    ));
                    runner.register_workflow(std::sync::Arc::new(
                        wa_core::workflows::HandleAuthRequired::new(),
                    ));
                    runner.register_workflow(std::sync::Arc::new(
                        wa_core::workflows::HandleClaudeCodeLimits::new(),
                    ));
                    runner.register_workflow(std::sync::Arc::new(
                        wa_core::workflows::HandleGeminiQuota::new(),
                    ));

                    println!("Workflow: {} ({})", workflow.name(), workflow.description());
                    println!("Target pane: {pane_id}");
                    println!("Steps: {}", workflow.step_count());
                    println!();

                    let run_start = std::time::Instant::now();
                    let result = runner
                        .run_workflow(pane_id, workflow, &execution_id, 0)
                        .await;
                    let elapsed = run_start.elapsed();

                    let (commit_result, commit_verification, exit_code) = match result {
                        wa_core::workflows::WorkflowExecutionResult::Completed {
                            steps_executed,
                            ..
                        } => {
                            println!(
                                "Commit completed ({} step(s) in {:.1}s)",
                                steps_executed,
                                elapsed.as_secs_f64()
                            );
                            println!("Execution ID: {execution_id}");
                            (
                                "success",
                                Some(format!("steps_executed={steps_executed}")),
                                None,
                            )
                        }
                        wa_core::workflows::WorkflowExecutionResult::Aborted {
                            reason,
                            step_index,
                            ..
                        } => {
                            eprintln!("Commit aborted at step {step_index}");
                            eprintln!("Reason: {reason}");
                            eprintln!("Execution ID: {execution_id}");
                            eprintln!(
                                "\nHint: Use 'wa workflow status {execution_id}' for details."
                            );
                            (
                                "failed",
                                Some(format!("aborted step={step_index} reason={reason}")),
                                Some(1),
                            )
                        }
                        wa_core::workflows::WorkflowExecutionResult::PolicyDenied {
                            reason,
                            step_index,
                            ..
                        } => {
                            eprintln!("Commit denied by policy at step {step_index}");
                            eprintln!("Reason: {reason}");
                            eprintln!("Execution ID: {execution_id}");
                            (
                                "denied",
                                Some(format!("policy_denied step={step_index} reason={reason}")),
                                Some(1),
                            )
                        }
                        wa_core::workflows::WorkflowExecutionResult::Error { error, .. } => {
                            eprintln!("Commit failed: {error}");
                            eprintln!("Execution ID: {execution_id}");
                            ("failed", Some(format!("error={error}")), Some(1))
                        }
                    };

                    let commit_audit = wa_core::storage::AuditActionRecord {
                        id: 0,
                        ts: now,
                        actor_kind: "human".to_string(),
                        actor_id: None,
                        correlation_id: Some(correlation_id.clone()),
                        pane_id: Some(pane_id),
                        domain: None,
                        action_kind: commit_audit_action_kind(
                            wa_core::policy::ActionKind::WorkflowRun.as_str(),
                        ),
                        policy_decision: decision.as_str().to_string(),
                        decision_reason: decision.reason().map(String::from),
                        rule_id: decision.rule_id().map(String::from),
                        input_summary: Some(format!("workflow={workflow_name}")),
                        verification_summary: commit_verification,
                        decision_context: Some(commit_context),
                        result: commit_result.to_string(),
                    };
                    if let Err(e) = storage.record_audit_action_redacted(commit_audit).await {
                        tracing::warn!(pane_id, "Failed to record commit audit: {e}");
                    }

                    if let Some(code) = exit_code {
                        std::process::exit(code);
                    }

                    if let Err(e) = storage.shutdown().await {
                        tracing::warn!("Failed to shutdown storage cleanly: {e}");
                    }
                }
            }
        }

        Some(Commands::Approve {
            code,
            pane,
            fingerprint,
            dry_run,
        }) => {
            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => s,
                Err(e) => {
                    eprintln!("Error: Failed to open database: {e}");
                    eprintln!("Is the watcher running? Try: wa watch --foreground");
                    std::process::exit(1);
                }
            };
            let workspace_id = layout.root.to_string_lossy().to_string();
            let now_ms = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .map_or(0, |d| d.as_millis() as i64);

            match evaluate_approve(
                &storage,
                &workspace_id,
                &code,
                pane,
                fingerprint.as_deref(),
                dry_run,
                "human",
            )
            .await
            {
                Ok(data) => {
                    if data.dry_run == Some(true) {
                        println!("DRY RUN - No changes will be made");
                        println!();
                        println!("Approval Token:");
                        println!("  Code: {}", data.code);
                        println!("  Status: valid (not consumed)");
                        if let Some(created) = data.created_at {
                            println!(
                                "  Created: {} ({created} ms)",
                                format_epoch_ms(created as i64)
                            );
                        }
                        if let Some(expires) = data.expires_at {
                            println!(
                                "  Expires: {} ({expires} ms)",
                                format_epoch_ms(expires as i64)
                            );
                            let remaining = expires as i64 - now_ms;
                            if remaining <= 60_000 && remaining > 0 {
                                println!("  Warning: expires in ~{}s", remaining / 1000);
                            }
                        }
                        println!();
                        println!("Associated Action:");
                        if let Some(action) = &data.action_kind {
                            println!("  Kind: {action}");
                        }
                        if let Some(pane_id) = data.pane_id {
                            println!("  Pane: {pane_id}");
                        }
                        if let Some(fingerprint) = &data.action_fingerprint {
                            println!("  Fingerprint: {fingerprint}");
                        }
                        println!();
                        println!("Would grant:");
                        println!("  - Allow-once permission for this action");
                        println!("  - Audit log entry would be created");
                        println!();
                        println!("To approve for real:");
                        println!("  wa approve {}", data.code);
                    } else {
                        println!("Approval granted.");
                        if let Some(action) = &data.action_kind {
                            println!("Action: {action}");
                        }
                        if let Some(pane_id) = data.pane_id {
                            println!("Pane: {pane_id}");
                        }
                        println!("You may now retry the original action.");
                    }
                }
                Err(err) => {
                    eprintln!("Error: {}", err.message);
                    if let Some(hint) = &err.hint {
                        eprintln!("{hint}");
                    }
                    std::process::exit(1);
                }
            }
        }

        Some(Commands::Event {
            from_uservar,
            pane,
            name,
            value,
        }) => {
            // NOTE: --from-status was removed in v0.2.0 (Lua performance optimization)
            // Alt-screen detection is now handled via escape sequence parsing.
            if !from_uservar {
                eprintln!("Error: must specify --from-uservar.");
                eprintln!(
                    "Hint: use `wa event --from-uservar --pane <id> --name <name> --value <value>`"
                );
                std::process::exit(1);
            }

            #[cfg(unix)]
            {
                let client = wa_core::ipc::IpcClient::new(&layout.ipc_socket_path);

                // Handle user-var event
                let name = name.expect("name required for --from-uservar");
                let value = value.expect("value required for --from-uservar");
                let name_for_log = name.clone();
                let value_len = value.len();

                if let Err(message) = validate_uservar_request(pane, &name, &value) {
                    eprintln!("Error: {message}");
                    eprintln!(
                        "Context: pane_id={pane} name=\"{name_for_log}\" value_len={value_len}"
                    );
                    std::process::exit(1);
                }

                tracing::debug!(
                    pane_id = pane,
                    name = %name_for_log,
                    value_len,
                    "Forwarding user-var event to watcher"
                );

                match client.send_user_var(pane, name, value).await {
                    Ok(response) => {
                        if !response.ok {
                            let detail = response
                                .error
                                .unwrap_or_else(|| "unknown error".to_string());
                            eprintln!("Error: watcher rejected user-var event: {detail}");
                            eprintln!(
                                "Context: pane_id={pane} name=\"{name_for_log}\" value_len={value_len}"
                            );
                            std::process::exit(1);
                        }
                    }
                    Err(err) => {
                        match err {
                            wa_core::events::UserVarError::WatcherNotRunning { .. } => {
                                eprintln!("Error: {err}");
                                eprintln!(
                                    "Hint: start the watcher with `wa watch` in this workspace."
                                );
                            }
                            _ => {
                                eprintln!("Error: failed to forward user-var event: {err}");
                            }
                        }
                        eprintln!(
                            "Context: pane_id={pane} name=\"{name_for_log}\" value_len={value_len}"
                        );
                        std::process::exit(1);
                    }
                }
            }

            #[cfg(not(unix))]
            {
                eprintln!("Error: IPC event forwarding is only supported on Unix platforms.");
                eprintln!("Context: pane_id={pane}");
                std::process::exit(1);
            }
        }

        Some(Commands::Audit {
            command,
            format,
            limit,
            pane_id,
            actor,
            correlation_id,
            action,
            decision,
            result,
            since,
        }) => {
            if let Some(AuditCommands::Tail {
                follow,
                poll_interval_ms,
            }) = command
            {
                let layout = match config.workspace_layout(Some(&workspace_root)) {
                    Ok(l) => l,
                    Err(e) => {
                        eprintln!("Error: Failed to get workspace layout: {e}");
                        eprintln!("Check --workspace or WA_WORKSPACE");
                        std::process::exit(1);
                    }
                };

                let db_path = layout.db_path.to_string_lossy();
                let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                    Ok(s) => s,
                    Err(e) => {
                        eprintln!("Error: Failed to open storage: {e}");
                        eprintln!("Is the database initialized? Run 'wa watch' first.");
                        std::process::exit(1);
                    }
                };

                if cli.verbose > 0 {
                    eprintln!("Workspace: {}", layout.root.display());
                    eprintln!("Database:  {}", layout.db_path.display());
                    if let Some(pane_id) = pane_id {
                        eprintln!("Filter:    pane_id={pane_id}");
                    }
                    if let Some(actor) = &actor {
                        eprintln!("Filter:    actor={actor}");
                    }
                    if let Some(correlation_id) = &correlation_id {
                        eprintln!("Filter:    correlation_id={correlation_id}");
                    }
                    if let Some(action) = &action {
                        eprintln!("Filter:    action={action}");
                    }
                    if let Some(decision) = &decision {
                        eprintln!("Filter:    decision={decision}");
                    }
                    if let Some(result) = &result {
                        eprintln!("Filter:    result={result}");
                    }
                    if let Some(since) = since {
                        eprintln!("Filter:    since={since}");
                    }
                    eprintln!("Limit:     {limit}");
                }

                let mut cursor: Option<i64> = None;
                let redactor = wa_core::policy::Redactor::new();
                let page_limit = if limit == 0 { 1 } else { limit };
                let mut stdout = std::io::stdout();

                loop {
                    let query = wa_core::storage::AuditStreamQuery {
                        cursor,
                        limit: Some(page_limit),
                        pane_id,
                        actor_kind: actor.clone(),
                        correlation_id: correlation_id.clone(),
                        action_kind: action.clone(),
                        policy_decision: decision.clone(),
                        result: result.clone(),
                        since,
                        ..Default::default()
                    };

                    let page = match storage.get_audit_actions_stream(query).await {
                        Ok(page) => page,
                        Err(e) => {
                            eprintln!("Error: Failed to stream audit trail: {e}");
                            std::process::exit(1);
                        }
                    };

                    let record_count = page.records.len();
                    for action in page.records {
                        let record =
                            wa_core::storage::AuditStreamRecord::from_action(action, &redactor);
                        if let Ok(line) = serde_json::to_string(&record) {
                            let _ = writeln!(stdout, "{line}");
                        }
                    }

                    let _ = stdout.flush();
                    cursor = page.next_cursor.or(cursor);

                    if !follow {
                        break;
                    }

                    if record_count < page_limit {
                        tokio::time::sleep(Duration::from_millis(poll_interval_ms)).await;
                    }
                }
            } else {
                use wa_core::output::{
                    AuditListRenderer, OutputFormat, RenderContext, detect_format,
                };

                let output_format = match format.to_lowercase().as_str() {
                    "json" => OutputFormat::Json,
                    "plain" => OutputFormat::Plain,
                    _ => detect_format(),
                };

                // Get workspace layout for DB path
                let layout = match config.workspace_layout(Some(&workspace_root)) {
                    Ok(l) => l,
                    Err(e) => {
                        if output_format.is_json() {
                            println!(
                                r#"{{"ok": false, "error": "Failed to get workspace layout: {}", "version": "{}"}}"#,
                                e,
                                wa_core::VERSION
                            );
                        } else {
                            eprintln!("Error: Failed to get workspace layout: {e}");
                            eprintln!("Check --workspace or WA_WORKSPACE");
                        }
                        std::process::exit(1);
                    }
                };

                // Open storage handle
                let db_path = layout.db_path.to_string_lossy();
                let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                    Ok(s) => s,
                    Err(e) => {
                        if output_format.is_json() {
                            println!(
                                r#"{{"ok": false, "error": "Failed to open storage: {}", "version": "{}"}}"#,
                                e,
                                wa_core::VERSION
                            );
                        } else {
                            eprintln!("Error: Failed to open storage: {e}");
                            eprintln!("Is the database initialized? Run 'wa watch' first.");
                        }
                        std::process::exit(1);
                    }
                };

                // Build audit query
                let query = wa_core::storage::AuditQuery {
                    limit: Some(limit),
                    pane_id,
                    actor_kind: actor.clone(),
                    correlation_id: correlation_id.clone(),
                    action_kind: action.clone(),
                    policy_decision: decision.clone(),
                    result: result.clone(),
                    since,
                    ..Default::default()
                };

                if cli.verbose > 0 {
                    eprintln!("Workspace: {}", layout.root.display());
                    eprintln!("Database:  {}", layout.db_path.display());
                    if let Some(pane_id) = pane_id {
                        eprintln!("Filter:    pane_id={pane_id}");
                    }
                    if let Some(actor) = &actor {
                        eprintln!("Filter:    actor={actor}");
                    }
                    if let Some(correlation_id) = &correlation_id {
                        eprintln!("Filter:    correlation_id={correlation_id}");
                    }
                    if let Some(action) = &action {
                        eprintln!("Filter:    action={action}");
                    }
                    if let Some(decision) = &decision {
                        eprintln!("Filter:    decision={decision}");
                    }
                    if let Some(result) = &result {
                        eprintln!("Filter:    result={result}");
                    }
                    if let Some(since) = since {
                        eprintln!("Filter:    since={since}");
                    }
                    eprintln!("Limit:     {limit}");
                }

                // Query audit actions
                match storage.get_audit_actions(query).await {
                    Ok(actions) => {
                        let ctx = RenderContext::new(output_format)
                            .verbose(cli.verbose)
                            .limit(limit);
                        let output = AuditListRenderer::render(&actions, &ctx);
                        print!("{output}");
                    }
                    Err(e) => {
                        if output_format.is_json() {
                            println!(
                                r#"{{"ok": false, "error": "Failed to query audit trail: {}", "version": "{}"}}"#,
                                e,
                                wa_core::VERSION
                            );
                        } else {
                            eprintln!("Error: Failed to query audit trail: {e}");
                        }
                        std::process::exit(1);
                    }
                }
            }
        }

        Some(Commands::History {
            format,
            export,
            limit,
            pane_id,
            actor,
            workflow,
            action,
            decision,
            result,
            undoable,
            since,
            until,
        }) => {
            use wa_core::output::{
                ActionHistoryRenderer, OutputFormat, RenderContext, detect_format,
            };

            let export_format = export.as_ref().map(|value| value.to_lowercase());

            let output_format = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            let wants_json_error =
                matches!(export_format.as_deref(), Some("json")) || output_format.is_json();

            let fail = |message: &str| -> ! {
                if wants_json_error {
                    println!(
                        r#"{{"ok": false, "error": "{}", "version": "{}"}}"#,
                        message,
                        wa_core::VERSION
                    );
                } else {
                    eprintln!("Error: {message}");
                }
                std::process::exit(1);
            };

            if let Some(format) = &export_format {
                if format != "json" && format != "csv" {
                    fail(&format!(
                        "Unknown export format '{format}'. Valid values: json, csv"
                    ));
                }
            }

            let actor_kind = if workflow.is_some() {
                match actor.as_deref() {
                    None => Some("workflow".to_string()),
                    Some(value) if value.eq_ignore_ascii_case("workflow") => {
                        Some("workflow".to_string())
                    }
                    Some(value) => {
                        fail(&format!(
                            "--workflow implies --actor workflow (got {value})"
                        ));
                    }
                }
            } else {
                actor.clone()
            };

            let since_ms = match since.as_deref() {
                Some(raw) => match parse_history_time_ms(raw) {
                    Ok(value) => Some(value),
                    Err(err) => fail(&err),
                },
                None => None,
            };
            let until_ms = match until.as_deref() {
                Some(raw) => match parse_history_time_ms(raw) {
                    Ok(value) => Some(value),
                    Err(err) => fail(&err),
                },
                None => None,
            };

            let layout = match config.workspace_layout(Some(&workspace_root)) {
                Ok(l) => l,
                Err(e) => {
                    fail(&format!("Failed to get workspace layout: {e}"));
                }
            };

            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => s,
                Err(e) => {
                    fail(&format!("Failed to open storage: {e}"));
                }
            };

            let query = wa_core::storage::ActionHistoryQuery {
                limit: Some(limit),
                pane_id,
                actor_kind,
                actor_id: workflow.clone(),
                action_kind: action.clone(),
                policy_decision: decision.clone(),
                result: result.clone(),
                undoable: if undoable { Some(true) } else { None },
                since: since_ms,
                until: until_ms,
                ..Default::default()
            };

            if cli.verbose > 0 {
                eprintln!("Workspace: {}", layout.root.display());
                eprintln!("Database:  {}", layout.db_path.display());
                if let Some(pane_id) = pane_id {
                    eprintln!("Filter:    pane_id={pane_id}");
                }
                if let Some(actor) = &actor {
                    eprintln!("Filter:    actor={actor}");
                }
                if let Some(workflow) = &workflow {
                    eprintln!("Filter:    workflow={workflow}");
                }
                if let Some(action) = &action {
                    eprintln!("Filter:    action={action}");
                }
                if let Some(decision) = &decision {
                    eprintln!("Filter:    decision={decision}");
                }
                if let Some(result) = &result {
                    eprintln!("Filter:    result={result}");
                }
                if let Some(since) = &since {
                    eprintln!("Filter:    since={since}");
                }
                if let Some(until) = &until {
                    eprintln!("Filter:    until={until}");
                }
                if undoable {
                    eprintln!("Filter:    undoable=true");
                }
                eprintln!("Limit:     {limit}");
            }

            match storage.get_action_history(query).await {
                Ok(actions) => {
                    if matches!(export_format.as_deref(), Some("csv")) {
                        let output = ActionHistoryRenderer::render_csv(&actions);
                        print!("{output}");
                        return Ok(());
                    }

                    let effective_format = if matches!(export_format.as_deref(), Some("json")) {
                        OutputFormat::Json
                    } else {
                        output_format
                    };
                    let ctx = RenderContext::new(effective_format)
                        .verbose(cli.verbose)
                        .limit(limit);

                    let output = if let Some(workflow_id) = &workflow {
                        if ctx.format.is_json() {
                            ActionHistoryRenderer::render(&actions, &ctx)
                        } else {
                            ActionHistoryRenderer::render_workflow(&actions, workflow_id, &ctx)
                        }
                    } else {
                        ActionHistoryRenderer::render(&actions, &ctx)
                    };
                    print!("{output}");
                }
                Err(e) => {
                    fail(&format!("Failed to query action history: {e}"));
                }
            }
        }

        Some(Commands::Undo {
            action_id,
            list,
            all_in_workflow,
            yes,
            format,
            limit,
        }) => {
            use wa_core::output::{OutputFormat, detect_format};
            use wa_core::undo::{UndoExecutionResult, UndoExecutor, UndoOutcome, UndoRequest};

            let output_format = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                "auto" => detect_format(),
                other => {
                    eprintln!("Error: Unknown format '{other}'. Valid values: auto, plain, json");
                    std::process::exit(1);
                }
            };
            let wants_json_error = output_format.is_json();

            let fail = |message: &str| -> ! {
                if wants_json_error {
                    println!(
                        r#"{{"ok": false, "error": "{}", "version": "{}"}}"#,
                        message,
                        wa_core::VERSION
                    );
                } else {
                    eprintln!("Error: {message}");
                }
                std::process::exit(1);
            };

            let mode_count = usize::from(list)
                + usize::from(action_id.is_some())
                + usize::from(all_in_workflow.is_some());
            if mode_count != 1 {
                fail("Specify exactly one mode: --list, <action-id>, or --all-in-workflow <id>");
            }

            let layout = match config.workspace_layout(Some(&workspace_root)) {
                Ok(value) => value,
                Err(err) => fail(&format!("Failed to get workspace layout: {err}")),
            };
            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(value) => Arc::new(value),
                Err(err) => fail(&format!("Failed to open storage: {err}")),
            };

            let query_undoable = |workflow_filter: Option<&str>, fetch_limit: usize| {
                wa_core::storage::ActionHistoryQuery {
                    limit: Some(fetch_limit),
                    undoable: Some(true),
                    actor_kind: workflow_filter.map(|_| "workflow".to_string()),
                    actor_id: workflow_filter.map(str::to_string),
                    ..Default::default()
                }
            };

            if list {
                let fetch_limit = limit.saturating_mul(4).max(limit);
                let mut actions = match storage
                    .get_action_history(query_undoable(None, fetch_limit))
                    .await
                {
                    Ok(value) => value,
                    Err(err) => fail(&format!("Failed to query undoable actions: {err}")),
                };
                actions.retain(|row| row.undone_at.is_none());
                if actions.len() > limit {
                    actions.truncate(limit);
                }

                if output_format.is_json() {
                    let items = actions
                        .iter()
                        .map(|row| {
                            serde_json::json!({
                                "action_id": row.id,
                                "ts": row.ts,
                                "action_kind": row.action_kind,
                                "pane_id": row.pane_id,
                                "workflow_id": row.actor_id,
                                "strategy": row.undo_strategy,
                                "hint": row.undo_hint,
                            })
                        })
                        .collect::<Vec<_>>();
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&serde_json::json!({
                            "ok": true,
                            "data": {
                                "actions": items,
                                "count": items.len(),
                            },
                            "version": wa_core::VERSION,
                        }))
                        .unwrap_or_else(|_| "{}".to_string())
                    );
                } else if actions.is_empty() {
                    println!("No undoable actions found.");
                } else {
                    println!(
                        "{:<8} {:<14} {:<16} {:<8} {}",
                        "ID", "STRATEGY", "ACTION", "PANE", "WORKFLOW"
                    );
                    for row in &actions {
                        println!(
                            "{:<8} {:<14} {:<16} {:<8} {}",
                            row.id,
                            row.undo_strategy.as_deref().unwrap_or("-"),
                            row.action_kind,
                            row.pane_id
                                .map_or_else(|| "-".to_string(), |value| value.to_string()),
                            row.actor_id.as_deref().unwrap_or("-")
                        );
                    }
                    println!("\n{} undoable action(s).", actions.len());
                }

                if let Err(err) = storage.shutdown().await {
                    tracing::warn!("Failed to shutdown storage cleanly: {err}");
                }
                return Ok(());
            }

            let mut target_action_ids: Vec<i64> = if let Some(workflow_id) = &all_in_workflow {
                let fetch_limit = limit.saturating_mul(8).max(limit);
                let mut actions = match storage
                    .get_action_history(query_undoable(Some(workflow_id), fetch_limit))
                    .await
                {
                    Ok(value) => value,
                    Err(err) => fail(&format!("Failed to query workflow undo actions: {err}")),
                };
                actions.retain(|row| row.undone_at.is_none());
                actions.into_iter().map(|row| row.id).collect()
            } else {
                vec![action_id.expect("validated mode requires action_id")]
            };

            if target_action_ids.is_empty() {
                fail("No undoable actions found for the requested workflow");
            }

            if !yes {
                if !std::io::stdin().is_terminal() {
                    fail("Confirmation required in non-interactive mode. Re-run with --yes.");
                }

                if let Some(workflow_id) = &all_in_workflow {
                    println!(
                        "About to undo {} action(s) in workflow {}.",
                        target_action_ids.len(),
                        workflow_id
                    );
                } else {
                    let id = target_action_ids[0];
                    let action = storage
                        .get_action_history(wa_core::storage::ActionHistoryQuery {
                            audit_action_id: Some(id),
                            limit: Some(1),
                            ..Default::default()
                        })
                        .await
                        .ok()
                        .and_then(|mut rows| rows.pop());
                    if let Some(action) = action {
                        println!(
                            "About to undo action {} (strategy={}, kind={}, pane={}).",
                            action.id,
                            action.undo_strategy.as_deref().unwrap_or("-"),
                            action.action_kind,
                            action
                                .pane_id
                                .map_or_else(|| "-".to_string(), |value| value.to_string())
                        );
                    } else {
                        println!("About to undo action {}.", id);
                    }
                }

                if !prompt_confirm("Proceed with undo? [y/N]: ")? {
                    println!("Aborted.");
                    if let Err(err) = storage.shutdown().await {
                        tracing::warn!("Failed to shutdown storage cleanly: {err}");
                    }
                    return Ok(());
                }
            }

            let executor = UndoExecutor::new(
                Arc::clone(&storage),
                wa_core::wezterm::default_wezterm_handle(),
            );
            let reason = if let Some(workflow_id) = &all_in_workflow {
                format!("wa undo --all-in-workflow {workflow_id}")
            } else {
                format!("wa undo {}", target_action_ids[0])
            };

            // Deterministic order: newest id first by default query order.
            target_action_ids.sort_unstable_by(|lhs, rhs| rhs.cmp(lhs));

            let mut results: Vec<UndoExecutionResult> = Vec::with_capacity(target_action_ids.len());
            for action_id in target_action_ids {
                let request = UndoRequest::new(action_id)
                    .with_actor("human-cli")
                    .with_reason(reason.clone());
                match executor.execute(request).await {
                    Ok(result) => results.push(result),
                    Err(err) => results.push(UndoExecutionResult {
                        action_id,
                        strategy: "unknown".to_string(),
                        outcome: UndoOutcome::Failed,
                        message: format!("Undo execution failed: {err}"),
                        guidance: Some(
                            "Inspect action history and workflow status for remediation."
                                .to_string(),
                        ),
                        target_workflow_id: None,
                        target_pane_id: None,
                        undone_at: None,
                    }),
                }
            }

            if output_format.is_json() {
                println!(
                    "{}",
                    serde_json::to_string_pretty(&serde_json::json!({
                        "ok": true,
                        "data": {
                            "results": results,
                            "count": results.len(),
                        },
                        "version": wa_core::VERSION,
                    }))
                    .unwrap_or_else(|_| "{}".to_string())
                );
            } else {
                for result in &results {
                    let outcome = match result.outcome {
                        UndoOutcome::Success => "success",
                        UndoOutcome::NotApplicable => "not_applicable",
                        UndoOutcome::Failed => "failed",
                    };
                    println!("#{} [{outcome}] {}", result.action_id, result.message);
                    if let Some(guidance) = &result.guidance {
                        println!("  hint: {guidance}");
                    }
                }
            }

            if let Err(err) = storage.shutdown().await {
                tracing::warn!("Failed to shutdown storage cleanly: {err}");
            }
        }

        Some(Commands::Notify { command }) => {
            handle_notify_command(command, &config).await?;
        }

        Some(Commands::Secrets { command }) => {
            use wa_core::output::{OutputFormat, detect_format};
            use wa_core::secrets::{
                SecretScanEngine, SecretScanOptions, SecretScanReport, scope_hash,
            };

            let layout = match config.workspace_layout(Some(&workspace_root)) {
                Ok(l) => l,
                Err(e) => {
                    eprintln!("Error: Failed to get workspace layout: {e}");
                    eprintln!("Check --workspace or WA_WORKSPACE");
                    std::process::exit(1);
                }
            };

            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => s,
                Err(e) => {
                    eprintln!("Error: Failed to open storage: {e}");
                    eprintln!("Is the database initialized? Run 'wa watch' first.");
                    std::process::exit(1);
                }
            };

            let render_report =
                |report: &SecretScanReport, format: &str, pretty: bool| -> anyhow::Result<()> {
                    let output_format = match format.to_lowercase().as_str() {
                        "json" => OutputFormat::Json,
                        "plain" => OutputFormat::Plain,
                        _ => detect_format(),
                    };
                    render_secret_scan_report(report, output_format, pretty)
                };

            match command {
                SecretsCommands::Scan {
                    format,
                    pane_id,
                    since,
                    until,
                    max_segments,
                    batch_size,
                    sample_limit,
                    pretty,
                } => {
                    let options = SecretScanOptions {
                        pane_id,
                        since,
                        until,
                        max_segments,
                        batch_size,
                        sample_limit,
                    };

                    let engine = SecretScanEngine::new();
                    let report = match engine.scan_storage_incremental(&storage, options).await {
                        Ok(report) => report,
                        Err(e) => {
                            eprintln!("Error: Secret scan failed: {e}");
                            std::process::exit(1);
                        }
                    };

                    render_report(&report, &format, pretty)?;
                }
                SecretsCommands::Report {
                    format,
                    pane_id,
                    since,
                    until,
                    pretty,
                } => {
                    let options = SecretScanOptions {
                        pane_id,
                        since,
                        until,
                        ..Default::default()
                    };
                    let scope = match scope_hash(&options) {
                        Ok(value) => value,
                        Err(e) => {
                            eprintln!("Error: Failed to compute scope hash: {e}");
                            std::process::exit(1);
                        }
                    };

                    let record = match storage.latest_secret_scan_report(&scope).await {
                        Ok(record) => record,
                        Err(e) => {
                            eprintln!("Error: Failed to load secret scan report: {e}");
                            std::process::exit(1);
                        }
                    };

                    let record = match record {
                        Some(record) => record,
                        None => {
                            eprintln!("No secret scan report found for this scope.");
                            eprintln!("Hint: run `wa secrets scan` first.");
                            std::process::exit(1);
                        }
                    };

                    let report: SecretScanReport = match serde_json::from_str(&record.report_json) {
                        Ok(report) => report,
                        Err(e) => {
                            eprintln!("Error: Failed to parse secret scan report: {e}");
                            std::process::exit(1);
                        }
                    };

                    render_report(&report, &format, pretty)?;
                }
            }
        }

        Some(Commands::Doctor { circuits, json }) => {
            let checks = run_diagnostics(&permission_warnings, &config, &layout);
            let mut all_checks: Vec<DiagnosticCheck> = checks;

            // Runtime health snapshot (only available when daemon is running in-process)
            let mut runtime_checks: Vec<DiagnosticCheck> = Vec::new();
            if let Some(snapshot) = wa_core::crash::HealthSnapshot::get_global() {
                use wa_core::output::{HealthDiagnosticStatus, HealthSnapshotRenderer};

                let health_checks = HealthSnapshotRenderer::diagnostic_checks(&snapshot);
                for hc in &health_checks {
                    let diag = match hc.status {
                        HealthDiagnosticStatus::Ok | HealthDiagnosticStatus::Info => {
                            DiagnosticCheck::ok_with_detail(hc.name, &hc.detail)
                        }
                        HealthDiagnosticStatus::Warning => DiagnosticCheck::warning(
                            hc.name,
                            &hc.detail,
                            "Check wa status for details",
                        ),
                        HealthDiagnosticStatus::Error => DiagnosticCheck::error(
                            hc.name,
                            &hc.detail,
                            "Investigate immediately: database may be unresponsive",
                        ),
                    };
                    runtime_checks.push(diag);
                }
            }

            // Recent crash bundles
            let crash_check =
                if let Some(bundle) = wa_core::crash::latest_crash_bundle(&layout.crash_dir) {
                    let detail = if let Some(ref report) = bundle.report {
                        let msg = if report.message.len() > 80 {
                            format!("{}...", &report.message[..77])
                        } else {
                            report.message.clone()
                        };
                        let loc = report.location.as_deref().unwrap_or("unknown location");
                        format!("{msg} (at {loc})")
                    } else if let Some(ref manifest) = bundle.manifest {
                        format!("crash at {}", manifest.created_at)
                    } else {
                        "crash bundle found".to_string()
                    };
                    DiagnosticCheck::warning(
                        "Recent crash",
                        &detail,
                        format!("Inspect bundle: {}", bundle.path.display()),
                    )
                } else {
                    DiagnosticCheck::ok_with_detail("Crash history", "No crash bundles found")
                };

            // Circuit breaker status
            let mut circuit_checks: Vec<serde_json::Value> = Vec::new();
            if circuits {
                use wa_core::circuit_breaker::{
                    CircuitStateKind, circuit_snapshots, ensure_default_circuits,
                };

                ensure_default_circuits();
                let snapshots = circuit_snapshots();
                for snapshot in &snapshots {
                    let state_str = match snapshot.status.state {
                        CircuitStateKind::Closed => "closed",
                        CircuitStateKind::HalfOpen => "half_open",
                        CircuitStateKind::Open => "open",
                    };
                    circuit_checks.push(serde_json::json!({
                        "name": snapshot.name,
                        "state": state_str,
                        "consecutive_failures": snapshot.status.consecutive_failures,
                        "cooldown_remaining_ms": snapshot.status.cooldown_remaining_ms,
                    }));
                }
            }

            // Determine overall status
            let has_errors = all_checks
                .iter()
                .chain(runtime_checks.iter())
                .chain(std::iter::once(&crash_check))
                .any(|c| c.status == DiagnosticStatus::Error);
            let has_warnings = all_checks
                .iter()
                .chain(runtime_checks.iter())
                .chain(std::iter::once(&crash_check))
                .any(|c| c.status == DiagnosticStatus::Warning);

            if json {
                // JSON output for automation
                let overall = if has_errors {
                    "error"
                } else if has_warnings {
                    "warning"
                } else {
                    "ok"
                };

                all_checks.extend(runtime_checks);
                all_checks.push(crash_check);

                let mut result = serde_json::json!({
                    "ok": !has_errors,
                    "status": overall,
                    "version": env!("CARGO_PKG_VERSION"),
                    "checks": all_checks.iter().map(|c| c.to_json_value()).collect::<Vec<_>>(),
                });

                if !circuit_checks.is_empty() {
                    result["circuits"] = serde_json::json!(circuit_checks);
                }

                println!(
                    "{}",
                    serde_json::to_string_pretty(&result).unwrap_or_else(|_| "{}".to_string())
                );
            } else {
                // Plain text output
                println!("wa doctor - Running diagnostics...\n");

                for check in &all_checks {
                    check.print();
                }

                if !runtime_checks.is_empty() {
                    println!();
                    println!("Runtime Health:");
                    for check in &runtime_checks {
                        check.print();
                    }
                }

                println!();
                println!("Crash History:");
                crash_check.print();

                if circuits {
                    use wa_core::circuit_breaker::{
                        CircuitStateKind, circuit_snapshots, ensure_default_circuits,
                    };

                    ensure_default_circuits();
                    let snapshots = circuit_snapshots();

                    if !snapshots.is_empty() {
                        let name_width = snapshots
                            .iter()
                            .map(|s| s.name.len())
                            .max()
                            .unwrap_or(0)
                            .max(8);

                        let format_retry = |ms: Option<u64>| -> String {
                            match ms {
                                Some(value) if value >= 60_000 => {
                                    let minutes = value / 60_000;
                                    let seconds = (value % 60_000) / 1_000;
                                    format!("{minutes}m{seconds:02}s")
                                }
                                Some(value) if value >= 1_000 => {
                                    let seconds = value / 1_000;
                                    let millis = value % 1_000;
                                    format!("{seconds}.{millis:03}s")
                                }
                                Some(value) => format!("{value}ms"),
                                None => "n/a".to_string(),
                            }
                        };

                        println!("Circuit Breaker Status:");
                        for snapshot in snapshots {
                            let status = match snapshot.status.state {
                                CircuitStateKind::Closed => "CLOSED (healthy)".to_string(),
                                CircuitStateKind::HalfOpen => "HALF-OPEN (testing)".to_string(),
                                CircuitStateKind::Open => format!(
                                    "OPEN ({} failures, retry in {})",
                                    snapshot.status.consecutive_failures,
                                    format_retry(snapshot.status.cooldown_remaining_ms)
                                ),
                            };
                            println!("  {:width$}: {status}", snapshot.name, width = name_width);
                        }
                        println!();
                    }
                }

                println!();
                if has_errors {
                    println!(
                        "Diagnostics completed with errors. Fix issues above before using wa."
                    );
                } else if has_warnings {
                    println!(
                        "Diagnostics completed with warnings. wa should work but performance may be affected."
                    );
                } else {
                    println!("All checks passed! wa is ready to use.");
                }
            }

            if has_errors {
                std::process::exit(1);
            }
        }

        Some(Commands::Diag { command }) => {
            match command {
                DiagCommands::Bundle {
                    output,
                    force,
                    events,
                    audit,
                    workflows,
                } => {
                    use wa_core::diagnostic::{DiagnosticOptions, generate_bundle};

                    // Resolve output path
                    let output_path = output;

                    // If output path exists and --force not set, refuse
                    if let Some(ref path) = output_path {
                        if path.exists() && !force {
                            eprintln!("Error: Output directory already exists: {}", path.display());
                            eprintln!("Use --force to overwrite.");
                            std::process::exit(1);
                        }
                    }

                    // Get workspace layout for DB path
                    let layout = match config.workspace_layout(Some(&workspace_root)) {
                        Ok(l) => l,
                        Err(e) => {
                            eprintln!("Error: Failed to get workspace layout: {e}");
                            std::process::exit(1);
                        }
                    };

                    let db_path = layout.db_path.to_string_lossy();
                    let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                        Ok(s) => s,
                        Err(e) => {
                            eprintln!("Error: Failed to open storage: {e}");
                            eprintln!("Is the database initialized? Run 'wa watch' first.");
                            std::process::exit(1);
                        }
                    };

                    let opts = DiagnosticOptions {
                        event_limit: events,
                        audit_limit: audit,
                        workflow_limit: workflows,
                        output: output_path,
                    };

                    eprintln!("Generating diagnostic bundle...");

                    match generate_bundle(&config, &layout, &storage, &opts).await {
                        Ok(result) => {
                            eprintln!("Bundle generated: {}", result.output_path);
                            eprintln!("  Files:      {}", result.file_count);
                            eprintln!("  Total size: {} bytes", result.total_size_bytes);
                            eprintln!();
                            eprintln!("All data is redacted. Safe to attach to bug reports.");
                            // Print path on stdout for easy piping
                            println!("{}", result.output_path);
                        }
                        Err(e) => {
                            eprintln!("Error: Failed to generate diagnostic bundle: {e}");
                            std::process::exit(1);
                        }
                    }

                    let _ = storage.shutdown().await;
                }
            }
        }

        Some(Commands::Reproduce { command }) => match command {
            ReproduceCommands::Export { kind, out, format } => {
                use wa_core::crash::{
                    IncidentBundleOptions, IncidentKind, collect_incident_bundle,
                };

                let incident_kind = match kind.to_lowercase().as_str() {
                    "crash" => IncidentKind::Crash,
                    "manual" => IncidentKind::Manual,
                    other => {
                        eprintln!(
                            "Error: Unknown incident kind '{other}'. Use 'crash' or 'manual'."
                        );
                        std::process::exit(1);
                    }
                };

                let out_dir = out.unwrap_or_else(|| layout.crash_dir.clone());
                let config_path = wa_core::config::resolve_config_path(None);

                let opts = IncidentBundleOptions {
                    crash_dir: &layout.crash_dir,
                    config_path: config_path.as_deref(),
                    out_dir: &out_dir,
                    kind: incident_kind,
                    db_path: Some(&layout.db_path),
                    max_events: 50,
                };

                match collect_incident_bundle(&opts) {
                    Ok(result) => {
                        if format.to_lowercase() == "json" {
                            let json = serde_json::to_string_pretty(&result)
                                .unwrap_or_else(|_| "{}".to_string());
                            println!("{json}");
                        } else {
                            println!("wa reproduce export - Incident bundle exported\n");
                            println!("  Kind:    {}", result.kind);
                            println!("  Path:    {}", result.path.display());
                            println!("  Files:   {}", result.files.len());
                            println!("  Size:    {} bytes", result.total_size_bytes);
                            println!("  Version: {}", result.wa_version);
                            println!("  Time:    {}", result.exported_at);
                            if !result.files.is_empty() {
                                println!("\nIncluded files:");
                                for f in &result.files {
                                    println!("  - {f}");
                                }
                            }
                            println!("\nNext steps:");
                            println!("  1. Review the bundle for sensitive data");
                            println!("  2. Share the bundle directory for analysis");
                            println!(
                                "  3. Run 'wa reproduce replay {}' to replay",
                                result.path.display()
                            );
                        }
                    }
                    Err(e) => {
                        eprintln!("Error: Failed to export incident bundle: {e}");
                        eprintln!("Run 'wa doctor' to check system health.");
                        std::process::exit(1);
                    }
                }
            }

            ReproduceCommands::Replay {
                bundle,
                mode,
                format,
            } => {
                use wa_core::crash::replay_incident_bundle;

                let replay_mode = match mode.to_lowercase().as_str() {
                    "policy" => wa_core::crash::ReplayMode::Policy,
                    "rules" => wa_core::crash::ReplayMode::Rules,
                    other => {
                        eprintln!("Error: Unknown replay mode '{other}'. Use 'policy' or 'rules'.");
                        std::process::exit(1);
                    }
                };

                match replay_incident_bundle(&bundle, replay_mode) {
                    Ok(result) => {
                        if format.to_lowercase() == "json" {
                            let json = serde_json::to_string_pretty(&result)
                                .unwrap_or_else(|_| "{}".to_string());
                            println!("{json}");
                        } else {
                            println!("wa reproduce replay - Bundle analysis\n");
                            println!("  Bundle:  {}", bundle.display());
                            println!("  Mode:    {}", result.mode);
                            println!("  Status:  {}", result.status);
                            println!("  Checks:  {}", result.checks.len());
                            let passed = result.checks.iter().filter(|c| c.passed).count();
                            let failed = result.checks.len() - passed;
                            println!("  Passed:  {passed}");
                            println!("  Failed:  {failed}");
                            if !result.checks.is_empty() {
                                println!("\nResults:");
                                for check in &result.checks {
                                    let icon = if check.passed { "PASS" } else { "FAIL" };
                                    println!("  [{icon}] {}", check.name);
                                    if let Some(ref detail) = check.detail {
                                        println!("         {detail}");
                                    }
                                }
                            }
                            if !result.warnings.is_empty() {
                                println!("\nWarnings:");
                                for w in &result.warnings {
                                    println!("  - {w}");
                                }
                            }
                        }
                    }
                    Err(e) => {
                        eprintln!("Error: Failed to replay bundle: {e}");
                        std::process::exit(1);
                    }
                }
            }
        },

        Some(Commands::Setup {
            list_hosts,
            apply,
            dry_run,
            command,
        }) => {
            if list_hosts {
                use wa_core::setup;

                println!("wa setup --list-hosts\n");

                match setup::locate_ssh_config() {
                    Ok(path) => match setup::load_ssh_hosts(&path) {
                        Ok(hosts) => {
                            if hosts.is_empty() {
                                println!("No SSH hosts found in {}.", path.display());
                            } else {
                                println!(
                                    "Found {} SSH host(s) in {}:\n",
                                    hosts.len(),
                                    path.display()
                                );
                                for host in hosts {
                                    println!(" {}", host.alias);
                                    if let Some(hostname) = host.hostname.as_deref() {
                                        println!("  HostName: {hostname}");
                                    }
                                    if let Some(user) = host.user.as_deref() {
                                        println!("  User: {user}");
                                    }
                                    if let Some(port) = host.port {
                                        println!("  Port: {port}");
                                    }
                                    let identities = host.redacted_identity_files();
                                    if !identities.is_empty() {
                                        println!("  IdentityFile(s): {}", identities.join(", "));
                                    }
                                    println!();
                                }
                            }
                        }
                        Err(err) => {
                            eprintln!("Error: {err}");
                            std::process::exit(1);
                        }
                    },
                    Err(err) => {
                        eprintln!("Error: {err}");
                        std::process::exit(1);
                    }
                }
            } else if let Some(command) = command {
                match command {
                    SetupCommands::Local => {
                        println!("wa setup local - WezTerm Configuration Guide\n");
                        println!("wa requires WezTerm to be configured with adequate scrollback.");
                        println!("Without sufficient scrollback, wa may miss terminal output.\n");

                        // Check current state
                        if let Ok((lines, path)) = check_wezterm_scrollback() {
                            if lines >= RECOMMENDED_SCROLLBACK_LINES {
                                println!(" Your WezTerm scrollback is already configured!");
                                println!("  Current: {} lines in {}", lines, path.display());
                                println!(
                                    "  Recommended minimum: {RECOMMENDED_SCROLLBACK_LINES} lines"
                                );
                                println!("\nNo changes needed.");
                            } else {
                                println!(" Your WezTerm scrollback is below recommended minimum.");
                                println!("  Current: {} lines in {}", lines, path.display());
                                println!("  Recommended: {RECOMMENDED_SCROLLBACK_LINES} lines\n");
                                println!("Add this line to your wezterm.lua:");
                                println!(
                                    "  config.scrollback_lines = {RECOMMENDED_SCROLLBACK_LINES}"
                                );
                            }
                        } else {
                            println!("Could not find or parse WezTerm config.\n");
                            println!("Add the following to your ~/.config/wezterm/wezterm.lua:\n");
                            println!(
                                "  config.scrollback_lines = {RECOMMENDED_SCROLLBACK_LINES}\n"
                            );
                            println!(
                                "This ensures wa can capture all terminal output without gaps."
                            );
                        }

                        println!("\n--- Why {RECOMMENDED_SCROLLBACK_LINES} lines? ---");
                        println!(" AI coding agents can produce substantial output");
                        println!(" wa uses delta extraction to capture only new content");
                        println!(
                            " Insufficient scrollback causes capture gaps (EVENT_GAP_DETECTED)"
                        );
                        println!(
                            " 50k lines  2-5 MB memory per pane (negligible on modern systems)"
                        );
                        println!("\nRun 'wa doctor' to verify your configuration.");
                    }
                    SetupCommands::Remote {
                        host,
                        yes,
                        install_wa,
                        wa_path,
                        wa_version,
                        timeout_secs,
                    } => {
                        let options = RemoteSetupOptions {
                            apply,
                            dry_run,
                            yes,
                            install_wa,
                            wa_path: wa_path.as_deref(),
                            wa_version: wa_version.as_deref(),
                            timeout_secs,
                            verbose: cli.verbose,
                        };
                        run_remote_setup(&host, &options)?;
                    }
                    SetupCommands::Config => {
                        use wa_core::setup;

                        println!("wa setup config - Generate WezTerm Config Additions\n");
                        let mut hosts = Vec::new();
                        let mut ssh_path = None;
                        match setup::locate_ssh_config() {
                            Ok(path) => match setup::load_ssh_hosts(&path) {
                                Ok(loaded) => {
                                    hosts = loaded;
                                    ssh_path = Some(path);
                                }
                                Err(err) => {
                                    eprintln!("Warning: {err}");
                                }
                            },
                            Err(err) => {
                                eprintln!("Warning: {err}");
                            }
                        }

                        let wa_block =
                            setup::generate_ssh_domains_lua(&hosts, RECOMMENDED_SCROLLBACK_LINES);

                        if dry_run {
                            match setup::locate_wezterm_config() {
                                Ok(config_path) => match fs::read_to_string(&config_path) {
                                    Ok(content) => {
                                        if setup::has_wa_block(&content) {
                                            let existing = setup::extract_wa_block(&content)
                                                .unwrap_or_default();
                                            if existing.trim_end() == wa_block.trim_end() {
                                                println!(
                                                    " wa block already up to date in {}",
                                                    config_path.display()
                                                );
                                            } else {
                                                println!(
                                                    " wa block would be updated in {}",
                                                    config_path.display()
                                                );
                                            }
                                        } else {
                                            println!(
                                                " wa block would be added to {}",
                                                config_path.display()
                                            );
                                        }
                                    }
                                    Err(err) => {
                                        eprintln!(
                                            "Error: Failed to read {}: {}",
                                            config_path.display(),
                                            err
                                        );
                                        std::process::exit(1);
                                    }
                                },
                                Err(err) => {
                                    eprintln!("Warning: {err}");
                                }
                            }
                            println!("\n--- Generated block (dry-run) ---\n");
                            println!("{wa_block}");
                            println!("Place this block before any `return config` line.");
                            println!("Run with --apply to patch your config.");
                        } else if apply {
                            let config_path = match setup::locate_wezterm_config() {
                                Ok(path) => path,
                                Err(err) => {
                                    eprintln!("Error: {err}");
                                    std::process::exit(1);
                                }
                            };
                            match setup::patch_wezterm_config_block_at(&config_path, &wa_block) {
                                Ok(patch_result) => {
                                    if patch_result.modified {
                                        println!(" {}", patch_result.message);
                                        if let Some(backup) = patch_result.backup_path {
                                            println!("  Backup: {}", backup.display());
                                        }
                                        println!("\nRestart WezTerm to apply the changes.");
                                    } else {
                                        println!(" {}", patch_result.message);
                                    }
                                }
                                Err(e) => {
                                    eprintln!("Error: {e}");
                                    std::process::exit(1);
                                }
                            }
                        } else {
                            println!("Add the following to your wezterm.lua:\n");
                            if let Some(path) = ssh_path {
                                println!(
                                    "-- Derived {} SSH host(s) from {}",
                                    hosts.len(),
                                    path.display()
                                );
                            } else {
                                println!("-- SSH config not found; update ssh_domains manually");
                            }
                            println!();
                            println!("{wa_block}");
                            println!("Place this block before any `return config` line.");
                            println!("Tip: run with --apply to patch automatically.");
                        }
                    }
                    SetupCommands::Patch {
                        remove,
                        config_path,
                    } => {
                        use wa_core::setup;

                        println!("wa setup patch - WezTerm User-Var Forwarding\n");

                        let result = if remove {
                            if let Some(path) = config_path {
                                setup::unpatch_wezterm_config_at(&path)
                            } else {
                                let path = setup::locate_wezterm_config()?;
                                setup::unpatch_wezterm_config_at(&path)
                            }
                        } else if let Some(path) = config_path {
                            setup::patch_wezterm_config_at(&path)
                        } else {
                            setup::patch_wezterm_config()
                        };

                        match result {
                            Ok(patch_result) => {
                                if patch_result.modified {
                                    println!(" {}", patch_result.message);
                                    if let Some(backup) = patch_result.backup_path {
                                        println!("  Backup: {}", backup.display());
                                    }
                                    println!("\nRestart WezTerm to apply the changes.");
                                } else {
                                    println!(" {}", patch_result.message);
                                }
                            }
                            Err(e) => {
                                eprintln!("Error: {e}");
                                std::process::exit(1);
                            }
                        }
                    }
                    SetupCommands::Shell {
                        remove,
                        shell,
                        rc_path,
                    } => {
                        use wa_core::setup::{self, ShellType};

                        // Determine shell type
                        let shell_type = match shell.as_deref() {
                            Some("bash") => ShellType::Bash,
                            Some("zsh") => ShellType::Zsh,
                            Some("fish") => ShellType::Fish,
                            Some(other) => {
                                eprintln!("Error: Unsupported shell: {other}");
                                eprintln!("Supported shells: bash, zsh, fish");
                                std::process::exit(1);
                            }
                            None => {
                                // Auto-detect from $SHELL
                                if let Some(st) = ShellType::detect() {
                                    println!("Detected shell: {}\n", st.name());
                                    st
                                } else {
                                    eprintln!("Error: Could not detect shell from $SHELL");
                                    eprintln!("Please specify --shell bash|zsh|fish");
                                    std::process::exit(1);
                                }
                            }
                        };

                        println!(
                            "wa setup shell - OSC 133 Prompt Markers ({})\n",
                            shell_type.name()
                        );

                        let result = if remove {
                            if let Some(path) = rc_path {
                                setup::unpatch_shell_rc_at(&path)
                            } else {
                                let path = setup::locate_shell_rc(shell_type)?;
                                setup::unpatch_shell_rc_at(&path)
                            }
                        } else if let Some(path) = rc_path {
                            setup::patch_shell_rc_at(&path, shell_type)
                        } else {
                            setup::patch_shell_rc(shell_type)
                        };

                        match result {
                            Ok(patch_result) => {
                                if patch_result.modified {
                                    println!(" {}", patch_result.message);
                                    if let Some(backup) = patch_result.backup_path {
                                        println!("  Backup: {}", backup.display());
                                    }
                                    println!(
                                        "\nSource your shell config or restart your shell to apply:"
                                    );
                                    println!("  source {}", patch_result.config_path.display());
                                } else {
                                    println!(" {}", patch_result.message);
                                }
                            }
                            Err(e) => {
                                eprintln!("Error: {e}");
                                std::process::exit(1);
                            }
                        }
                    }
                }
            } else {
                run_guided_setup(apply, dry_run, cli.verbose).await?;
            }
        }

        Some(Commands::Config { command }) => {
            handle_config_command(command, cli_config_arg.as_deref(), workspace.as_deref()).await?;
        }

        Some(Commands::Learn {
            track,
            status,
            achievements,
            reset,
            complete,
            skip,
            json,
        }) => {
            handle_learn_command(track, status, achievements, reset, complete, skip, json)?;
        }

        Some(Commands::Db { command }) => {
            handle_db_command(command, &layout, config.storage.retention_days).await?;
        }

        Some(Commands::Backup { command }) => {
            handle_backup_command(command, &layout, &workspace_root).await?;
        }

        #[cfg(feature = "sync")]
        Some(Commands::Sync { command }) => {
            use wa_core::output::{OutputFormat, detect_format};
            use wa_core::sync::{SyncPlanOptions, SyncResult, build_sync_plan, build_sync_status};

            let render_status = |format: &str| -> SyncResult<()> {
                let output_format = match format.to_lowercase().as_str() {
                    "json" => OutputFormat::Json,
                    "plain" => OutputFormat::Plain,
                    _ => detect_format(),
                };

                let status = build_sync_status(&config);
                if output_format.is_json() {
                    let result = serde_json::json!({
                        "ok": true,
                        "version": wa_core::VERSION,
                        "data": status,
                    });
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&result).unwrap_or_else(|_| "{}".to_string())
                    );
                } else {
                    println!("wa sync status\n");
                    println!("Enabled: {}", status.enabled);
                    println!(
                        "Defaults: binary={}, config={}, snapshots={}, overwrite={}, confirm={}",
                        status.allow_binary,
                        status.allow_config,
                        status.allow_snapshots,
                        status.allow_overwrite,
                        status.require_confirmation
                    );
                    if status.targets.is_empty() {
                        println!("\nTargets: (none configured)");
                    } else {
                        println!("\nTargets:");
                        for target in &status.targets {
                            println!(
                                "  - {} ({}) {}",
                                target.name, target.transport, target.endpoint
                            );
                            println!("      root: {}", target.root);
                            println!(
                                "      allow: binary={}, config={}, snapshots={}",
                                target.allow_binary, target.allow_config, target.allow_snapshots
                            );
                        }
                    }
                    if !status.deny_paths.is_empty() {
                        println!("\nDenied paths:");
                        for deny in &status.deny_paths {
                            println!("  - {deny}");
                        }
                    }
                }
                Ok(())
            };

            let render_plan = |plan: wa_core::sync::SyncPlan, format: &str| {
                let output_format = match format.to_lowercase().as_str() {
                    "json" => OutputFormat::Json,
                    "plain" => OutputFormat::Plain,
                    _ => detect_format(),
                };

                if output_format.is_json() {
                    let result = serde_json::json!({
                        "ok": true,
                        "version": wa_core::VERSION,
                        "data": plan,
                    });
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&result).unwrap_or_else(|_| "{}".to_string())
                    );
                } else {
                    let direction = match plan.direction {
                        wa_core::config::SyncDirection::Push => "push",
                        wa_core::config::SyncDirection::Pull => "pull",
                    };
                    println!("wa sync {direction} - plan\n");
                    println!(
                        "Target: {} ({}) {}",
                        plan.target.name, plan.target.transport, plan.target.endpoint
                    );
                    println!("Root: {}", plan.target.root);
                    println!("Dry-run: {}", plan.dry_run);
                    println!("Apply: {}", plan.apply);
                    println!("Allow overwrite: {}", plan.allow_overwrite);
                    if !plan.warnings.is_empty() {
                        println!("\nWarnings:");
                        for warning in &plan.warnings {
                            println!("  - {warning}");
                        }
                    }
                    if plan.payloads.is_empty() {
                        println!("\nPayloads: (none)");
                    } else {
                        println!("\nPayloads:");
                        for payload in &plan.payloads {
                            println!(
                                "  - {:?}: {} -> {}",
                                payload.category, payload.source, payload.destination
                            );
                            if let Some(ref note) = payload.note {
                                println!("      note: {note}");
                            }
                        }
                    }
                }
            };

            match command {
                SyncCommands::Status { format } => {
                    if let Err(err) = render_status(&format) {
                        eprintln!("Error: {err}");
                        std::process::exit(1);
                    }
                }
                SyncCommands::Push {
                    target,
                    dry_run,
                    apply,
                    yes,
                    allow_overwrite,
                    include,
                    format,
                } => {
                    let mut dry_run = dry_run;
                    if apply {
                        dry_run = false;
                    } else if !dry_run {
                        dry_run = true;
                    }
                    let plan = build_sync_plan(
                        &config,
                        &layout,
                        SyncPlanOptions {
                            target,
                            direction: wa_core::config::SyncDirection::Push,
                            dry_run,
                            apply,
                            yes,
                            allow_overwrite,
                            include: include.into_iter().map(Into::into).collect(),
                            config_path: resolved_config_path.clone(),
                        },
                    );
                    match plan {
                        Ok(plan) => render_plan(plan, &format),
                        Err(err) => {
                            eprintln!("Error: {err}");
                            std::process::exit(1);
                        }
                    }
                }
                SyncCommands::Pull {
                    target,
                    dry_run,
                    apply,
                    yes,
                    allow_overwrite,
                    include,
                    format,
                } => {
                    let mut dry_run = dry_run;
                    if apply {
                        dry_run = false;
                    } else if !dry_run {
                        dry_run = true;
                    }
                    let plan = build_sync_plan(
                        &config,
                        &layout,
                        SyncPlanOptions {
                            target,
                            direction: wa_core::config::SyncDirection::Pull,
                            dry_run,
                            apply,
                            yes,
                            allow_overwrite,
                            include: include.into_iter().map(Into::into).collect(),
                            config_path: resolved_config_path.clone(),
                        },
                    );
                    match plan {
                        Ok(plan) => render_plan(plan, &format),
                        Err(err) => {
                            eprintln!("Error: {err}");
                            std::process::exit(1);
                        }
                    }
                }
            }
        }

        Some(Commands::Rules { command }) => {
            handle_rules_command(
                command,
                &config,
                cli_config_arg.as_deref(),
                resolved_config_path.as_deref(),
                &layout,
            );
        }

        Some(Commands::Ext { command }) => {
            handle_ext_command(command, &config, resolved_config_path.as_deref());
        }

        Some(Commands::Record { command }) => match command {
            RecordCommands::Start {
                pane,
                title,
                auto_stop,
                output,
            } => {
                use wa_core::recording::{Recorder, RecordingOptions};

                let pane_id = pane.unwrap_or(0);
                let recordings_dir = layout.recordings_dir();
                std::fs::create_dir_all(&recordings_dir).map_err(|e| {
                    anyhow::anyhow!(
                        "Failed to create recordings directory '{}': {e}",
                        recordings_dir.display()
                    )
                })?;

                let out_path = output.unwrap_or_else(|| {
                    let ts = chrono::Utc::now().format("%Y%m%d-%H%M%S");
                    recordings_dir.join(format!("pane{pane_id}-{ts}.war"))
                });

                let auto_stop_ms = if let Some(ref dur) = auto_stop {
                    Some(wa_core::replay::parse_duration_ms(dur)?)
                } else {
                    None
                };

                let opts = RecordingOptions::default();
                let mut recorder = Recorder::new(pane_id, &out_path, opts.flush_threshold)?;
                let now_ms = chrono::Utc::now().timestamp_millis();
                recorder.start(now_ms);

                println!("Recording pane {pane_id} to {}", out_path.display());
                if let Some(ref t) = title {
                    println!("Title: {t}");
                }
                if let Some(ms) = auto_stop_ms {
                    println!("Auto-stop after {}s", ms / 1000);
                }
                println!("Press Ctrl+C to stop...");

                // Poll pane output via WezTerm CLI
                let wez = wa_core::wezterm::WeztermClient::new();
                let mut last_text = String::new();
                let start = std::time::Instant::now();

                loop {
                    if let Some(ms) = auto_stop_ms {
                        if start.elapsed().as_millis() as u64 >= ms {
                            break;
                        }
                    }

                    match wez.get_text(pane_id, false).await {
                        Ok(text) => {
                            if text != last_text {
                                let delta = if last_text.is_empty() {
                                    text.as_bytes().to_vec()
                                } else {
                                    // Simple: record full text each time (works for short sessions)
                                    text.as_bytes().to_vec()
                                };
                                let cap_ms = chrono::Utc::now().timestamp_millis();
                                if let Err(e) = recorder.record_output(cap_ms, false, &delta) {
                                    eprintln!("Recording error: {e}");
                                    break;
                                }
                                last_text = text;
                            }
                        }
                        Err(e) => {
                            eprintln!("Failed to capture pane {pane_id}: {e}");
                            break;
                        }
                    }

                    tokio::time::sleep(std::time::Duration::from_millis(200)).await;
                }

                recorder.stop()?;
                let stats = recorder.stats();
                println!(
                    "\nRecording stopped. {} frames, {} bytes written.",
                    stats.frames_written, stats.bytes_written
                );
                println!("Saved: {}", out_path.display());
            }

            RecordCommands::Stop { pane, all } => {
                // Stop requires IPC to the running watcher
                let _ = (pane, all);
                eprintln!(
                    "wa record stop: requires an active watcher with recording enabled.\n\
                     For standalone recordings started with `wa record start`, press Ctrl+C.\n\
                     To stop a watcher-managed recording, use `wa robot rpc record-stop`."
                );
                std::process::exit(1);
            }

            RecordCommands::List {
                limit,
                json: as_json,
            } => {
                let recordings_dir = layout.recordings_dir();
                let mut entries = Vec::new();

                if recordings_dir.is_dir() {
                    if let Ok(read_dir) = std::fs::read_dir(&recordings_dir) {
                        for entry in read_dir.flatten() {
                            let path = entry.path();
                            if path.extension().and_then(|e| e.to_str()) == Some("war") {
                                let metadata = std::fs::metadata(&path).ok();
                                let size = metadata.as_ref().map(|m| m.len()).unwrap_or(0);
                                let modified = metadata
                                    .as_ref()
                                    .and_then(|m| m.modified().ok())
                                    .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())
                                    .map(|d| d.as_millis() as i64)
                                    .unwrap_or(0);

                                // Try to load recording for frame count/duration
                                let (duration_ms, frame_count) =
                                    if let Ok(rec) = wa_core::replay::Recording::load(&path) {
                                        (rec.duration_ms, rec.frames.len())
                                    } else {
                                        (0, 0)
                                    };

                                entries.push((
                                    path.file_name()
                                        .unwrap_or_default()
                                        .to_string_lossy()
                                        .to_string(),
                                    path.clone(),
                                    size,
                                    modified,
                                    duration_ms,
                                    frame_count,
                                ));
                            }
                        }
                    }
                }

                // Sort by modification time descending
                entries.sort_by_key(|e| std::cmp::Reverse(e.3));
                entries.truncate(limit);

                if as_json {
                    let json_entries: Vec<_> = entries
                        .iter()
                        .map(|(name, path, size, _modified, duration_ms, frame_count)| {
                            serde_json::json!({
                                "name": name,
                                "path": path.display().to_string(),
                                "size_bytes": size,
                                "duration_ms": duration_ms,
                                "frame_count": frame_count,
                            })
                        })
                        .collect();
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&json_entries)
                            .unwrap_or_else(|_| "[]".to_string())
                    );
                } else if entries.is_empty() {
                    println!("No recordings found in {}", recordings_dir.display());
                } else {
                    println!(
                        "{:<40} {:>10} {:>8} {:>8}",
                        "Name", "Duration", "Frames", "Size"
                    );
                    println!("{}", "-".repeat(70));
                    for (name, _path, size, _modified, duration_ms, frame_count) in &entries {
                        let dur = format_duration_short(*duration_ms);
                        let sz = format_size_short(*size);
                        println!("{name:<40} {dur:>10} {frame_count:>8} {sz:>8}");
                    }
                    println!(
                        "\n{} recording(s) in {}",
                        entries.len(),
                        recordings_dir.display()
                    );
                }
            }

            RecordCommands::Info {
                file,
                json: as_json,
            } => {
                let recording = wa_core::replay::Recording::load(&file).map_err(|e| {
                    anyhow::anyhow!("Failed to load recording '{}': {e}", file.display())
                })?;
                let info = recording.info();

                if as_json {
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&info).unwrap_or_else(|_| "{}".to_string())
                    );
                } else {
                    println!("Recording: {}", file.display());
                    println!("Duration:  {}", format_duration_short(info.duration_ms));
                    println!("Terminal:  {}x{}", info.terminal_cols, info.terminal_rows);
                    println!("Frames:    {} total", info.frame_count);
                    println!("  Output:  {}", info.output_frames);
                    println!("  Resize:  {}", info.resize_frames);
                    println!("  Events:  {}", info.event_frames);
                    println!("  Markers: {}", info.marker_frames);
                    println!("  Input:   {}", info.input_frames);
                    println!(
                        "Size:      {} ({} bytes)",
                        format_size_short(info.total_bytes as u64),
                        info.total_bytes
                    );
                }
            }

            RecordCommands::Export {
                file,
                format,
                output,
                cols,
                rows,
                title,
                no_redact,
                redact_patterns,
            } => {
                use wa_core::replay::{
                    ExportFormat, ExportOptions, Recording, export_asciinema, export_html,
                };

                let recording = Recording::load(&file).map_err(|e| {
                    anyhow::anyhow!("Failed to load recording '{}': {e}", file.display())
                })?;

                let export_fmt = match format.to_lowercase().as_str() {
                    "asciinema" | "cast" => ExportFormat::Asciinema,
                    "html" => ExportFormat::Html,
                    other => {
                        eprintln!("Error: Unknown format '{other}'. Use 'asciinema' or 'html'.");
                        std::process::exit(1);
                    }
                };

                let opts = ExportOptions {
                    cols: cols.unwrap_or(80),
                    rows: rows.unwrap_or(24),
                    redact: !no_redact,
                    extra_redact_patterns: redact_patterns,
                    title,
                };

                match export_fmt {
                    ExportFormat::Asciinema => {
                        if let Some(ref path) = output {
                            let mut f = std::fs::File::create(path).map_err(|e| {
                                anyhow::anyhow!("Failed to create '{}': {e}", path.display())
                            })?;
                            let count = export_asciinema(&recording, &opts, &mut f)?;
                            eprintln!(
                                "Exported {count} events to {} (asciinema cast)",
                                path.display()
                            );
                        } else {
                            let stdout = std::io::stdout();
                            let mut handle = stdout.lock();
                            export_asciinema(&recording, &opts, &mut handle)?;
                        }
                    }
                    ExportFormat::Html => {
                        if let Some(ref path) = output {
                            let mut f = std::fs::File::create(path).map_err(|e| {
                                anyhow::anyhow!("Failed to create '{}': {e}", path.display())
                            })?;
                            let count = export_html(&recording, &opts, &mut f)?;
                            eprintln!(
                                "Exported {count} events to {} (HTML player)",
                                path.display()
                            );
                        } else {
                            let stdout = std::io::stdout();
                            let mut handle = stdout.lock();
                            export_html(&recording, &opts, &mut handle)?;
                        }
                    }
                }
            }
        },

        Some(Commands::Replay {
            file,
            speed,
            from,
            events_only,
            json: as_json,
        }) => {
            use wa_core::replay::{
                CollectorSink, DecodedFrame, HeadlessSink, PlaybackSpeed, Player, Recording,
                decode_frame,
            };

            let recording = Recording::load(&file).map_err(|e| {
                anyhow::anyhow!("Failed to load recording '{}': {e}", file.display())
            })?;

            let info = recording.info();

            if events_only {
                // Just list events and markers
                let base_ts = recording
                    .frames
                    .first()
                    .map(|f| f.header.timestamp_ms)
                    .unwrap_or(0);

                let mut events = Vec::new();
                for frame in &recording.frames {
                    let rel_ms = frame.header.timestamp_ms.saturating_sub(base_ts);
                    match decode_frame(frame)? {
                        DecodedFrame::Event(value) => {
                            events.push(serde_json::json!({
                                "time_ms": rel_ms,
                                "type": "event",
                                "data": value,
                            }));
                        }
                        DecodedFrame::Marker(text) => {
                            events.push(serde_json::json!({
                                "time_ms": rel_ms,
                                "type": "marker",
                                "text": text,
                            }));
                        }
                        _ => {}
                    }
                }

                if as_json {
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&events).unwrap_or_else(|_| "[]".to_string())
                    );
                } else if events.is_empty() {
                    println!("No events or markers in recording.");
                } else {
                    for ev in &events {
                        let t = ev["time_ms"].as_u64().unwrap_or(0);
                        let kind = ev["type"].as_str().unwrap_or("?");
                        let detail = if kind == "marker" {
                            ev["text"].as_str().unwrap_or("").to_string()
                        } else {
                            ev["data"].to_string()
                        };
                        println!("[{:>8}ms] {kind}: {detail}", t);
                    }
                }
            } else {
                // Full playback
                let playback_speed = PlaybackSpeed::new(speed as f32)
                    .map_err(|e| anyhow::anyhow!("Invalid speed {speed}: {e}"))?;

                let mut player = Player::new(recording);
                player.set_speed(playback_speed);

                // Seek if --from specified
                if let Some(ref from_str) = from {
                    let seek_ms = wa_core::replay::parse_duration_ms(from_str)?;
                    let mut seek_sink = HeadlessSink;
                    player.seek_to(seek_ms, &mut seek_sink)?;
                }

                if as_json {
                    // Collect all output and events
                    let mut sink = CollectorSink::new();
                    player.play_simple(&mut sink).await?;
                    let result = serde_json::json!({
                        "duration_ms": info.duration_ms,
                        "frames": info.frame_count,
                        "output_bytes": sink.output.len(),
                        "events": sink.events,
                        "markers": sink.markers,
                    });
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&result).unwrap_or_else(|_| "{}".to_string())
                    );
                } else {
                    eprintln!(
                        "Replaying {} ({}, {} frames, {speed}x speed)",
                        file.display(),
                        format_duration_short(info.duration_ms),
                        info.frame_count,
                    );

                    // Write output to stdout
                    struct StdoutSink;
                    impl wa_core::replay::OutputSink for StdoutSink {
                        fn write_output(&mut self, bytes: &[u8]) -> wa_core::Result<()> {
                            use std::io::Write;
                            std::io::stdout().write_all(bytes).map_err(|e| {
                                wa_core::Error::Runtime(format!("stdout write error: {e}"))
                            })
                        }
                        fn show_event(&mut self, event: &serde_json::Value) -> wa_core::Result<()> {
                            eprintln!("\n[event] {event}");
                            Ok(())
                        }
                        fn show_marker(&mut self, text: &str) -> wa_core::Result<()> {
                            eprintln!("\n[marker] {text}");
                            Ok(())
                        }
                    }

                    let mut sink = StdoutSink;
                    player.play_simple(&mut sink).await?;
                    eprintln!("\nReplay complete.");
                }
            }
        }

        Some(Commands::Reserve {
            pane_id,
            ttl,
            owner_kind,
            owner_id,
            reason,
            json,
        }) => {
            let db_path = layout.db_path.to_string_lossy();
            let storage = wa_core::storage::StorageHandle::new(&db_path).await?;

            let ttl_ms = (ttl * 1000) as i64;
            match storage
                .create_reservation(pane_id, &owner_kind, &owner_id, reason.as_deref(), ttl_ms)
                .await
            {
                Ok(r) => {
                    if json {
                        let info = RobotReservationInfo {
                            id: r.id,
                            pane_id: r.pane_id,
                            owner_kind: r.owner_kind,
                            owner_id: r.owner_id,
                            reason: r.reason,
                            created_at: r.created_at,
                            expires_at: r.expires_at,
                            released_at: r.released_at,
                            status: r.status,
                        };
                        println!(
                            "{}",
                            serde_json::to_string_pretty(&info)
                                .unwrap_or_else(|_| "{}".to_string())
                        );
                    } else {
                        println!("Reserved pane {} (id={})", r.pane_id, r.id);
                        println!("  Owner: {} ({})", r.owner_id, r.owner_kind);
                        if let Some(ref reason) = r.reason {
                            println!("  Reason: {reason}");
                        }
                        println!("  Expires: {} ms from now", r.expires_at - r.created_at);
                    }
                }
                Err(e) => {
                    eprintln!("Failed to reserve pane {pane_id}: {e}");
                    eprintln!("Hint: Use 'wa reservations' to see active reservations.");
                    std::process::exit(1);
                }
            }

            storage.shutdown().await?;
        }

        Some(Commands::Reservations { json }) => {
            let db_path = layout.db_path.to_string_lossy();
            let storage = wa_core::storage::StorageHandle::new(&db_path).await?;

            // Expire stale reservations first
            if let Err(e) = storage.expire_stale_reservations().await {
                tracing::warn!("Failed to expire stale reservations: {e}");
            }

            match storage.list_active_reservations().await {
                Ok(reservations) => {
                    if json {
                        let infos: Vec<RobotReservationInfo> = reservations
                            .into_iter()
                            .map(|r| RobotReservationInfo {
                                id: r.id,
                                pane_id: r.pane_id,
                                owner_kind: r.owner_kind,
                                owner_id: r.owner_id,
                                reason: r.reason,
                                created_at: r.created_at,
                                expires_at: r.expires_at,
                                released_at: r.released_at,
                                status: r.status,
                            })
                            .collect();
                        println!(
                            "{}",
                            serde_json::to_string_pretty(&infos)
                                .unwrap_or_else(|_| "[]".to_string())
                        );
                    } else if reservations.is_empty() {
                        println!("No active pane reservations.");
                    } else {
                        println!(
                            "{:<6} {:<8} {:<12} {:<16} {:<20} {}",
                            "ID", "PANE", "OWNER_KIND", "OWNER_ID", "REASON", "EXPIRES_IN"
                        );
                        let now = std::time::SystemTime::now()
                            .duration_since(std::time::UNIX_EPOCH)
                            .map_or(0, |d| d.as_millis() as i64);
                        for r in &reservations {
                            let remaining_secs = (r.expires_at - now) / 1000;
                            let mins = remaining_secs / 60;
                            let secs = remaining_secs % 60;
                            println!(
                                "{:<6} {:<8} {:<12} {:<16} {:<20} {}m {}s",
                                r.id,
                                r.pane_id,
                                r.owner_kind,
                                r.owner_id,
                                r.reason.as_deref().unwrap_or("-"),
                                mins,
                                secs,
                            );
                        }
                        println!("\n{} active reservation(s).", reservations.len());
                    }
                }
                Err(e) => {
                    eprintln!("Failed to list reservations: {e}");
                    std::process::exit(1);
                }
            }

            storage.shutdown().await?;
        }

        Some(Commands::Export {
            kind,
            pane_id,
            since,
            until,
            limit,
            actor,
            action,
            no_redact,
            pretty,
            output,
        }) => {
            use wa_core::export::{ExportKind, ExportOptions, export_jsonl};
            use wa_core::storage::ExportQuery;

            let export_kind = match ExportKind::from_str_loose(&kind) {
                Some(k) => k,
                None => {
                    eprintln!(
                        "Error: Unknown export kind '{kind}'. Valid kinds: {}",
                        ExportKind::all_names().join(", ")
                    );
                    std::process::exit(1);
                }
            };

            // Warn about audit-only filters on non-audit kinds
            if (actor.is_some() || action.is_some()) && export_kind != ExportKind::Audit {
                eprintln!(
                    "Warning: --actor and --action filters only apply to 'audit' exports; ignoring."
                );
            }

            // Warn about --no-redact
            if no_redact {
                eprintln!(
                    "WARNING: Redaction is disabled. Exported data may contain secrets \
                     (API keys, tokens, passwords). Handle output with care."
                );
            }

            // Get workspace layout for DB path
            let layout = match config.workspace_layout(Some(&workspace_root)) {
                Ok(l) => l,
                Err(e) => {
                    eprintln!("Error: Failed to get workspace layout: {e}");
                    eprintln!("Check --workspace or WA_WORKSPACE");
                    std::process::exit(1);
                }
            };

            // Open storage handle
            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => s,
                Err(e) => {
                    eprintln!("Error: Failed to open storage: {e}");
                    eprintln!("Is the database initialized? Run 'wa watch' first.");
                    std::process::exit(1);
                }
            };

            let opts = ExportOptions {
                kind: export_kind,
                query: ExportQuery {
                    pane_id,
                    since,
                    until,
                    limit,
                },
                audit_actor: actor,
                audit_action: action,
                redact: !no_redact,
                pretty,
            };

            // Determine output target
            let result = if let Some(ref path) = output {
                let mut file = match std::fs::File::create(path) {
                    Ok(f) => std::io::BufWriter::new(f),
                    Err(e) => {
                        eprintln!("Error: Failed to create output file '{path}': {e}");
                        std::process::exit(1);
                    }
                };
                export_jsonl(&storage, &opts, &mut file).await
            } else {
                // Collect to a Vec first to avoid holding stdout lock across await
                let mut buffer = Vec::new();
                let count = export_jsonl(&storage, &opts, &mut buffer).await;
                // Now write to stdout synchronously
                {
                    use std::io::Write;
                    let stdout = std::io::stdout();
                    let mut handle = stdout.lock();
                    if let Err(e) = handle.write_all(&buffer) {
                        eprintln!("Error: Failed to write to stdout: {e}");
                        std::process::exit(1);
                    }
                }
                count
            };

            match result {
                Ok(count) => {
                    if let Some(ref path) = output {
                        eprintln!(
                            "Exported {count} {kind} record(s) to {path}{}",
                            if !no_redact { " (redacted)" } else { "" }
                        );
                    } else {
                        eprintln!(
                            "Exported {count} {kind} record(s){}",
                            if !no_redact { " (redacted)" } else { "" }
                        );
                    }
                }
                Err(e) => {
                    eprintln!("Error: Export failed: {e}");
                    std::process::exit(1);
                }
            }

            storage.shutdown().await?;
        }

        Some(Commands::Auth { command }) => {
            handle_auth_command(command, &layout, cli.verbose > 0).await?;
        }

        Some(Commands::Accounts {
            format,
            service,
            pick,
            command,
        }) => {
            use wa_core::output::{
                AccountListRenderer, OutputFormat, RenderContext, detect_format,
            };

            let output_format = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            let die = |msg: &str, hint: Option<&str>| -> ! {
                if output_format.is_json() {
                    let mut payload = serde_json::json!({
                        "ok": false,
                        "error": msg,
                        "version": wa_core::VERSION,
                    });
                    if let Some(h) = hint {
                        payload["hint"] = serde_json::Value::String(h.to_string());
                    }
                    println!(
                        "{}",
                        serde_json::to_string(&payload).unwrap_or_else(|_| "{}".to_string())
                    );
                } else {
                    eprintln!("Error: {msg}");
                    if let Some(h) = hint {
                        eprintln!("{h}");
                    }
                }
                std::process::exit(1);
            };

            // Handle refresh subcommand
            if let Some(AccountsCommands::Refresh {
                service: ref_service,
            }) = command
            {
                let caut_service = match ref_service.as_str() {
                    "openai" => wa_core::caut::CautService::OpenAI,
                    other => {
                        die(
                            &format!("Unknown service: {other}"),
                            Some("Supported services: openai"),
                        );
                    }
                };

                // Open storage for rate-limit check
                let db_path = layout.db_path.to_string_lossy();
                if let Ok(storage_check) = wa_core::storage::StorageHandle::new(&db_path).await {
                    if let Ok(accounts) = storage_check.get_accounts_by_service(&ref_service).await
                    {
                        let now_check = now_ms_i64();
                        let most_recent = accounts
                            .iter()
                            .map(|a| a.last_refreshed_at)
                            .max()
                            .unwrap_or(0);
                        // 60-second cooldown
                        let cooldown_ms: i64 = 60_000;
                        let elapsed_ms_val = now_check.saturating_sub(most_recent);
                        if elapsed_ms_val < cooldown_ms && most_recent > 0 {
                            let wait_secs = (cooldown_ms - elapsed_ms_val) / 1000 + 1;
                            die(
                                &format!(
                                    "Refresh rate limited: last refresh was {}s ago",
                                    elapsed_ms_val / 1000
                                ),
                                Some(&format!(
                                    "Wait {wait_secs}s before refreshing again, or use 'wa accounts' to see cached data."
                                )),
                            );
                        }
                    }
                    let _ = storage_check.shutdown().await;
                }

                // Call caut refresh
                let caut = wa_core::caut::CautClient::new();
                let refresh_result = match caut.refresh(caut_service).await {
                    Ok(r) => r,
                    Err(e) => {
                        die(
                            &format!("caut refresh failed: {e}"),
                            Some(&e.remediation().summary),
                        );
                    }
                };

                // Persist refreshed data
                let db_path = layout.db_path.to_string_lossy();
                let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                    Ok(s) => s,
                    Err(e) => {
                        die(
                            &format!("Failed to open storage: {e}"),
                            Some("Is the database initialized? Run 'wa watch' first."),
                        );
                    }
                };

                let now = now_ms_i64();
                let mut count = 0usize;
                for usage in &refresh_result.accounts {
                    let record =
                        wa_core::accounts::AccountRecord::from_caut(usage, caut_service, now);
                    if let Err(e) = storage.upsert_account(record.clone()).await {
                        tracing::warn!("Failed to upsert account {}: {e}", record.account_id);
                    }
                    count += 1;
                }

                // Now render the refreshed list
                let accounts = storage
                    .get_accounts_by_service(&ref_service)
                    .await
                    .unwrap_or_default();

                let pick_result = if pick {
                    let sel_config = wa_core::accounts::AccountSelectionConfig::default();
                    Some(wa_core::accounts::select_account(&accounts, &sel_config))
                } else {
                    None
                };

                let ctx = RenderContext::new(output_format).verbose(cli.verbose);
                let rendered = AccountListRenderer::render(
                    &accounts,
                    pick_result.as_ref(),
                    &ref_service,
                    &ctx,
                );

                if !output_format.is_json() {
                    eprintln!("Refreshed {count} account(s) for service \"{ref_service}\"");
                }
                print!("{rendered}");

                if let Err(e) = storage.shutdown().await {
                    tracing::warn!("Failed to shutdown storage cleanly: {e}");
                }
            } else {
                // Default: list accounts
                let db_path = layout.db_path.to_string_lossy();
                let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                    Ok(s) => s,
                    Err(e) => {
                        die(
                            &format!("Failed to open storage: {e}"),
                            Some("Is the database initialized? Run 'wa watch' first."),
                        );
                    }
                };

                let accounts = match storage.get_accounts_by_service(&service).await {
                    Ok(a) => a,
                    Err(e) => {
                        die(&format!("Failed to fetch accounts: {e}"), None);
                    }
                };

                let pick_result = if pick {
                    let sel_config = wa_core::accounts::AccountSelectionConfig::default();
                    Some(wa_core::accounts::select_account(&accounts, &sel_config))
                } else {
                    None
                };

                let ctx = RenderContext::new(output_format).verbose(cli.verbose);
                let rendered =
                    AccountListRenderer::render(&accounts, pick_result.as_ref(), &service, &ctx);
                print!("{rendered}");

                if let Err(e) = storage.shutdown().await {
                    tracing::warn!("Failed to shutdown storage cleanly: {e}");
                }
            }
        }

        Some(Commands::Triage {
            format,
            severity,
            only,
            details: details_flag,
        }) => {
            use wa_core::output::{OutputFormat, detect_format};

            let output_format = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            let show_all = only.is_none();
            let section = only.as_deref().unwrap_or("");

            // Collect triage items as JSON values for uniform sorting/filtering
            let mut items: Vec<serde_json::Value> = Vec::new();

            // 1. Health diagnostics (in-process snapshot or persisted fallback)
            if show_all || section == "health" {
                let snapshot = wa_core::crash::HealthSnapshot::get_global().or_else(|| {
                    let path = layout.wa_dir.join("health_snapshot.json");
                    fs::read_to_string(&path).ok().and_then(|data| {
                        serde_json::from_str::<wa_core::crash::HealthSnapshot>(&data).ok()
                    })
                });

                if let Some(snapshot) = snapshot {
                    use wa_core::output::{HealthDiagnosticStatus, HealthSnapshotRenderer};
                    let checks = HealthSnapshotRenderer::diagnostic_checks(&snapshot);
                    for hc in &checks {
                        let sev = match hc.status {
                            HealthDiagnosticStatus::Error => "error",
                            HealthDiagnosticStatus::Warning => "warning",
                            _ => continue, // skip OK/info health checks in triage
                        };
                        items.push(serde_json::json!({
                            "section": "health",
                            "severity": sev,
                            "title": hc.name,
                            "detail": hc.detail,
                            "action": "wa doctor",
                            "actions": [
                                {"command": "wa doctor", "label": "Run diagnostics"},
                                {"command": "wa doctor --json", "label": "Machine-readable diagnostics"},
                            ],
                        }));
                    }
                }
            }

            // 2. Recent crash bundles
            if show_all || section == "crashes" {
                if let Some(bundle) = wa_core::crash::latest_crash_bundle(&layout.crash_dir) {
                    let detail = if let Some(ref report) = bundle.report {
                        let msg = if report.message.len() > 100 {
                            format!("{}...", &report.message[..97])
                        } else {
                            report.message.clone()
                        };
                        format!(
                            "{msg} (at {})",
                            report.location.as_deref().unwrap_or("unknown")
                        )
                    } else if let Some(ref manifest) = bundle.manifest {
                        format!("crash at {}", manifest.created_at)
                    } else {
                        "crash bundle found".to_string()
                    };
                    items.push(serde_json::json!({
                        "section": "crashes",
                        "severity": "warning",
                        "title": "Recent crash",
                        "detail": detail,
                        "action": "wa reproduce export --kind crash",
                        "actions": [
                            {"command": "wa reproduce export --kind crash", "label": "Export incident bundle"},
                            {"command": "wa doctor", "label": "Check system health"},
                        ],
                        "explain": format!(
                            "ls {}",
                            bundle.path.display()
                        ),
                        "bundle_path": bundle.path.display().to_string(),
                    }));
                }
            }

            // 3. Unhandled events + 4. Incomplete workflows (both need DB)
            let needs_db = show_all || section == "events" || section == "workflows";
            if needs_db {
                let db_path = layout.db_path.to_string_lossy();
                let storage_result = wa_core::storage::StorageHandle::new(&db_path).await;

                match storage_result {
                    Ok(storage) => {
                        // Fetch active mutes for noise control annotations
                        let now_triage = now_ms_i64();
                        let active_mutes = storage
                            .list_active_mutes(now_triage)
                            .await
                            .unwrap_or_default();
                        let muted_keys: std::collections::HashSet<String> = active_mutes
                            .iter()
                            .map(|m| m.identity_key.clone())
                            .collect();

                        // Unhandled events
                        if show_all || section == "events" {
                            let query = wa_core::storage::EventQuery {
                                limit: Some(20),
                                pane_id: None,
                                rule_id: None,
                                event_type: None,
                                triage_state: None,
                                label: None,
                                unhandled_only: true,
                                since: None,
                                until: None,
                            };
                            if let Ok(events) = storage.get_events(query).await {
                                for event in &events {
                                    let is_muted = event
                                        .dedupe_key
                                        .as_ref()
                                        .is_some_and(|k| muted_keys.contains(k));

                                    let mut actions = vec![
                                        serde_json::json!({
                                            "command": format!(
                                                "wa events --pane {} --unhandled",
                                                event.pane_id
                                            ),
                                            "label": "List unhandled events"
                                        }),
                                        serde_json::json!({
                                            "command": format!(
                                                "wa why --recent --pane {}",
                                                event.pane_id
                                            ),
                                            "label": "Explain detection"
                                        }),
                                        serde_json::json!({
                                            "command": format!(
                                                "wa show {}",
                                                event.pane_id
                                            ),
                                            "label": "Show pane details"
                                        }),
                                    ];
                                    if !is_muted {
                                        if let Some(ref key) = event.dedupe_key {
                                            actions.push(serde_json::json!({
                                                "command": format!(
                                                    "wa mute add {} --for 1h",
                                                    key
                                                ),
                                                "label": "Mute for 1 hour"
                                            }));
                                        }
                                    }

                                    items.push(serde_json::json!({
                                        "section": "events",
                                        "severity": event.severity,
                                        "title": format!(
                                            "{}[pane {}] {}: {}",
                                            if is_muted { "(muted) " } else { "" },
                                            event.pane_id,
                                            event.event_type,
                                            event.rule_id
                                        ),
                                        "detail": event.matched_text
                                            .as_deref()
                                            .unwrap_or("")
                                            .chars()
                                            .take(120)
                                            .collect::<String>(),
                                        "action": format!(
                                            "wa events --pane {} --unhandled",
                                            event.pane_id
                                        ),
                                        "actions": actions,
                                        "explain": format!(
                                            "wa why --recent --pane {}",
                                            event.pane_id
                                        ),
                                        "event_id": event.id,
                                        "pane_id": event.pane_id,
                                        "detected_at": event.detected_at,
                                        "muted": is_muted,
                                    }));
                                }
                            }
                        }

                        // Incomplete workflows
                        if show_all || section == "workflows" {
                            if let Ok(workflows) = storage.find_incomplete_workflows().await {
                                for wf in &workflows {
                                    items.push(serde_json::json!({
                                        "section": "workflows",
                                        "severity": "info",
                                        "title": format!(
                                            "{} (pane {})",
                                            wf.workflow_name, wf.pane_id
                                        ),
                                        "detail": format!(
                                            "status={}, step={}",
                                            wf.status, wf.current_step
                                        ),
                                        "action": format!(
                                            "wa workflow status {}",
                                            wf.id
                                        ),
                                        "actions": [
                                            {
                                                "command": format!(
                                                    "wa workflow status {}",
                                                    wf.id
                                                ),
                                                "label": "Check workflow status"
                                            },
                                            {
                                                "command": format!(
                                                    "wa why --recent --pane {}",
                                                    wf.pane_id
                                                ),
                                                "label": "Explain decisions"
                                            },
                                            {
                                                "command": format!(
                                                    "wa show {}",
                                                    wf.pane_id
                                                ),
                                                "label": "Show pane details"
                                            },
                                        ],
                                        "explain": format!(
                                            "wa why --recent --pane {}",
                                            wf.pane_id
                                        ),
                                        "workflow_id": wf.id,
                                        "pane_id": wf.pane_id,
                                        "started_at": wf.started_at,
                                    }));
                                }
                            }
                        }

                        // Noise control summary
                        if (show_all || section == "mutes") && !active_mutes.is_empty() {
                            items.push(serde_json::json!({
                                "section": "mutes",
                                "severity": "info",
                                "title": format!(
                                    "{} active mute(s) suppressing notifications",
                                    active_mutes.len()
                                ),
                                "detail": active_mutes.iter().take(5).map(|m| {
                                    let expiry = match m.expires_at {
                                        Some(ts) => {
                                            let remaining_s = (ts - now_triage) / 1000;
                                            if remaining_s < 3600 {
                                                format!("{}m left", remaining_s / 60)
                                            } else {
                                                format!("{}h left", remaining_s / 3600)
                                            }
                                        }
                                        None => "permanent".to_string(),
                                    };
                                    format!("{} ({})", m.identity_key, expiry)
                                }).collect::<Vec<_>>().join(", "),
                                "action": "wa mute list",
                                "actions": [
                                    {"command": "wa mute list", "label": "List all mutes"},
                                    {"command": "wa mute list --format json", "label": "JSON output"},
                                ],
                            }));
                        }
                    }
                    Err(e) => {
                        items.push(serde_json::json!({
                            "section": "health",
                            "severity": "warning",
                            "title": "Database unavailable",
                            "detail": format!(
                                "Could not open storage: {e}"
                            ),
                            "action": "wa watch",
                            "actions": [
                                {"command": "wa watch", "label": "Start the watcher daemon"},
                                {"command": "wa doctor", "label": "Run diagnostics"},
                            ],
                        }));
                    }
                }
            }

            // Severity ranking for sorting/filtering
            let severity_rank = |s: &str| -> u8 {
                match s {
                    "error" => 3,
                    "warning" => 2,
                    "info" => 1,
                    _ => 0,
                }
            };

            // Apply severity filter
            if let Some(ref min_sev) = severity {
                let min_rank = severity_rank(min_sev);
                items.retain(|item| {
                    let sev = item["severity"].as_str().unwrap_or("info");
                    severity_rank(sev) >= min_rank
                });
            }

            // Sort: errors first, then warnings, then info
            items.sort_by(|a, b| {
                let sa = severity_rank(a["severity"].as_str().unwrap_or("info"));
                let sb = severity_rank(b["severity"].as_str().unwrap_or("info"));
                sb.cmp(&sa)
            });

            // Render output
            if output_format.is_json() {
                let result = serde_json::json!({
                    "ok": true,
                    "version": wa_core::VERSION,
                    "total": items.len(),
                    "items": items,
                });
                println!(
                    "{}",
                    serde_json::to_string_pretty(&result).unwrap_or_else(|_| "{}".to_string())
                );
            } else if items.is_empty() {
                println!("wa triage - Nothing needs attention\n");
                println!("All clear. No unhandled events, crashes, or health issues.");
            } else {
                println!("wa triage - {} item(s) need attention\n", items.len());

                let mut current_section = "";
                for item in &items {
                    let sec = item["section"].as_str().unwrap_or("unknown");
                    if sec != current_section {
                        if !current_section.is_empty() {
                            println!();
                        }
                        let header = match sec {
                            "health" => "Health Issues",
                            "crashes" => "Recent Crashes",
                            "events" => "Unhandled Events",
                            "workflows" => "Active Workflows",
                            "mutes" => "Noise Control",
                            _ => sec,
                        };
                        println!("{header}:");
                        current_section = sec;
                    }

                    let sev = item["severity"].as_str().unwrap_or("info");
                    let icon = match sev {
                        "error" => "[ERROR]",
                        "warning" => "[WARN] ",
                        _ => "[INFO] ",
                    };
                    let title = item["title"].as_str().unwrap_or("");
                    println!("  {icon} {title}");

                    let is_verbose = details_flag || cli.verbose > 0;

                    if is_verbose {
                        if let Some(detail) = item["detail"].as_str() {
                            if !detail.is_empty() {
                                println!("         {detail}");
                            }
                        }
                    }

                    // Show primary action always
                    if let Some(action) = item["action"].as_str() {
                        println!("         -> {action}");
                    }

                    // In verbose mode, show additional actions and explain link
                    if is_verbose {
                        if let Some(actions) = item["actions"].as_array() {
                            // Skip first action (already shown as primary)
                            for extra in actions.iter().skip(1) {
                                if let (Some(cmd), Some(label)) =
                                    (extra["command"].as_str(), extra["label"].as_str())
                                {
                                    println!("            {label}: {cmd}");
                                }
                            }
                        }
                        if let Some(explain) = item["explain"].as_str() {
                            println!("         ?? {explain}");
                        }
                    }
                }

                println!();
                let errors = items.iter().filter(|i| i["severity"] == "error").count();
                let warnings = items.iter().filter(|i| i["severity"] == "warning").count();
                let infos = items.len() - errors - warnings;
                let mut parts = Vec::new();
                if errors > 0 {
                    parts.push(format!("{errors} error(s)"));
                }
                if warnings > 0 {
                    parts.push(format!("{warnings} warning(s)"));
                }
                if infos > 0 {
                    parts.push(format!("{infos} info"));
                }
                println!("Summary: {}", parts.join(", "));
            }
        }

        Some(Commands::Mute { command }) => {
            use wa_core::output::OutputFormat;
            use wa_core::storage::EventMuteRecord;

            let layout = match config.workspace_layout(Some(&workspace_root)) {
                Ok(l) => l,
                Err(e) => {
                    eprintln!("Error: Failed to get workspace layout: {e}");
                    eprintln!("Check --workspace or WA_WORKSPACE");
                    std::process::exit(1);
                }
            };

            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => s,
                Err(e) => {
                    eprintln!("Error: Failed to open storage: {e}");
                    eprintln!("Is the database initialized? Run 'wa watch' first.");
                    std::process::exit(1);
                }
            };

            match command {
                MuteCommands::Add {
                    identity_key,
                    r#for: duration,
                    scope,
                    reason,
                    format,
                } => {
                    let fmt = resolve_prepare_output_format(&format);
                    let now = now_ms_i64();
                    let expires_at = match duration {
                        Some(ref dur) => match parse_duration_to_ms(dur) {
                            Some(ms) => Some(now + ms),
                            None => {
                                eprintln!(
                                    "Error: Invalid duration '{dur}'. Use e.g. 30s, 5m, 1h, 7d, 2w."
                                );
                                std::process::exit(1);
                            }
                        },
                        None => None,
                    };

                    let record = EventMuteRecord {
                        identity_key: identity_key.clone(),
                        scope: scope.clone(),
                        created_at: now,
                        expires_at,
                        created_by: Some("cli".to_string()),
                        reason: reason.clone(),
                    };

                    if let Err(e) = storage.add_event_mute(record).await {
                        eprintln!("Error: Failed to add mute: {e}");
                        std::process::exit(1);
                    }

                    match fmt {
                        OutputFormat::Json => {
                            let obj = serde_json::json!({
                                "status": "muted",
                                "identity_key": identity_key,
                                "scope": scope,
                                "expires_at": expires_at,
                                "reason": reason,
                            });
                            println!("{}", serde_json::to_string_pretty(&obj).unwrap());
                        }
                        _ => {
                            let expiry_desc = match expires_at {
                                Some(ts) => format!("until epoch ms {ts}"),
                                None => "permanently".to_string(),
                            };
                            println!("Muted event key '{identity_key}' ({scope}) {expiry_desc}");
                            if let Some(ref r) = reason {
                                println!("Reason: {r}");
                            }
                        }
                    }
                }

                MuteCommands::Remove {
                    identity_key,
                    format,
                } => {
                    let fmt = resolve_prepare_output_format(&format);

                    match storage.remove_event_mute(&identity_key).await {
                        Ok(removed) => match fmt {
                            OutputFormat::Json => {
                                let obj = serde_json::json!({
                                    "status": if removed { "removed" } else { "not_found" },
                                    "identity_key": identity_key,
                                });
                                println!("{}", serde_json::to_string_pretty(&obj).unwrap());
                            }
                            _ => {
                                if removed {
                                    println!("Unmuted event key '{identity_key}'");
                                } else {
                                    println!("No active mute found for '{identity_key}'");
                                }
                            }
                        },
                        Err(e) => {
                            eprintln!("Error: Failed to remove mute: {e}");
                            std::process::exit(1);
                        }
                    }
                }

                MuteCommands::List { format } => {
                    let fmt = resolve_prepare_output_format(&format);
                    let now = now_ms_i64();

                    match storage.list_active_mutes(now).await {
                        Ok(mutes) => match fmt {
                            OutputFormat::Json => {
                                let arr: Vec<serde_json::Value> = mutes
                                    .iter()
                                    .map(|m| {
                                        serde_json::json!({
                                            "identity_key": m.identity_key,
                                            "scope": m.scope,
                                            "created_at": m.created_at,
                                            "expires_at": m.expires_at,
                                            "created_by": m.created_by,
                                            "reason": m.reason,
                                        })
                                    })
                                    .collect();
                                println!("{}", serde_json::to_string_pretty(&arr).unwrap());
                            }
                            _ => {
                                if mutes.is_empty() {
                                    println!("No active mutes.");
                                } else {
                                    println!(
                                        "{:<44}  {:<12}  {:<14}  {}",
                                        "IDENTITY KEY", "SCOPE", "EXPIRES", "REASON"
                                    );
                                    for m in &mutes {
                                        let expires = match m.expires_at {
                                            Some(ts) => {
                                                let remaining_s = (ts - now) / 1000;
                                                if remaining_s < 60 {
                                                    format!("{remaining_s}s")
                                                } else if remaining_s < 3600 {
                                                    format!("{}m", remaining_s / 60)
                                                } else if remaining_s < 86400 {
                                                    format!("{}h", remaining_s / 3600)
                                                } else {
                                                    format!("{}d", remaining_s / 86400)
                                                }
                                            }
                                            None => "permanent".to_string(),
                                        };
                                        let reason = m.reason.as_deref().unwrap_or("-");
                                        println!(
                                            "{:<44}  {:<12}  {:<14}  {}",
                                            m.identity_key, m.scope, expires, reason
                                        );
                                    }
                                    println!("\n{} active mute(s)", mutes.len());
                                }
                            }
                        },
                        Err(e) => {
                            eprintln!("Error: Failed to list mutes: {e}");
                            std::process::exit(1);
                        }
                    }
                }
            }
        }

        #[cfg(feature = "web")]
        Some(Commands::Web { port }) => {
            let config = wa_core::web::WebServerConfig::new(port);
            wa_core::web::run_web_server(config).await?;
        }

        #[cfg(all(feature = "tui", not(feature = "rollout")))]
        Some(Commands::Tui { debug, refresh }) => {
            use std::time::Duration;
            use wa_core::tui::{AppConfig, ProductionQueryClient, run_tui};

            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => s,
                Err(e) => {
                    // Route through tracing, not raw eprintln (FTUI-03.2.a).
                    tracing::error!(%e, "Failed to open storage for TUI");
                    return Err(e.into());
                }
            };

            let tui_config = AppConfig {
                refresh_interval: Duration::from_secs(refresh),
                debug,
            };

            // Spawn TUI in a blocking thread to completely isolate it from
            // the main async runtime. The ProductionQueryClient creates its
            // own dedicated runtime for async operations.
            let layout_clone = layout.clone();
            let result = tokio::task::spawn_blocking(move || {
                let query_client = ProductionQueryClient::with_storage(layout_clone, storage);
                run_tui(query_client, tui_config)
            })
            .await
            .map_err(|e| anyhow::anyhow!("TUI thread panicked: {e}"))?;

            if let Err(e) = result {
                // Route through tracing, not raw eprintln (FTUI-03.2.a).
                tracing::error!(%e, "TUI runtime error");
                return Err(e.into());
            }
        }

        #[cfg(all(feature = "ftui", not(feature = "tui"), not(feature = "rollout")))]
        Some(Commands::Tui { debug, refresh }) => {
            use std::time::Duration;
            use wa_core::tui::{AppConfig, ProductionQueryClient, run_tui};

            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => s,
                Err(e) => {
                    // Route through tracing, not raw eprintln (FTUI-03.2.a).
                    tracing::error!(%e, "Failed to open storage for TUI");
                    return Err(e.into());
                }
            };

            let tui_config = AppConfig {
                refresh_interval: Duration::from_secs(refresh),
                debug,
            };

            let layout_clone = layout.clone();
            let result = tokio::task::spawn_blocking(move || {
                let query_client = ProductionQueryClient::with_storage(layout_clone, storage);
                run_tui(query_client, tui_config)
            })
            .await
            .map_err(|e| anyhow::anyhow!("TUI thread panicked: {e}"))?;

            if let Err(e) = result {
                // Route through tracing, not raw eprintln (FTUI-03.2.a).
                tracing::error!(%e, "TUI runtime error");
                return Err(e.into());
            }
        }

        // Rollout mode: both backends compiled, runtime selection via WA_TUI_BACKEND.
        // See docs/ftui-rollout-strategy.md for stage details. (FTUI-09.2)
        #[cfg(feature = "rollout")]
        Some(Commands::Tui { debug, refresh }) => {
            use std::time::Duration;
            use wa_core::tui::{AppConfig, ProductionQueryClient, run_tui, select_backend};

            let backend = select_backend();
            tracing::info!(%backend, "TUI rollout mode  backend selected");

            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => s,
                Err(e) => {
                    tracing::error!(%e, "Failed to open storage for TUI");
                    return Err(e.into());
                }
            };

            let tui_config = AppConfig {
                refresh_interval: Duration::from_secs(refresh),
                debug,
            };

            let layout_clone = layout.clone();
            let result = tokio::task::spawn_blocking(move || {
                let query_client = ProductionQueryClient::with_storage(layout_clone, storage);
                run_tui(query_client, tui_config)
            })
            .await
            .map_err(|e| anyhow::anyhow!("TUI thread panicked: {e}"))?;

            if let Err(e) = result {
                tracing::error!(%e, %backend, "TUI runtime error (rollout mode)");
                return Err(e.into());
            }
        }

        Some(Commands::Analytics {
            command,
            period,
            format,
        }) => {
            use wa_core::output::{
                AnalyticsAgentRenderer, AnalyticsDailyRenderer, AnalyticsExportRenderer,
                AnalyticsSummaryData, AnalyticsSummaryRenderer, OutputFormat, RenderContext,
                detect_format,
            };
            use wa_core::storage::MetricQuery;

            let output_format = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            let period_ms = parse_period_ms(&period);
            let since_ts = now_epoch_ms() - period_ms;
            let period_label = format_period_label(&period);

            let db_path = layout.db_path.to_string_lossy();
            let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
                Ok(s) => s,
                Err(e) => {
                    if output_format.is_json() {
                        println!(
                            r#"{{"ok": false, "error": "Failed to open storage: {}", "version": "{}"}}"#,
                            e,
                            wa_core::VERSION
                        );
                    } else {
                        eprintln!("Error: Failed to open storage: {e}");
                        eprintln!("Is the database initialized? Run 'wa watch' first.");
                    }
                    std::process::exit(1);
                }
            };

            let ctx = RenderContext::new(output_format);

            match command {
                Some(AnalyticsCommands::Daily) => {
                    let days = storage.aggregate_daily_metrics(since_ts).await?;
                    print!("{}", AnalyticsDailyRenderer::render(&days, &ctx));
                }
                Some(AnalyticsCommands::ByAgent) => {
                    let agents = storage.aggregate_by_agent(since_ts).await?;
                    print!("{}", AnalyticsAgentRenderer::render(&agents, &ctx));
                }
                Some(AnalyticsCommands::Export {
                    format: export_format,
                    output: output_path,
                }) => {
                    let metrics = storage
                        .query_usage_metrics(MetricQuery {
                            since: Some(since_ts),
                            ..Default::default()
                        })
                        .await?;

                    let rendered = match export_format.to_lowercase().as_str() {
                        "csv" => AnalyticsExportRenderer::render_csv(&metrics),
                        _ => AnalyticsExportRenderer::render_json(&metrics),
                    };

                    if let Some(path) = output_path {
                        std::fs::write(&path, &rendered)?;
                        eprintln!("Exported {} metrics to {path}", metrics.len());
                    } else {
                        print!("{rendered}");
                    }
                }
                None => {
                    // Default: summary view
                    let query_tokens = MetricQuery {
                        metric_type: Some(wa_core::storage::MetricType::TokenUsage),
                        since: Some(since_ts),
                        ..Default::default()
                    };
                    let query_cost = MetricQuery {
                        metric_type: Some(wa_core::storage::MetricType::ApiCost),
                        since: Some(since_ts),
                        ..Default::default()
                    };
                    let query_rl = MetricQuery {
                        metric_type: Some(wa_core::storage::MetricType::RateLimitHit),
                        since: Some(since_ts),
                        ..Default::default()
                    };
                    let query_wf = MetricQuery {
                        metric_type: Some(wa_core::storage::MetricType::WorkflowCost),
                        since: Some(since_ts),
                        ..Default::default()
                    };

                    let token_metrics = storage.query_usage_metrics(query_tokens).await?;
                    let cost_metrics = storage.query_usage_metrics(query_cost).await?;
                    let rl_metrics = storage.query_usage_metrics(query_rl).await?;
                    let wf_metrics = storage.query_usage_metrics(query_wf).await?;

                    let total_tokens: i64 = token_metrics.iter().filter_map(|m| m.tokens).sum();
                    let total_cost: f64 = cost_metrics.iter().filter_map(|m| m.amount).sum();
                    let rate_limit_hits: i64 = rl_metrics.iter().filter_map(|m| m.count).sum();
                    let workflow_runs: i64 = i64::try_from(wf_metrics.len()).unwrap_or(0);

                    let summary = AnalyticsSummaryData {
                        period_label,
                        total_tokens,
                        total_cost,
                        rate_limit_hits,
                        workflow_runs,
                    };

                    print!("{}", AnalyticsSummaryRenderer::render(&summary, &ctx));
                }
            }
        }

        Some(Commands::Simulate { command }) => match command {
            SimulateCommands::Run {
                scenario,
                speed,
                json,
            } => {
                use wa_core::simulation::Scenario;
                use wa_core::wezterm::{MockWezterm, WeztermInterface};

                let scenario = Scenario::load(&scenario)?;
                let mock = MockWezterm::new();
                scenario.setup(&mock).await?;

                if json {
                    // Output scenario metadata
                    let meta = serde_json::json!({
                        "name": scenario.name,
                        "description": scenario.description,
                        "duration_ms": scenario.duration.as_millis() as u64,
                        "pane_count": scenario.panes.len(),
                        "event_count": scenario.events.len(),
                        "expectation_count": scenario.expectations.len(),
                    });
                    println!("{}", serde_json::to_string_pretty(&meta)?);
                } else {
                    println!("Simulation: {}", scenario.name);
                    if !scenario.description.is_empty() {
                        println!("  {}", scenario.description);
                    }
                    println!(
                        "  Panes: {}  Events: {}  Duration: {:.1}s  Speed: {speed}x",
                        scenario.panes.len(),
                        scenario.events.len(),
                        scenario.duration.as_secs_f64(),
                    );
                    println!();
                }

                // Execute events with timing
                let speed_factor = if speed > 0.0 { speed } else { 1.0 };
                let start = std::time::Instant::now();

                for (i, event) in scenario.events.iter().enumerate() {
                    // Wait until the scaled time for this event
                    let target_elapsed =
                        std::time::Duration::from_secs_f64(event.at.as_secs_f64() / speed_factor);
                    let actual_elapsed = start.elapsed();
                    if let Some(wait) = target_elapsed.checked_sub(actual_elapsed) {
                        tokio::time::sleep(wait).await;
                    }

                    let mock_event = Scenario::to_mock_event(event)?;
                    mock.inject(event.pane, mock_event).await?;

                    if json {
                        let ev = serde_json::json!({
                            "index": i,
                            "at_ms": event.at.as_millis() as u64,
                            "pane": event.pane,
                            "action": format!("{:?}", event.action),
                        });
                        println!("{}", serde_json::to_string(&ev)?);
                    } else {
                        let action_str = match &event.action {
                            wa_core::simulation::EventAction::Append => "append",
                            wa_core::simulation::EventAction::Clear => "clear",
                            wa_core::simulation::EventAction::SetTitle => "set_title",
                            wa_core::simulation::EventAction::Resize => "resize",
                            wa_core::simulation::EventAction::Marker => "marker",
                        };
                        println!(
                            "  [{:>6.1}s] pane {} \u{2192} {}",
                            event.at.as_secs_f64(),
                            event.pane,
                            action_str,
                        );
                    }
                }

                // Check expectations
                let mut pass_count = 0;
                let mut fail_count = 0;
                for exp in &scenario.expectations {
                    match &exp.kind {
                        wa_core::simulation::ExpectationKind::Contains { pane, text } => {
                            let content = mock.get_text(*pane, false).await.unwrap_or_default();
                            if content.contains(text) {
                                pass_count += 1;
                                if !json {
                                    println!("  \u{2713} pane {} contains \"{}\"", pane, text);
                                }
                            } else {
                                fail_count += 1;
                                if !json {
                                    eprintln!("  \u{2717} pane {} missing \"{}\"", pane, text);
                                }
                            }
                        }
                        _ => {
                            // Event/Workflow expectations need pattern engine integration
                            if !json {
                                println!("  - expectation skipped (needs pattern engine)");
                            }
                        }
                    }
                }

                if json {
                    let result = serde_json::json!({
                        "completed": true,
                        "events_executed": scenario.events.len(),
                        "expectations_passed": pass_count,
                        "expectations_failed": fail_count,
                    });
                    println!("{}", serde_json::to_string_pretty(&result)?);
                } else if pass_count + fail_count > 0 {
                    println!();
                    println!("Results: {} passed, {} failed", pass_count, fail_count);
                } else {
                    println!();
                    println!(
                        "Simulation complete ({} events executed)",
                        scenario.events.len()
                    );
                }

                if fail_count > 0 {
                    std::process::exit(1);
                }
            }
            SimulateCommands::List => {
                println!("Built-in scenarios:");
                println!();
                println!("  (none yet  use 'wa simulate run <file.yaml>' with custom scenarios)");
                println!();
                println!("Scenario YAML format:");
                println!("  name: my_scenario");
                println!("  description: \"What this scenario tests\"");
                println!("  duration: \"30s\"");
                println!("  panes:");
                println!("    - id: 0");
                println!("      title: \"Agent\"");
                println!("      initial_content: \"$ \"");
                println!("  events:");
                println!("    - at: \"2s\"");
                println!("      pane: 0");
                println!("      action: append");
                println!("      content: \"output text\"");
                println!("  expectations:");
                println!("    - pane: 0");
                println!("      text: \"output text\"");
            }
            SimulateCommands::Validate { scenario, json } => {
                use wa_core::simulation::Scenario;

                match Scenario::load(&scenario) {
                    Ok(s) => {
                        if json {
                            let info = serde_json::json!({
                                "valid": true,
                                "name": s.name,
                                "description": s.description,
                                "duration_ms": s.duration.as_millis() as u64,
                                "pane_count": s.panes.len(),
                                "event_count": s.events.len(),
                                "expectation_count": s.expectations.len(),
                            });
                            println!("{}", serde_json::to_string_pretty(&info)?);
                        } else {
                            println!("Valid scenario: {}", s.name);
                            println!("  Description: {}", s.description);
                            println!("  Duration:    {:.1}s", s.duration.as_secs_f64());
                            println!("  Panes:       {}", s.panes.len());
                            println!("  Events:      {}", s.events.len());
                            println!("  Expectations: {}", s.expectations.len());
                        }
                    }
                    Err(e) => {
                        if json {
                            let info = serde_json::json!({
                                "valid": false,
                                "error": e.to_string(),
                            });
                            println!("{}", serde_json::to_string_pretty(&info)?);
                        } else {
                            eprintln!("Invalid scenario: {e}");
                        }
                        std::process::exit(1);
                    }
                }
            }
        },

        Some(Commands::Demo {
            name,
            speed,
            narrate,
            json,
        }) => {
            let demos: &[(&str, &str)] = &[
                ("quickstart", "Basic wa setup and first detection"),
                ("usage_limit", "Agent hits usage limit, wa auto-rotates"),
                ("compaction", "Context compaction detection and handling"),
            ];

            match name {
                None => {
                    if json {
                        let list: Vec<_> = demos
                            .iter()
                            .map(|(name, desc)| {
                                serde_json::json!({"name": name, "description": desc})
                            })
                            .collect();
                        println!("{}", serde_json::to_string_pretty(&list)?);
                    } else {
                        println!("Available demos:");
                        println!();
                        for (name, desc) in demos {
                            println!("  {name:<20} {desc}");
                        }
                        println!();
                        println!("Run a demo: wa demo <name>");
                        println!(
                            "Note: Demo scenarios are not yet bundled. Use 'wa simulate run' with custom YAML."
                        );
                    }
                }
                Some(name) => {
                    if demos.iter().any(|(n, _)| *n == name.as_str()) {
                        if json {
                            let msg = serde_json::json!({
                                "demo": name,
                                "status": "not_yet_bundled",
                                "message": "Demo scenario files are not yet included. Use 'wa simulate run <file.yaml>' with a custom scenario."
                            });
                            println!("{}", serde_json::to_string_pretty(&msg)?);
                        } else {
                            println!("Demo: {name}");
                            if narrate {
                                println!("  (narration enabled)");
                            }
                            println!("  Speed: {speed}x");
                            println!();
                            println!("  Demo scenario files are not yet bundled.");
                            println!("  Use 'wa simulate run <file.yaml>' with a custom scenario.");
                        }
                    } else {
                        eprintln!("Unknown demo: {name}");
                        eprintln!("Available demos:");
                        for (n, _) in demos {
                            eprintln!("  {n}");
                        }
                        std::process::exit(1);
                    }
                }
            }
        }

        #[cfg(feature = "mcp")]
        Some(Commands::Mcp { command }) => {
            mcp::run_mcp(command, &config, &workspace_root)?;
        }

        None => {
            println!("wa - WezTerm Automata");
            println!();
            println!("Terminal hypervisor for AI agent swarms.");
            println!();
            println!("Use --help to see available commands.");
        }
    }

    Ok(())
}

fn handle_fatal_error(err: &anyhow::Error, robot_mode: bool) {
    use wa_core::output::{ErrorRenderer, OutputFormat, detect_format};

    if robot_mode {
        // In robot mode, output structured JSON error
        if let Some(core_err) = err.downcast_ref::<wa_core::Error>() {
            let renderer = ErrorRenderer::new(OutputFormat::Json);
            eprintln!("{}", renderer.render(core_err));
        } else {
            eprintln!(
                "{}",
                serde_json::json!({
                    "ok": false,
                    "error": err.to_string(),
                })
            );
        }
        return;
    }

    // In human mode, use rich formatting with error codes
    if let Some(core_err) = err.downcast_ref::<wa_core::Error>() {
        let format = detect_format();
        let renderer = ErrorRenderer::new(format);
        eprintln!("{}", renderer.render(core_err));
    } else {
        eprintln!("Error: {err}");
    }
}

/// Handle `wa why --recent`: query actual decisions from the audit trail and
/// render explanations with evidence, rationale, and next-step suggestions.
#[allow(clippy::too_many_arguments)]
async fn handle_why_recent(
    config: &wa_core::config::Config,
    workspace_root: &std::path::Path,
    output_format: wa_core::output::OutputFormat,
    decision_type: Option<&str>,
    pane: Option<u64>,
    decision_id: Option<i64>,
    limit: usize,
    verbose: u8,
) {
    use wa_core::storage::AuditQuery;

    // Resolve workspace layout
    let layout = match config.workspace_layout(Some(workspace_root)) {
        Ok(l) => l,
        Err(e) => {
            if output_format.is_json() {
                println!(
                    r#"{{"ok": false, "error": "Failed to get workspace layout: {}", "version": "{}"}}"#,
                    e,
                    wa_core::VERSION
                );
            } else {
                eprintln!("Error: Failed to get workspace layout: {e}");
            }
            std::process::exit(1);
        }
    };

    // Open storage
    let db_path = layout.db_path.to_string_lossy();
    let storage = match wa_core::storage::StorageHandle::new(&db_path).await {
        Ok(s) => s,
        Err(e) => {
            if output_format.is_json() {
                println!(
                    r#"{{"ok": false, "error": "Failed to open storage: {}", "version": "{}"}}"#,
                    e,
                    wa_core::VERSION
                );
            } else {
                eprintln!("Error: Failed to open storage: {e}");
                eprintln!("Is the database initialized? Run 'wa watch' first.");
            }
            std::process::exit(1);
        }
    };

    // Map user-friendly type names to policy_decision filter values
    let policy_filter = decision_type.map(|dt| match dt {
        "denied" | "deny" => "deny".to_string(),
        "require_approval" | "approval" => "require_approval".to_string(),
        "allow" | "allowed" => "allow".to_string(),
        other => other.to_string(),
    });

    // If fetching by specific ID, just get that one record
    if let Some(record_id) = decision_id {
        let query = AuditQuery {
            limit: Some(500),
            pane_id: pane,
            policy_decision: policy_filter.clone(),
            ..Default::default()
        };
        match storage.get_audit_actions(query).await {
            Ok(actions) => {
                if let Some(record) = actions.iter().find(|a| a.id == record_id) {
                    render_why_decision(record, output_format, verbose);
                } else {
                    if output_format.is_json() {
                        println!(
                            r#"{{"ok": false, "error": "Decision record {} not found", "version": "{}"}}"#,
                            record_id,
                            wa_core::VERSION
                        );
                    } else {
                        eprintln!("Error: Decision record {record_id} not found");
                        eprintln!("Use 'wa why --recent' to see recent decisions.");
                    }
                    std::process::exit(1);
                }
            }
            Err(e) => {
                if output_format.is_json() {
                    println!(
                        r#"{{"ok": false, "error": "Failed to query audit trail: {}", "version": "{}"}}"#,
                        e,
                        wa_core::VERSION
                    );
                } else {
                    eprintln!("Error: Failed to query audit trail: {e}");
                }
                std::process::exit(1);
            }
        }
        return;
    }

    // Default: only show non-allow decisions (denials + require_approval)
    let effective_filter = policy_filter.or_else(|| Some("deny".to_string()));

    let query = AuditQuery {
        limit: Some(limit),
        pane_id: pane,
        policy_decision: effective_filter.clone(),
        ..Default::default()
    };

    match storage.get_audit_actions(query).await {
        Ok(actions) => {
            if actions.is_empty() {
                let filter_desc = effective_filter.as_deref().unwrap_or("any");
                if output_format.is_json() {
                    println!(
                        r#"{{"ok": true, "decisions": [], "count": 0, "filter": "{}", "version": "{}"}}"#,
                        filter_desc,
                        wa_core::VERSION
                    );
                } else {
                    println!("No recent {filter_desc} decisions found.");
                    if pane.is_some() {
                        println!("Try without --pane to see all decisions.");
                    }
                    println!("Use 'wa why --recent allow' to include allowed decisions.");
                }
                return;
            }

            if output_format.is_json() {
                #[derive(serde::Serialize)]
                struct WhyRecentResponse {
                    ok: bool,
                    decisions: Vec<WhyDecisionJson>,
                    count: usize,
                    version: &'static str,
                }
                #[derive(serde::Serialize)]
                struct WhyDecisionJson {
                    id: i64,
                    timestamp_ms: i64,
                    action_kind: String,
                    policy_decision: String,
                    decision_reason: Option<String>,
                    rule_id: Option<String>,
                    pane_id: Option<u64>,
                    domain: Option<String>,
                    actor_kind: String,
                    result: String,
                    decision_context: Option<serde_json::Value>,
                    explanation_template: Option<String>,
                }
                let decisions: Vec<WhyDecisionJson> = actions
                    .iter()
                    .map(|a| {
                        let ctx_json = a
                            .decision_context
                            .as_ref()
                            .and_then(|s| serde_json::from_str::<serde_json::Value>(s).ok());
                        let tmpl_id = resolve_template_id(a);
                        WhyDecisionJson {
                            id: a.id,
                            timestamp_ms: a.ts,
                            action_kind: a.action_kind.clone(),
                            policy_decision: a.policy_decision.clone(),
                            decision_reason: a.decision_reason.clone(),
                            rule_id: a.rule_id.clone(),
                            pane_id: a.pane_id,
                            domain: a.domain.clone(),
                            actor_kind: a.actor_kind.clone(),
                            result: a.result.clone(),
                            decision_context: ctx_json,
                            explanation_template: tmpl_id,
                        }
                    })
                    .collect();
                let response = WhyRecentResponse {
                    ok: true,
                    count: decisions.len(),
                    decisions,
                    version: wa_core::VERSION,
                };
                println!("{}", serde_json::to_string_pretty(&response).unwrap());
            } else {
                println!("Recent decisions ({} found):\n", actions.len());
                for (i, action) in actions.iter().enumerate() {
                    if i > 0 {
                        println!("{}", "-".repeat(60));
                    }
                    render_why_decision(action, output_format, verbose);
                }
            }
        }
        Err(e) => {
            if output_format.is_json() {
                println!(
                    r#"{{"ok": false, "error": "Failed to query audit trail: {}", "version": "{}"}}"#,
                    e,
                    wa_core::VERSION
                );
            } else {
                eprintln!("Error: Failed to query audit trail: {e}");
            }
            std::process::exit(1);
        }
    }
}

/// Render a single audit decision as an explanation with evidence and suggestions.
fn render_why_decision(
    record: &wa_core::storage::AuditActionRecord,
    output_format: wa_core::output::OutputFormat,
    verbose: u8,
) {
    use wa_core::explanations::get_explanation;
    use wa_core::policy::DecisionContext;

    if output_format.is_json() {
        let ctx_json = record
            .decision_context
            .as_ref()
            .and_then(|s| serde_json::from_str::<serde_json::Value>(s).ok());
        let tmpl_id = resolve_template_id(record);
        let tmpl = tmpl_id.as_deref().and_then(get_explanation);

        #[derive(serde::Serialize)]
        struct WhyDetailJson<'a> {
            ok: bool,
            id: i64,
            timestamp_ms: i64,
            action_kind: &'a str,
            policy_decision: &'a str,
            decision_reason: Option<&'a str>,
            rule_id: Option<&'a str>,
            pane_id: Option<u64>,
            domain: Option<&'a str>,
            actor_kind: &'a str,
            result: &'a str,
            decision_context: Option<serde_json::Value>,
            explanation: Option<ExplanationSummary<'a>>,
            version: &'static str,
        }
        #[derive(serde::Serialize)]
        struct ExplanationSummary<'a> {
            template_id: &'a str,
            scenario: &'a str,
            brief: &'a str,
            suggestions: &'a [&'a str],
            see_also: &'a [&'a str],
        }
        let explanation = tmpl.map(|t| ExplanationSummary {
            template_id: t.id,
            scenario: t.scenario,
            brief: t.brief,
            suggestions: t.suggestions,
            see_also: t.see_also,
        });
        let detail = WhyDetailJson {
            ok: true,
            id: record.id,
            timestamp_ms: record.ts,
            action_kind: &record.action_kind,
            policy_decision: &record.policy_decision,
            decision_reason: record.decision_reason.as_deref(),
            rule_id: record.rule_id.as_deref(),
            pane_id: record.pane_id,
            domain: record.domain.as_deref(),
            actor_kind: &record.actor_kind,
            result: &record.result,
            decision_context: ctx_json,
            explanation,
            version: wa_core::VERSION,
        };
        println!("{}", serde_json::to_string_pretty(&detail).unwrap());
        return;
    }

    // Plain text output
    let decision_label = match record.policy_decision.as_str() {
        "deny" => "DENY",
        "require_approval" => "REQUIRE APPROVAL",
        "allow" => "ALLOW",
        other => other,
    };

    println!("Decision: {decision_label}");
    println!("Type: {}", record.action_kind);
    if let Some(pane_id) = record.pane_id {
        println!("Target: Pane {pane_id}");
    }
    if let Some(domain) = &record.domain {
        println!("Domain: {domain}");
    }
    println!("Actor: {}", record.actor_kind);
    let ts_str = format_epoch_ms(record.ts);
    println!("Timestamp: {ts_str}");
    println!("Result: {}", record.result);
    println!("Record ID: {}", record.id);
    println!();

    // Reason
    if let Some(reason) = &record.decision_reason {
        println!("Reason: {reason}");
    }
    if let Some(rule_id) = &record.rule_id {
        println!("Rule: {rule_id}");
    }

    // Parse decision context for evidence
    let ctx: Option<DecisionContext> = record
        .decision_context
        .as_ref()
        .and_then(|s| serde_json::from_str(s).ok());

    if let Some(ref ctx) = ctx {
        if !ctx.evidence.is_empty() {
            println!();
            println!("Evidence:");
            for ev in &ctx.evidence {
                println!("  - {}: {}", ev.key, ev.value);
            }
        }

        if verbose > 0 && !ctx.rules_evaluated.is_empty() {
            println!();
            println!("Rules evaluated:");
            for rule_eval in &ctx.rules_evaluated {
                let status = if rule_eval.matched { "MATCH" } else { "skip" };
                let decision_str = rule_eval
                    .decision
                    .as_deref()
                    .map(|d| format!(" -> {d}"))
                    .unwrap_or_default();
                println!("  [{status}] {}{decision_str}", rule_eval.rule_id);
            }
        }

        if let Some(ref rate_limit) = ctx.rate_limit {
            println!();
            println!(
                "Rate limit: {}/{} per minute (scope: {}), retry after {}s",
                rate_limit.current, rate_limit.limit, rate_limit.scope, rate_limit.retry_after_secs
            );
        }

        if let Some(ref determining) = ctx.determining_rule {
            println!("Determining rule: {determining}");
        }
    }

    // Explanation template lookup
    let tmpl_id = resolve_template_id(record);
    if let Some(ref id) = tmpl_id {
        if let Some(template) = get_explanation(id) {
            println!();
            println!("Rationale:");
            // Use brief for compact output
            println!("  {}", template.brief);
            if verbose > 0 {
                // Show detailed in verbose mode
                for line in template.detailed.lines() {
                    println!("  {line}");
                }
            }
            if !template.suggestions.is_empty() {
                println!();
                println!("To proceed:");
                for (j, suggestion) in template.suggestions.iter().enumerate() {
                    println!("  {}. {suggestion}", j + 1);
                }
            }
            if !template.see_also.is_empty() {
                println!();
                println!("See also: {}", template.see_also.join(", "));
            }
        }
    }
    println!();
}

/// Resolve an explanation template ID from an audit record's rule_id.
///
/// Maps rule IDs like "safety.alt_screen_block" to template IDs like "deny.alt_screen".
fn resolve_template_id(record: &wa_core::storage::AuditActionRecord) -> Option<String> {
    use wa_core::explanations::get_explanation;

    let rule_id = record.rule_id.as_deref()?;

    // Direct match: rule_id might already be a template ID
    if get_explanation(rule_id).is_some() {
        return Some(rule_id.to_string());
    }

    // Map decision type + rule_id patterns to template IDs
    let prefix = match record.policy_decision.as_str() {
        "deny" => "deny",
        "require_approval" => "workflow",
        _ => return None,
    };

    // Try prefix + last segment of rule_id
    // e.g., "safety.alt_screen_block" -> try "deny.alt_screen_block", "deny.alt_screen"
    let segments: Vec<&str> = rule_id.split('.').collect();
    if let Some(last) = segments.last() {
        let candidate = format!("{prefix}.{last}");
        if get_explanation(&candidate).is_some() {
            return Some(candidate);
        }
        // Strip common suffixes
        for suffix in ["_block", "_blocked", "_deny", "_check"] {
            if let Some(stripped) = last.strip_suffix(suffix) {
                let candidate = format!("{prefix}.{stripped}");
                if get_explanation(&candidate).is_some() {
                    return Some(candidate);
                }
            }
        }
    }

    // Try decision_reason text matching as fallback
    if let Some(reason) = &record.decision_reason {
        let lower = reason.to_lowercase();
        if lower.contains("alt") && lower.contains("screen") {
            return Some("deny.alt_screen".to_string());
        }
        if lower.contains("command") && lower.contains("running") {
            return Some("deny.command_running".to_string());
        }
        if lower.contains("rate") && lower.contains("limit") {
            return Some("deny.rate_limited".to_string());
        }
        if lower.contains("gap") {
            return Some("deny.recent_gap".to_string());
        }
        if lower.contains("unknown") && lower.contains("pane") {
            return Some("deny.unknown_pane".to_string());
        }
        if lower.contains("permission") {
            return Some("deny.permission".to_string());
        }
        if lower.contains("approval") {
            return Some("workflow.approval_needed".to_string());
        }
    }

    None
}

fn render_secret_scan_report(
    report: &wa_core::secrets::SecretScanReport,
    format: wa_core::output::OutputFormat,
    pretty: bool,
) -> anyhow::Result<()> {
    match format {
        wa_core::output::OutputFormat::Json => {
            let output = if pretty {
                serde_json::to_string_pretty(report)?
            } else {
                serde_json::to_string(report)?
            };
            println!("{output}");
        }
        wa_core::output::OutputFormat::Plain | wa_core::output::OutputFormat::Auto => {
            render_secret_scan_report_plain(report);
        }
    }
    Ok(())
}

fn render_secret_scan_report_plain(report: &wa_core::secrets::SecretScanReport) {
    let pane = report
        .scope
        .pane_id
        .map(|value| value.to_string())
        .unwrap_or_else(|| "any".to_string());
    let since = report
        .scope
        .since
        .map(|value| format!("{value} ({})", format_epoch_ms(value)))
        .unwrap_or_else(|| "any".to_string());
    let until = report
        .scope
        .until
        .map(|value| format!("{value} ({})", format_epoch_ms(value)))
        .unwrap_or_else(|| "any".to_string());

    println!("Secret scan report");
    println!("Report version: {}", report.report_version);
    println!("Scope: pane_id={pane}, since={since}, until={until}");
    println!(
        "Started: {}  Completed: {}",
        format_epoch_ms(report.started_at),
        format_epoch_ms(report.completed_at)
    );
    if let Some(resume) = report.resume_after_id {
        println!("Resume after segment ID: {resume}");
    }
    if let Some(last) = report.last_segment_id {
        println!("Last segment ID: {last}");
    }
    println!(
        "Segments scanned: {}  Bytes scanned: {}",
        report.scanned_segments, report.scanned_bytes
    );
    println!("Matches total: {}", report.matches_total);

    if report.matches_by_pattern.is_empty() {
        println!("Matches by pattern: none");
    } else {
        println!("Matches by pattern:");
        for (pattern, count) in &report.matches_by_pattern {
            println!("  {pattern}: {count}");
        }
    }

    if report.samples.is_empty() {
        println!("Samples: none");
        return;
    }

    println!("Samples (redacted):");
    for sample in &report.samples {
        println!(
            "  pattern={} pane={} segment_id={} captured_at={} hash={} len={}",
            sample.pattern,
            sample.pane_id,
            sample.segment_id,
            format_epoch_ms(sample.captured_at),
            sample.secret_hash,
            sample.match_len
        );
    }
}

/// Format epoch milliseconds as ISO 8601 string (basic, no chrono dependency).
fn format_epoch_ms(ms: i64) -> String {
    let secs = ms / 1000;
    let subsec_ms = (ms % 1000).unsigned_abs();
    // Use the same approach as chrono_stub_now but from epoch
    let days = secs / 86400;
    let day_secs = secs % 86400;
    let hours = day_secs / 3600;
    let mins = (day_secs % 3600) / 60;
    let s = day_secs % 60;

    // Approximate date from days since epoch (1970-01-01)
    // This is a simplified calculation sufficient for display
    let mut y = 1970i64;
    let mut remaining = days;
    loop {
        let days_in_year = if (y % 4 == 0 && y % 100 != 0) || y % 400 == 0 {
            366
        } else {
            365
        };
        if remaining < days_in_year {
            break;
        }
        remaining -= days_in_year;
        y += 1;
    }
    let leap = (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
    let month_days: [i64; 12] = if leap {
        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    } else {
        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    };
    let mut m = 0usize;
    for (i, &md) in month_days.iter().enumerate() {
        if remaining < md {
            m = i;
            break;
        }
        remaining -= md;
    }
    let d = remaining + 1;

    format!(
        "{y:04}-{:02}-{d:02}T{hours:02}:{mins:02}:{s:02}.{subsec_ms:03}Z",
        m + 1
    )
}

fn parse_history_time_ms(raw: &str) -> Result<i64, String> {
    let raw = raw.trim();
    if raw.is_empty() {
        return Err("Time filter cannot be empty".to_string());
    }

    if let Some(relative_ms) = parse_relative_duration_ms(raw) {
        let now_ms = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as i64;
        return Ok(now_ms.saturating_sub(relative_ms));
    }

    if let Some(parsed) = wa_core::cass::parse_cass_timestamp_ms(raw) {
        return Ok(parsed);
    }

    if raw.contains('T') {
        let replaced = raw.replace('T', " ");
        if let Some(parsed) = wa_core::cass::parse_cass_timestamp_ms(&replaced) {
            return Ok(parsed);
        }
    }

    Err(format!(
        "Invalid time '{raw}'. Expected epoch seconds/ms, RFC3339, or \"1 hour ago\""
    ))
}

fn parse_relative_duration_ms(raw: &str) -> Option<i64> {
    let lower = raw.trim().to_lowercase();
    let parts: Vec<&str> = lower.split_whitespace().collect();
    if parts.len() != 3 || parts[2] != "ago" {
        return None;
    }

    let value: i64 = parts[0].parse().ok()?;
    let unit_ms: i64 = match parts[1] {
        "s" | "sec" | "secs" | "second" | "seconds" => 1_000,
        "m" | "min" | "mins" | "minute" | "minutes" => 60_000,
        "h" | "hr" | "hrs" | "hour" | "hours" => 3_600_000,
        "d" | "day" | "days" => 86_400_000,
        "w" | "week" | "weeks" => 604_800_000,
        _ => return None,
    };

    Some(value.saturating_mul(unit_ms))
}

fn resolve_config_path_for_edit(cli_config: Option<&str>) -> PathBuf {
    if let Some(path) = cli_config {
        return PathBuf::from(path);
    }

    let cwd_config = PathBuf::from("wa.toml");
    if cwd_config.exists() {
        return cwd_config;
    }

    dirs::config_dir()
        .unwrap_or_else(|| PathBuf::from("~/.config"))
        .join("wa")
        .join("wa.toml")
}

fn update_patterns_in_doc(
    doc: &mut toml_edit::DocumentMut,
    patterns: &wa_core::config::PatternsConfig,
) -> anyhow::Result<()> {
    if !doc["patterns"].is_table() {
        doc["patterns"] = toml_edit::table();
    }
    let patterns_table = doc["patterns"]
        .as_table_mut()
        .ok_or_else(|| anyhow::anyhow!("patterns must be a table"))?;

    let mut packs = toml_edit::Array::default();
    for pack in &patterns.packs {
        packs.push(pack.as_str());
    }
    patterns_table["packs"] = toml_edit::Item::Value(packs.into());
    patterns_table["quick_reject_enabled"] = toml_edit::value(patterns.quick_reject_enabled);

    if patterns.pack_overrides.is_empty() {
        patterns_table.remove("pack_overrides");
    } else {
        let overrides_toml = toml::to_string(&patterns.pack_overrides)?;
        let overrides_doc = overrides_toml.parse::<toml_edit::DocumentMut>()?;
        patterns_table["pack_overrides"] = toml_edit::Item::Table(overrides_doc.as_table().clone());
    }

    Ok(())
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct ConfigProfileApplyMeta {
    profile: String,
    applied_at: u64,
    backup_path: String,
    config_path: String,
}

fn profile_backup_path(config_path: &Path) -> PathBuf {
    config_path.with_extension("toml.profile.bak")
}

fn profile_meta_path(config_path: &Path) -> PathBuf {
    config_path.with_extension("toml.profile.meta.json")
}

fn merge_toml_documents(base: &str, overlay: &str) -> anyhow::Result<String> {
    let mut base_doc = base
        .parse::<toml_edit::DocumentMut>()
        .map_err(|e| anyhow::anyhow!("Failed to parse base config: {e}"))?;
    let overlay_doc = overlay
        .parse::<toml_edit::DocumentMut>()
        .map_err(|e| anyhow::anyhow!("Failed to parse profile overlay: {e}"))?;

    let overlay_table = overlay_doc.as_table();
    let base_table = base_doc.as_table_mut();
    merge_toml_tables(base_table, overlay_table);

    Ok(base_doc.to_string())
}

fn merge_toml_tables(target: &mut toml_edit::Table, overlay: &toml_edit::Table) {
    for (key, overlay_item) in overlay {
        if target.contains_key(key) {
            if let Some(target_item) = target.get_mut(key) {
                merge_toml_item(target_item, overlay_item);
            }
        } else {
            target.insert(key, overlay_item.clone());
        }
    }
}

fn merge_toml_item(target: &mut toml_edit::Item, overlay: &toml_edit::Item) {
    if let toml_edit::Item::Table(target_table) = target {
        if let toml_edit::Item::Table(overlay_table) = overlay {
            merge_toml_tables(target_table, overlay_table);
            return;
        }
    }
    *target = overlay.clone();
}

fn update_profile_manifest_on_create(
    manifest: &mut wa_core::config_profiles::ConfigProfileManifest,
    name: &str,
    rel_path: &str,
    description: Option<String>,
    timestamp_ms: u64,
) {
    if let Some(entry) = manifest
        .profiles
        .iter_mut()
        .find(|entry| entry.name == name)
    {
        entry.path = rel_path.to_string();
        if description.is_some() {
            entry.description = description;
        }
        entry.updated_at = Some(timestamp_ms);
        entry.created_at = entry.created_at.or(Some(timestamp_ms));
        return;
    }

    manifest
        .profiles
        .push(wa_core::config_profiles::ConfigProfileManifestEntry {
            name: name.to_string(),
            path: rel_path.to_string(),
            description,
            created_at: Some(timestamp_ms),
            updated_at: Some(timestamp_ms),
            last_applied_at: None,
        });
    manifest.profiles.sort_by(|a, b| a.name.cmp(&b.name));
}

fn handle_config_profile_command(
    command: ConfigProfileCommands,
    cli_config: Option<&str>,
) -> anyhow::Result<()> {
    match command {
        ConfigProfileCommands::List { json, path } => {
            let config_path = if let Some(p) = path {
                PathBuf::from(p)
            } else {
                resolve_config_path_for_edit(cli_config)
            };
            let profiles_dir = wa_core::config_profiles::resolve_profiles_dir(Some(&config_path));
            let profiles = wa_core::config_profiles::list_profiles(&profiles_dir)?;

            if json {
                println!("{}", serde_json::to_string_pretty(&profiles)?);
                return Ok(());
            }

            println!("Config profiles:");
            for profile in profiles {
                let description = profile.description.unwrap_or_default();
                let suffix = if profile.implicit {
                    "(implicit)".to_string()
                } else if let Some(path) = profile.path {
                    format!("({path})")
                } else {
                    String::new()
                };
                if description.is_empty() {
                    if suffix.is_empty() {
                        println!("  {}", profile.name);
                    } else {
                        println!("  {} {suffix}", profile.name);
                    }
                } else if suffix.is_empty() {
                    println!("  {} - {description}", profile.name);
                } else {
                    println!("  {} - {description} {suffix}", profile.name);
                }
            }
        }

        ConfigProfileCommands::Diff { name, path } => {
            let config_path = if let Some(p) = path {
                PathBuf::from(p)
            } else {
                resolve_config_path_for_edit(cli_config)
            };

            let (base_toml, merged_toml) = load_and_merge_config_profile(&config_path, &name)?;

            let diff_lines = compute_config_diff(&base_toml, &merged_toml);
            if diff_lines.is_empty() {
                println!("No changes detected  profile produces identical config.");
                return Ok(());
            }

            println!(
                "Profile diff ({} change{}):",
                diff_lines.len(),
                if diff_lines.len() == 1 { "" } else { "s" }
            );
            for line in diff_lines {
                println!("  {line}");
            }
        }

        ConfigProfileCommands::Apply {
            name,
            dry_run,
            path,
        } => {
            let config_path = if let Some(p) = path {
                PathBuf::from(p)
            } else {
                resolve_config_path_for_edit(cli_config)
            };

            let (base_toml, merged_toml) = load_and_merge_config_profile(&config_path, &name)?;

            let diff_lines = compute_config_diff(&base_toml, &merged_toml);
            if diff_lines.is_empty() {
                println!("No changes detected  profile produces identical config.");
                return Ok(());
            }

            println!(
                "Profile apply preview ({} change{}):",
                diff_lines.len(),
                if diff_lines.len() == 1 { "" } else { "s" }
            );
            for line in &diff_lines {
                println!("  {line}");
            }

            if dry_run {
                println!("\n(dry run  no changes applied)");
                println!("Config file: {}", config_path.display());
                return Ok(());
            }

            if let Some(parent) = config_path.parent() {
                std::fs::create_dir_all(parent)?;
            }

            let backup_path = profile_backup_path(&config_path);
            std::fs::write(&backup_path, &base_toml)?;

            std::fs::write(&config_path, &merged_toml)?;

            let applied_at = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_millis() as u64;

            let meta = ConfigProfileApplyMeta {
                profile: name.clone(),
                applied_at,
                backup_path: backup_path.display().to_string(),
                config_path: config_path.display().to_string(),
            };
            let meta_path = profile_meta_path(&config_path);
            std::fs::write(&meta_path, serde_json::to_string_pretty(&meta)?)?;

            let profiles_dir = wa_core::config_profiles::resolve_profiles_dir(Some(&config_path));
            let mut manifest = match wa_core::config_profiles::load_manifest(&profiles_dir) {
                Ok(Some(manifest)) => manifest,
                Ok(None) => wa_core::config_profiles::scan_profiles(&profiles_dir)?,
                Err(err) => {
                    eprintln!(
                        "Warning: failed to read config profile manifest: {err}. Scanning directory."
                    );
                    wa_core::config_profiles::scan_profiles(&profiles_dir)?
                }
            };

            let (canonical, _path, rel_path) = wa_core::config_profiles::resolve_profile_path(
                &profiles_dir,
                Some(&manifest),
                &name,
            )?;
            wa_core::config_profiles::touch_last_applied(
                &mut manifest,
                &canonical,
                &rel_path,
                applied_at,
            );
            wa_core::config_profiles::write_manifest(&profiles_dir, &manifest)?;

            println!("Applied profile '{canonical}' to {}", config_path.display());
            println!("Backup saved to: {}", backup_path.display());
        }

        ConfigProfileCommands::Create {
            name,
            from,
            description,
            force,
            path,
        } => {
            let config_path = if let Some(p) = path {
                PathBuf::from(p)
            } else {
                resolve_config_path_for_edit(cli_config)
            };

            let profiles_dir = wa_core::config_profiles::resolve_profiles_dir(Some(&config_path));
            if !profiles_dir.exists() {
                std::fs::create_dir_all(&profiles_dir)?;
            }

            let canonical = wa_core::config_profiles::canonicalize_profile_name(&name)?;
            if canonical == "default" {
                anyhow::bail!("Profile name 'default' is reserved");
            }

            let manifest = match wa_core::config_profiles::load_manifest(&profiles_dir) {
                Ok(Some(manifest)) => Some(manifest),
                Ok(None) => Some(wa_core::config_profiles::scan_profiles(&profiles_dir)?),
                Err(err) => {
                    eprintln!(
                        "Warning: failed to read config profile manifest: {err}. Scanning directory."
                    );
                    Some(wa_core::config_profiles::scan_profiles(&profiles_dir)?)
                }
            };

            let (_canonical, profile_path, rel_path) =
                wa_core::config_profiles::resolve_profile_path(
                    &profiles_dir,
                    manifest.as_ref(),
                    &canonical,
                )?;

            if profile_path.exists() && !force {
                anyhow::bail!(
                    "Profile already exists at {}. Use --force to overwrite.",
                    profile_path.display()
                );
            }

            let source_toml = match from.trim() {
                "current" => {
                    if config_path.exists() {
                        std::fs::read_to_string(&config_path)?
                    } else {
                        generate_default_config_toml()
                    }
                }
                "empty" => String::new(),
                other => {
                    let source_name = wa_core::config_profiles::canonicalize_profile_name(other)?;
                    let (_name, source_path, _) = wa_core::config_profiles::resolve_profile_path(
                        &profiles_dir,
                        manifest.as_ref(),
                        &source_name,
                    )?;
                    if !source_path.exists() {
                        anyhow::bail!(
                            "Source profile '{source_name}' not found at {}",
                            source_path.display()
                        );
                    }
                    std::fs::read_to_string(&source_path)?
                }
            };

            if !source_toml.trim().is_empty() {
                let mut candidate = wa_core::config::Config::from_toml(&source_toml)?;
                candidate.normalize_paths();
                candidate.validate()?;
            }

            let tmp_path = profile_path.with_extension("toml.tmp");
            std::fs::write(&tmp_path, &source_toml)?;
            std::fs::rename(&tmp_path, &profile_path)?;

            let applied_at = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_millis() as u64;

            let mut updated_manifest = manifest.unwrap_or_default();
            update_profile_manifest_on_create(
                &mut updated_manifest,
                &canonical,
                &rel_path,
                description,
                applied_at,
            );
            wa_core::config_profiles::write_manifest(&profiles_dir, &updated_manifest)?;

            println!(
                "Created profile '{canonical}' at {}",
                profile_path.display()
            );
        }

        ConfigProfileCommands::Rollback { yes, path } => {
            let config_path = if let Some(p) = path {
                PathBuf::from(p)
            } else {
                resolve_config_path_for_edit(cli_config)
            };
            let backup_path = profile_backup_path(&config_path);
            if !backup_path.exists() {
                anyhow::bail!("No profile backup found at {}", backup_path.display());
            }

            if !yes {
                println!(
                    "This will overwrite {} with the backup from {}.",
                    config_path.display(),
                    backup_path.display()
                );
                if let Ok(meta) = std::fs::read_to_string(profile_meta_path(&config_path)) {
                    if let Ok(parsed) = serde_json::from_str::<ConfigProfileApplyMeta>(&meta) {
                        println!(
                            "Last applied profile: {} (applied_at {} ms)",
                            parsed.profile, parsed.applied_at
                        );
                    }
                }
                if !prompt_confirm("Continue rollback? [y/N]: ")? {
                    println!("Aborted.");
                    return Ok(());
                }
            }

            let backup_contents = std::fs::read_to_string(&backup_path)?;
            if let Some(parent) = config_path.parent() {
                std::fs::create_dir_all(parent)?;
            }
            std::fs::write(&config_path, backup_contents)?;
            println!("Rollback complete: {}", config_path.display());
        }
    }

    Ok(())
}

fn load_and_merge_config_profile(
    config_path: &Path,
    profile_name: &str,
) -> anyhow::Result<(String, String)> {
    use wa_core::config::Config;

    let base_toml = if config_path.exists() {
        std::fs::read_to_string(config_path)?
    } else {
        generate_default_config_toml()
    };

    let profiles_dir = wa_core::config_profiles::resolve_profiles_dir(Some(config_path));
    let manifest = match wa_core::config_profiles::load_manifest(&profiles_dir) {
        Ok(Some(manifest)) => Some(manifest),
        Ok(None) => Some(wa_core::config_profiles::scan_profiles(&profiles_dir)?),
        Err(err) => {
            eprintln!(
                "Warning: failed to read config profile manifest: {err}. Scanning directory."
            );
            Some(wa_core::config_profiles::scan_profiles(&profiles_dir)?)
        }
    };

    let canonical = wa_core::config_profiles::canonicalize_profile_name(profile_name)?;
    if canonical == "default" {
        return Ok((base_toml.clone(), base_toml));
    }

    let (canonical, profile_path, _rel_path) = wa_core::config_profiles::resolve_profile_path(
        &profiles_dir,
        manifest.as_ref(),
        &canonical,
    )?;
    if !profile_path.exists() {
        anyhow::bail!(
            "Profile '{canonical}' not found at {}",
            profile_path.display()
        );
    }

    let overlay_toml = std::fs::read_to_string(&profile_path)?;
    let merged_toml = merge_toml_documents(&base_toml, &overlay_toml)?;

    let mut merged_config = Config::from_toml(&merged_toml)?;
    merged_config.normalize_paths();
    merged_config.validate()?;

    Ok((base_toml, merged_toml))
}

fn handle_rules_profile_command(
    command: RulesProfileCommands,
    cli_config: Option<&str>,
    resolved_config_path: Option<&Path>,
    layout: &wa_core::config::WorkspaceLayout,
) -> anyhow::Result<()> {
    use wa_core::output::{OutputFormat, detect_format};
    use wa_core::patterns::PatternEngine;

    match command {
        RulesProfileCommands::List { format } => {
            let rulesets_dir = wa_core::rulesets::resolve_rulesets_dir(resolved_config_path);
            let fmt = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            let profiles = wa_core::rulesets::list_profiles(&rulesets_dir)?;

            if fmt == OutputFormat::Json {
                println!("{}", serde_json::to_string_pretty(&profiles)?);
                return Ok(());
            }

            println!("Ruleset profiles:");
            for profile in profiles {
                let description = profile.description.unwrap_or_default();
                let suffix = if profile.implicit {
                    "(implicit)".to_string()
                } else if let Some(path) = profile.path {
                    format!("({})", path)
                } else {
                    String::new()
                };
                if description.is_empty() {
                    if suffix.is_empty() {
                        println!("  {}", profile.name);
                    } else {
                        println!("  {} {}", profile.name, suffix);
                    }
                } else if suffix.is_empty() {
                    println!("  {} - {}", profile.name, description);
                } else {
                    println!("  {} - {} {}", profile.name, description, suffix);
                }
            }
        }

        RulesProfileCommands::Apply { name } => {
            use wa_core::config::{Config, ConfigOverrides};

            let config_path = resolve_config_path_for_edit(cli_config);
            let rulesets_dir = wa_core::rulesets::resolve_rulesets_dir(Some(&config_path));
            let mut manifest = match wa_core::rulesets::load_manifest(&rulesets_dir) {
                Ok(Some(manifest)) => manifest,
                Ok(None) => wa_core::rulesets::scan_rulesets(&rulesets_dir)?,
                Err(err) => {
                    eprintln!(
                        "Warning: failed to read ruleset manifest: {err}. Scanning directory."
                    );
                    wa_core::rulesets::scan_rulesets(&rulesets_dir)?
                }
            };

            let base_config = Config::load_with_overrides(
                Some(&config_path),
                false,
                &ConfigOverrides::default(),
            )?;
            let resolved_patterns = wa_core::rulesets::resolve_patterns_for_profile(
                &base_config.patterns,
                &rulesets_dir,
                Some(&manifest),
                &name,
            )?;

            let patterns_root = config_path.parent();
            PatternEngine::from_config_with_root(&resolved_patterns, patterns_root)?;

            let content = if config_path.exists() {
                std::fs::read_to_string(&config_path)?
            } else {
                generate_default_config_toml()
            };
            let mut doc = content
                .parse::<toml_edit::DocumentMut>()
                .map_err(|e| anyhow::anyhow!("Failed to parse config: {e}"))?;

            update_patterns_in_doc(&mut doc, &resolved_patterns)?;

            if let Some(parent) = config_path.parent() {
                std::fs::create_dir_all(parent)?;
            }
            std::fs::write(&config_path, doc.to_string())?;

            let canonical = name.trim().to_lowercase();
            if canonical != "default" {
                let profile_path = manifest
                    .rulesets
                    .iter()
                    .find(|entry| entry.name == canonical)
                    .map(|entry| entry.path.clone())
                    .unwrap_or_else(|| format!("{canonical}.toml"));
                wa_core::rulesets::touch_last_applied(
                    &mut manifest,
                    &canonical,
                    &profile_path,
                    now_ms(),
                );
                wa_core::rulesets::write_manifest(&rulesets_dir, &manifest)?;
            }

            println!(
                "Applied ruleset profile '{}' to {}",
                canonical,
                config_path.display()
            );

            if let Some(meta) = wa_core::lock::check_running(&layout.lock_path) {
                #[cfg(unix)]
                {
                    let status = std::process::Command::new("kill")
                        .args(["-s", "HUP", &meta.pid.to_string()])
                        .status();
                    match status {
                        Ok(s) if s.success() => {
                            println!("Sent SIGHUP to watcher (pid {}).", meta.pid);
                        }
                        Ok(s) => {
                            eprintln!(
                                "Failed to signal watcher (pid {}) (exit code: {}).",
                                meta.pid,
                                s.code().unwrap_or(-1)
                            );
                        }
                        Err(err) => {
                            eprintln!("Failed to run kill command: {err}");
                        }
                    }
                }
                #[cfg(not(unix))]
                {
                    println!(
                        "Watcher reload not supported on this platform (pid {}).",
                        meta.pid
                    );
                }
            } else {
                println!("No watcher running in workspace: {}", layout.root.display());
            }
        }
    }

    Ok(())
}

/// Handle `wa ext` subcommands
fn handle_ext_command(
    command: ExtCommands,
    config: &wa_core::config::Config,
    resolved_config_path: Option<&Path>,
) {
    use wa_core::extensions;
    use wa_core::output::{OutputFormat, detect_format};

    let config_root = resolved_config_path.and_then(|p| p.parent());

    match command {
        ExtCommands::List { r#type, format } => {
            let fmt = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            let exts = match extensions::list_extensions(&config.patterns, config_root) {
                Ok(exts) => exts,
                Err(e) => {
                    eprintln!("Failed to list extensions: {e}");
                    std::process::exit(1);
                }
            };

            let type_filter = r#type.to_lowercase();
            let filtered: Vec<_> = exts
                .iter()
                .filter(|e| match type_filter.as_str() {
                    "builtin" => e.source == extensions::ExtensionSource::Builtin,
                    "file" => e.source == extensions::ExtensionSource::File,
                    _ => true,
                })
                .collect();

            if matches!(fmt, OutputFormat::Json) {
                println!(
                    "{}",
                    serde_json::to_string_pretty(&filtered).unwrap_or_else(|_| "[]".to_string())
                );
            } else {
                if filtered.is_empty() {
                    println!("No extensions found.");
                    return;
                }

                println!(
                    "{:<10} {:<25} {:<10} {:<10} {:<8} {}",
                    "TYPE", "NAME", "VERSION", "RULES", "ACTIVE", "PATH"
                );
                for ext in &filtered {
                    let source = match ext.source {
                        extensions::ExtensionSource::Builtin => "built-in",
                        extensions::ExtensionSource::File => "file",
                    };
                    let active = if ext.active { "yes" } else { "no" };
                    let path = ext.path.as_deref().unwrap_or("-");
                    println!(
                        "{:<10} {:<25} {:<10} {:<10} {:<8} {}",
                        source, ext.name, ext.version, ext.rule_count, active, path
                    );
                }
            }
        }

        ExtCommands::Install { path } => {
            match extensions::install_extension(&path, resolved_config_path) {
                Ok(pack_id) => {
                    println!("Installed extension: {pack_id}");
                    println!();
                    println!("To activate, add to wa.toml [patterns].packs:");
                    println!("  packs = [..., \"{pack_id}\"]");
                }
                Err(e) => {
                    eprintln!("Failed to install extension: {e}");
                    std::process::exit(1);
                }
            }
        }

        ExtCommands::Remove { name } => {
            match extensions::remove_extension(&name, &config.patterns, resolved_config_path) {
                Ok(Some(pack_id)) => {
                    println!("Removed extension: {pack_id}");
                    println!();
                    println!("Remember to remove from wa.toml [patterns].packs if present.");
                }
                Ok(None) => {
                    eprintln!("Extension '{name}' not found.");
                    eprintln!("Use 'wa ext list' to see installed extensions.");
                    std::process::exit(1);
                }
                Err(e) => {
                    eprintln!("Failed to remove extension: {e}");
                    std::process::exit(1);
                }
            }
        }

        ExtCommands::Validate { path } => {
            let result = extensions::validate_extension(&path);

            if result.valid {
                println!("Extension is valid.");
                if let Some(name) = &result.pack_name {
                    println!("  Name: {name}");
                }
                if let Some(version) = &result.version {
                    println!("  Version: {version}");
                }
                println!("  Rules: {}", result.rule_count);
            } else {
                eprintln!("Extension validation failed:");
                for error in &result.errors {
                    eprintln!("  error: {error}");
                }
            }

            for warning in &result.warnings {
                eprintln!("  warning: {warning}");
            }

            if !result.valid {
                std::process::exit(1);
            }
        }

        ExtCommands::Info { name, format } => {
            let fmt = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            let detail = match extensions::extension_info(&name, &config.patterns, config_root) {
                Ok(d) => d,
                Err(e) => {
                    eprintln!("Extension '{name}' not found: {e}");
                    std::process::exit(1);
                }
            };

            if matches!(fmt, OutputFormat::Json) {
                println!(
                    "{}",
                    serde_json::to_string_pretty(&detail).unwrap_or_else(|_| "{}".to_string())
                );
            } else {
                let source = match detail.source {
                    extensions::ExtensionSource::Builtin => "built-in",
                    extensions::ExtensionSource::File => "file",
                };
                println!("Name: {}", detail.name);
                println!("Version: {}", detail.version);
                println!("Type: {source}");
                if let Some(path) = &detail.path {
                    println!("Source: {path}");
                }
                println!("Rules: {}", detail.rules.len());
                for rule in &detail.rules {
                    println!("  - {} ({}, {})", rule.id, rule.severity, rule.description);
                }
            }
        }
    }
}

/// Handle `wa rules` subcommands
fn handle_rules_command(
    command: RulesCommands,
    config: &wa_core::config::Config,
    cli_config: Option<&str>,
    resolved_config_path: Option<&Path>,
    layout: &wa_core::config::WorkspaceLayout,
) {
    use wa_core::output::{
        OutputFormat, RenderContext, RuleDetail, RuleDetailRenderer, RuleListItem, RuleTestMatch,
        RulesListRenderer, RulesTestRenderer, detect_format,
    };
    use wa_core::patterns::{AgentType, PatternEngine};

    let patterns_root = resolved_config_path.and_then(|p| p.parent());
    let load_engine = || {
        PatternEngine::from_config_with_root(&config.patterns, patterns_root).unwrap_or_else(
            |err| {
                eprintln!("Failed to load pattern packs: {err}");
                std::process::exit(1);
            },
        )
    };

    match command {
        RulesCommands::List {
            agent_type,
            verbose,
            format,
        } => {
            let engine = load_engine();
            let fmt = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            let agent_filter: Option<AgentType> =
                agent_type.as_ref().and_then(|s| match s.as_str() {
                    "codex" => Some(AgentType::Codex),
                    "claude_code" => Some(AgentType::ClaudeCode),
                    "gemini" => Some(AgentType::Gemini),
                    "wezterm" => Some(AgentType::Wezterm),
                    _ => None,
                });

            let rules: Vec<RuleListItem> = engine
                .rules()
                .iter()
                .filter(|rule| {
                    if let Some(ref agent) = agent_filter {
                        rule.agent_type == *agent
                    } else {
                        true
                    }
                })
                .map(|rule| RuleListItem {
                    id: rule.id.clone(),
                    agent_type: format!("{}", rule.agent_type),
                    event_type: rule.event_type.clone(),
                    severity: format!("{:?}", rule.severity).to_lowercase(),
                    description: rule.description.clone(),
                    workflow: rule.workflow.clone(),
                    anchor_count: rule.anchors.len(),
                    has_regex: rule.regex.is_some(),
                })
                .collect();

            let ctx = RenderContext::new(fmt).verbose(verbose);
            let output = if verbose > 0 {
                RulesListRenderer::render_verbose(&rules, &ctx)
            } else {
                RulesListRenderer::render(&rules, &ctx)
            };
            print!("{output}");
        }

        RulesCommands::Test { text, format } => {
            let engine = load_engine();
            let fmt = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            let detections = engine.detect(&text);
            let matches: Vec<RuleTestMatch> = detections
                .iter()
                .map(|d| RuleTestMatch {
                    rule_id: d.rule_id.clone(),
                    agent_type: format!("{}", d.agent_type),
                    event_type: d.event_type.clone(),
                    severity: format!("{:?}", d.severity).to_lowercase(),
                    confidence: d.confidence,
                    matched_text: d.matched_text.clone(),
                    extracted: if d.extracted.is_null()
                        || d.extracted
                            .as_object()
                            .is_some_and(serde_json::Map::is_empty)
                    {
                        None
                    } else {
                        Some(d.extracted.clone())
                    },
                })
                .collect();

            let ctx = RenderContext::new(fmt);
            let output = RulesTestRenderer::render(&matches, text.len(), &ctx);
            print!("{output}");
        }

        RulesCommands::Show { rule_id, format } => {
            let engine = load_engine();
            let fmt = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            if let Some(rule) = engine.rules().iter().find(|r| r.id == rule_id) {
                let detail = RuleDetail {
                    id: rule.id.clone(),
                    agent_type: format!("{}", rule.agent_type),
                    event_type: rule.event_type.clone(),
                    severity: format!("{:?}", rule.severity).to_lowercase(),
                    description: rule.description.clone(),
                    anchors: rule.anchors.clone(),
                    regex: rule.regex.clone(),
                    workflow: rule.workflow.clone(),
                    remediation: rule.remediation.clone(),
                    manual_fix: rule.manual_fix.clone(),
                    learn_more_url: rule.learn_more_url.clone(),
                };

                let ctx = RenderContext::new(fmt);
                let output = RuleDetailRenderer::render(&detail, &ctx);
                print!("{output}");
            } else {
                eprintln!("Rule '{}' not found.", rule_id);
                eprintln!("Use 'wa rules list' to see available rules.");
                std::process::exit(1);
            }
        }

        RulesCommands::Profile { command } => {
            if let Err(err) =
                handle_rules_profile_command(command, cli_config, resolved_config_path, layout)
            {
                eprintln!("{err}");
                std::process::exit(1);
            }
        }
    }
}

/// Handle `wa config` subcommands
async fn handle_config_command(
    command: ConfigCommands,
    cli_config: Option<&str>,
    cli_workspace: Option<&str>,
) -> anyhow::Result<()> {
    use wa_core::config::{Config, ConfigOverrides};

    match command {
        ConfigCommands::Init { force, path } => {
            // Determine config path
            let config_path = if let Some(p) = path {
                std::path::PathBuf::from(p)
            } else if let Some(p) = cli_config {
                std::path::PathBuf::from(p)
            } else {
                // Default: ./wa.toml, fallback to ~/.config/wa/wa.toml
                let cwd_config = std::path::PathBuf::from("wa.toml");
                if cwd_config.exists() && !force {
                    anyhow::bail!(
                        "Config file already exists at {}. Use --force to overwrite.",
                        cwd_config.display()
                    );
                }
                if cwd_config.exists() || std::env::current_dir().is_ok() {
                    cwd_config
                } else {
                    dirs::config_dir()
                        .unwrap_or_else(|| std::path::PathBuf::from("~/.config"))
                        .join("wa")
                        .join("wa.toml")
                }
            };

            // Check if exists
            if config_path.exists() && !force {
                anyhow::bail!(
                    "Config file already exists at {}. Use --force to overwrite.",
                    config_path.display()
                );
            }

            // Create parent directories
            if let Some(parent) = config_path.parent() {
                std::fs::create_dir_all(parent)?;
            }

            // Write default config
            let _default_config = Config::default();
            let toml_content = generate_default_config_toml();
            std::fs::write(&config_path, toml_content)?;

            println!("Created config at: {}", config_path.display());
            println!();
            println!("Edit this file to customize wa behavior.");
            println!("Run `wa config validate` to check for errors.");
        }

        ConfigCommands::Validate { path, strict } => {
            // Find config
            let config_path = if let Some(p) = path {
                Some(std::path::PathBuf::from(p))
            } else {
                cli_config.map(std::path::PathBuf::from)
            };

            let config = Config::load_with_overrides(
                config_path.as_deref(),
                strict,
                &ConfigOverrides::default(),
            )?;

            // Run validation
            config.validate()?;

            let path_display = config_path
                .as_ref()
                .map_or_else(|| "(default)".to_string(), |p| p.display().to_string());

            println!(" Config is valid: {path_display}");

            // Show any warnings (non-fatal)
            let warnings = validate_config_warnings(&config);
            if !warnings.is_empty() {
                println!();
                println!("Warnings:");
                for warning in &warnings {
                    println!("   {warning}");
                }
                if strict {
                    anyhow::bail!("{} warning(s) found in strict mode", warnings.len());
                }
            }
        }

        ConfigCommands::Show {
            effective,
            json,
            path,
        } => {
            // Find config
            let config_path = if let Some(p) = path {
                Some(std::path::PathBuf::from(p))
            } else {
                cli_config.map(std::path::PathBuf::from)
            };

            let config = Config::load_with_overrides(
                config_path.as_deref(),
                false,
                &ConfigOverrides::default(),
            )?;

            if effective {
                // Show effective config with resolved paths
                let workspace_root = cli_workspace.map(std::path::PathBuf::from);
                let effective_config = config.effective_config(workspace_root.as_deref())?;

                if json {
                    println!("{}", serde_json::to_string_pretty(&effective_config)?);
                } else {
                    println!("Effective Configuration");
                    println!("=======================");
                    println!();
                    println!("Paths:");
                    println!(
                        "  workspace_root: {}",
                        effective_config.paths.workspace_root
                    );
                    println!("  wa_dir:         {}", effective_config.paths.wa_dir);
                    println!("  db_path:        {}", effective_config.paths.db_path);
                    println!("  lock_path:      {}", effective_config.paths.lock_path);
                    println!(
                        "  ipc_socket:     {}",
                        effective_config.paths.ipc_socket_path
                    );
                    println!("  logs_dir:       {}", effective_config.paths.logs_dir);
                    println!("  log_path:       {}", effective_config.paths.log_path);
                    println!();
                    println!("Settings:");
                    println!(
                        "  log_level:      {}",
                        effective_config.config.general.log_level
                    );
                    println!(
                        "  log_format:     {}",
                        effective_config.config.general.log_format
                    );
                    println!(
                        "  poll_interval:  {}ms",
                        effective_config.config.ingest.poll_interval_ms
                    );
                    println!(
                        "  retention_days: {}",
                        effective_config.config.storage.retention_days
                    );
                }
            } else {
                // Show raw config
                if json {
                    println!("{}", serde_json::to_string_pretty(&config)?);
                } else {
                    // Re-serialize to TOML for display
                    let toml_str =
                        toml::to_string_pretty(&config).unwrap_or_else(|_| format!("{config:?}"));
                    println!("{toml_str}");
                }
            }
        }

        ConfigCommands::Set {
            key,
            value,
            dry_run,
            path,
        } => {
            // Find config path
            let config_path = if let Some(p) = path {
                std::path::PathBuf::from(p)
            } else if let Some(p) = cli_config {
                std::path::PathBuf::from(p)
            } else {
                // Default to ./wa.toml or user config
                let cwd_config = std::path::PathBuf::from("wa.toml");
                if cwd_config.exists() {
                    cwd_config
                } else {
                    dirs::config_dir()
                        .unwrap_or_else(|| std::path::PathBuf::from("~/.config"))
                        .join("wa")
                        .join("wa.toml")
                }
            };

            // Read existing config
            let content = if config_path.exists() {
                std::fs::read_to_string(&config_path)?
            } else {
                generate_default_config_toml()
            };

            // Parse as TOML value for modification
            let mut doc = content
                .parse::<toml_edit::DocumentMut>()
                .map_err(|e| anyhow::anyhow!("Failed to parse config: {e}"))?;

            // Split key by dots
            let parts: Vec<&str> = key.split('.').collect();
            if parts.is_empty() {
                anyhow::bail!("Invalid key: empty");
            }

            // Navigate to the target and set value
            set_toml_value(&mut doc, &parts, &value)?;

            let updated = doc.to_string();
            let diff_lines = compute_config_diff(&content, &updated);
            if diff_lines.is_empty() {
                println!("No changes detected  configuration already matches.");
                return Ok(());
            }

            println!(
                "Set preview ({} change{}):",
                diff_lines.len(),
                if diff_lines.len() == 1 { "" } else { "s" }
            );
            for line in &diff_lines {
                println!("  {line}");
            }

            if dry_run {
                println!("\n(dry run  no changes applied)");
                println!("Config file: {}", config_path.display());
                return Ok(());
            }

            // Create parent directory if needed
            if let Some(parent) = config_path.parent() {
                std::fs::create_dir_all(parent)?;
            }

            // Write back
            std::fs::write(&config_path, updated)?;

            println!("Set {key} = {value}");
            println!("Config file: {}", config_path.display());
        }

        ConfigCommands::Export { output, json, path } => {
            let config_path = if let Some(p) = path {
                Some(std::path::PathBuf::from(p))
            } else {
                cli_config.map(std::path::PathBuf::from)
            };

            let config = Config::load_with_overrides(
                config_path.as_deref(),
                false,
                &ConfigOverrides::default(),
            )?;

            let exported = if json {
                serde_json::to_string_pretty(&config)?
            } else {
                let mut header = String::new();
                header.push_str("# wa configuration export\n");
                header.push_str(&format!("# Exported: {}\n", chrono_stub_now()));
                header.push_str(&format!("# wa version: {}\n\n", wa_core::VERSION));

                let toml_body = config.to_toml()?;
                format!("{header}{toml_body}")
            };

            if let Some(out_path) = output {
                let out = std::path::PathBuf::from(&out_path);
                if let Some(parent) = out.parent() {
                    std::fs::create_dir_all(parent)?;
                }
                std::fs::write(&out, &exported)?;
                println!("Exported config to: {out_path}");
            } else {
                print!("{exported}");
            }
        }

        ConfigCommands::Import {
            source,
            dry_run,
            replace,
            yes,
            path,
        } => {
            let source_path = std::path::PathBuf::from(&source);
            if !source_path.exists() {
                anyhow::bail!("Source config not found: {source}");
            }

            // Load and validate the incoming config
            let source_content = std::fs::read_to_string(&source_path)?;
            let incoming: Config = toml::from_str(&source_content)
                .map_err(|e| anyhow::anyhow!("Invalid config in {source}: {e}"))?;
            incoming.validate()?;

            // Resolve target config path
            let config_path = if let Some(p) = path {
                std::path::PathBuf::from(p)
            } else if let Some(p) = cli_config {
                std::path::PathBuf::from(p)
            } else {
                let cwd_config = std::path::PathBuf::from("wa.toml");
                if cwd_config.exists() {
                    cwd_config
                } else {
                    dirs::config_dir()
                        .unwrap_or_else(|| std::path::PathBuf::from("~/.config"))
                        .join("wa")
                        .join("wa.toml")
                }
            };

            // Show what would change
            let existing_toml = if config_path.exists() {
                std::fs::read_to_string(&config_path)?
            } else {
                generate_default_config_toml()
            };
            let incoming_toml = incoming.to_toml()?;

            // Compute simple diff summary
            let diff_lines = compute_config_diff(&existing_toml, &incoming_toml);
            if diff_lines.is_empty() {
                println!("No changes detected  configs are equivalent.");
                return Ok(());
            }

            let mode_label = if replace { "Replace" } else { "Import" };
            println!(
                "{mode_label} preview ({} change{}):",
                diff_lines.len(),
                if diff_lines.len() == 1 { "" } else { "s" }
            );
            for line in &diff_lines {
                println!("  {line}");
            }

            if dry_run {
                println!("\n(dry run  no changes applied)");
                return Ok(());
            }

            if replace && !yes {
                println!();
                eprintln!("Warning: --replace will overwrite your entire configuration.");
                if !prompt_confirm("Continue? [y/N]: ")? {
                    println!("Aborted.");
                    return Ok(());
                }
            }

            // Backup existing config before overwriting
            if config_path.exists() {
                let backup = config_path.with_extension("toml.bak");
                std::fs::copy(&config_path, &backup)?;
                println!("Backup saved to: {}", backup.display());
            }

            // Write the new config
            if let Some(parent) = config_path.parent() {
                std::fs::create_dir_all(parent)?;
            }

            if replace {
                // Full replacement
                let header = format!(
                    "# wa configuration (imported)\n# Imported: {}\n# Source: {}\n\n",
                    chrono_stub_now(),
                    source,
                );
                std::fs::write(&config_path, format!("{header}{incoming_toml}"))?;
            } else {
                // Merge: load incoming on top of existing defaults
                // Parse both as TOML documents and overlay incoming sections
                let mut existing_doc = existing_toml
                    .parse::<toml_edit::DocumentMut>()
                    .map_err(|e| anyhow::anyhow!("Failed to parse existing config: {e}"))?;
                let incoming_doc = incoming_toml
                    .parse::<toml_edit::DocumentMut>()
                    .map_err(|e| anyhow::anyhow!("Failed to parse incoming config: {e}"))?;

                // Overlay all top-level tables from incoming into existing
                for (key, item) in incoming_doc.iter() {
                    existing_doc[key] = item.clone();
                }
                std::fs::write(&config_path, existing_doc.to_string())?;
            }

            println!("Config updated: {}", config_path.display());
        }

        ConfigCommands::Profile { command } => {
            handle_config_profile_command(command, cli_config)?;
        }
    }

    Ok(())
}

/// Stub for timestamp generation (avoids chrono dependency)
fn chrono_stub_now() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};
    let secs = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    // Basic ISO 8601 approximation
    let days = secs / 86400;
    let time = secs % 86400;
    let hours = time / 3600;
    let mins = (time % 3600) / 60;
    let secs_rem = time % 60;

    let mut year: u64 = 1970;
    let mut rem = days;
    loop {
        let ydays = if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) {
            366
        } else {
            365
        };
        if rem < ydays {
            break;
        }
        rem -= ydays;
        year += 1;
    }
    let mut month: u64 = 1;
    loop {
        let mdays = match month {
            1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,
            2 => {
                if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) {
                    29
                } else {
                    28
                }
            }
            _ => 30,
        };
        if rem < mdays {
            break;
        }
        rem -= mdays;
        month += 1;
    }
    let day = rem + 1;
    format!("{year:04}-{month:02}-{day:02}T{hours:02}:{mins:02}:{secs_rem:02}Z")
}

/// Compute a simple line-level diff summary between two TOML strings
fn compute_config_diff(existing: &str, incoming: &str) -> Vec<String> {
    let existing_lines: Vec<&str> = existing.lines().collect();
    let incoming_lines: Vec<&str> = incoming.lines().collect();
    let mut diffs = Vec::new();

    // Build sets for quick lookup
    let existing_set: std::collections::HashSet<&str> = existing_lines.iter().copied().collect();
    let incoming_set: std::collections::HashSet<&str> = incoming_lines.iter().copied().collect();

    // Find added lines (in incoming but not existing), skip comments and blanks
    for line in &incoming_lines {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with('#') {
            continue;
        }
        if !existing_set.contains(line) {
            diffs.push(format!("+ {trimmed}"));
        }
    }

    // Find removed lines (in existing but not incoming), skip comments and blanks
    for line in &existing_lines {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with('#') {
            continue;
        }
        if !incoming_set.contains(line) {
            diffs.push(format!("- {trimmed}"));
        }
    }

    diffs
}

/// Handle `wa learn` command for interactive tutorials
#[allow(clippy::fn_params_excessive_bools)]
fn handle_learn_command(
    track: Option<String>,
    status: bool,
    achievements: bool,
    reset: bool,
    complete: bool,
    skip: bool,
    json: bool,
) -> anyhow::Result<()> {
    use wa_core::learn::{TutorialEngine, TutorialEvent, TutorialStatus};

    let mut engine = TutorialEngine::load_or_create()?;

    // Handle reset
    if reset {
        engine.handle_event(TutorialEvent::Reset)?;
        engine.save()?;
        if json {
            println!(r#"{{"reset": true}}"#);
        } else {
            println!("Tutorial progress has been reset.");
        }
        return Ok(());
    }

    // Handle achievements
    if achievements {
        if json {
            let collection = engine.achievement_collection();
            println!("{}", serde_json::to_string_pretty(&collection)?);
        } else {
            println!("{}", engine.format_achievement_list());
        }
        return Ok(());
    }

    // Handle status
    if status {
        let status: TutorialStatus = (&engine).into();
        if json {
            println!("{}", serde_json::to_string_pretty(&status)?);
        } else {
            println!("wa learn --status\n");
            println!(
                "Overall Progress: {}/{} exercises",
                status.completed_exercises, status.total_exercises
            );
            println!("Achievements: {}", status.achievements_earned);
            println!("Time spent: {} minutes\n", status.total_time_minutes);

            println!("Tracks:");
            for t in &status.tracks {
                let marker = if t.is_complete { "" } else { " " };
                println!("  [{marker}] {} ({}/{})", t.name, t.completed, t.total);
            }

            if let Some(current) = &status.current_track {
                println!("\nCurrent track: {}", current);
            }
            if let Some(exercise) = &status.current_exercise {
                println!("Current exercise: {}", exercise);
            }
        }
        return Ok(());
    }

    // Handle complete or skip flags
    if complete || skip {
        if let Some(exercise_id) = engine.state().current_exercise.clone() {
            let track_id = engine.state().current_track.clone();
            let before_count = engine.state().achievements.len();
            let event = if complete {
                TutorialEvent::CompleteExercise(exercise_id.clone())
            } else {
                TutorialEvent::SkipExercise(exercise_id.clone())
            };
            engine.handle_event(event)?;
            engine.save()?;

            if json {
                let action = if complete { "completed" } else { "skipped" };
                let new_achievements: Vec<_> = engine
                    .state()
                    .achievements
                    .iter()
                    .skip(before_count)
                    .collect();
                let response = serde_json::json!({
                    "exercise": exercise_id,
                    "action": action,
                    "new_achievements": new_achievements,
                });
                println!("{}", response);
            } else {
                let action = if complete { "completed" } else { "skipped" };
                println!("Exercise {} {}!", exercise_id, action);

                // Show any newly unlocked achievements
                for achievement in engine.state().achievements.iter().skip(before_count) {
                    println!(
                        "\n{}",
                        TutorialEngine::format_achievement_unlock(achievement)
                    );
                }

                // Show next exercise or completion
                if let Some(next) = engine.current_exercise() {
                    println!("\nNext exercise: {}", next.title);
                    if let Some(tid) = &track_id {
                        println!("Run: wa learn {} to continue", tid);
                    }
                } else if let Some(tid) = &track_id {
                    if engine.is_track_complete(tid) {
                        println!("\nTrack '{}' complete!", tid);
                    }
                }
            }
            return Ok(());
        }
        anyhow::bail!("No exercise in progress. Start a track first with: wa learn <track>");
    }

    // Handle track selection or show menu
    if let Some(track_id) = track {
        // Validate track exists
        if engine.get_track(&track_id).is_none() {
            let available: Vec<_> = engine.tracks().iter().map(|t| t.id.as_str()).collect();
            anyhow::bail!(
                "Unknown track '{}'. Available tracks: {}",
                track_id,
                available.join(", ")
            );
        }

        engine.handle_event(TutorialEvent::StartTrack(track_id.clone()))?;
        engine.save()?;

        // Show current exercise
        if let Some(exercise) = engine.current_exercise() {
            if json {
                println!("{}", serde_json::to_string_pretty(&exercise)?);
            } else {
                let (completed, total) = engine.track_progress(&track_id);
                println!("wa learn {}\n", track_id);
                println!(
                    "Track: {} ({}/{})",
                    engine
                        .get_track(&track_id)
                        .map(|t| t.name.as_str())
                        .unwrap_or(&track_id),
                    completed,
                    total
                );
                println!("\n--- Exercise: {} ---\n", exercise.title);
                println!("{}\n", exercise.description);
                println!("Instructions:");
                for (i, step) in exercise.instructions.iter().enumerate() {
                    println!("  {}. {}", i + 1, step);
                }
                println!("\nWhen done, run: wa learn --complete");
            }
        } else {
            // Track complete
            if json {
                let response = serde_json::json!({
                    "track": track_id,
                    "complete": true
                });
                println!("{}", response);
            } else {
                println!("Track '{}' is complete!", track_id);
            }
        }
    } else {
        // Show track selection
        engine.handle_event(TutorialEvent::Heartbeat)?;
        engine.save()?;

        if json {
            let status: TutorialStatus = (&engine).into();
            println!("{}", serde_json::to_string_pretty(&status)?);
        } else {
            println!("wa learn\n");
            println!("Welcome to the wa tutorial!\n");
            println!("Available tracks:\n");

            for track in engine.tracks() {
                let (completed, total) = engine.track_progress(&track.id);
                let status_marker = if engine.is_track_complete(&track.id) {
                    ""
                } else if completed > 0 {
                    ""
                } else {
                    " "
                };
                println!(
                    "  [{status_marker}] {} - {} (~{} min)",
                    track.id, track.description, track.estimated_minutes
                );
                println!("      Progress: {}/{}", completed, total);
            }

            println!("\nTo start a track, run: wa learn <track>");
            println!("Example: wa learn basics");

            if let Some(current) = engine.state().current_track.as_ref() {
                println!("\nResume your current track: wa learn {}", current);
            }
        }
    }

    Ok(())
}

/// Handle `wa db` subcommands
async fn handle_db_command(
    command: DbCommands,
    layout: &wa_core::config::WorkspaceLayout,
    retention_days: u32,
) -> anyhow::Result<()> {
    use wa_core::storage::{
        MigrationDirection, SCHEMA_VERSION, migrate_database_to_version, migration_plan_for_path,
        migration_status_for_path,
    };

    let db_path = &layout.db_path;

    match command {
        DbCommands::Migrate {
            status,
            to,
            yes,
            allow_downgrade,
            dry_run,
        } => {
            let target_version = to.unwrap_or(SCHEMA_VERSION);

            if status {
                let report = migration_status_for_path(db_path)?;
                print_migration_status(&report, db_path);
                return Ok(());
            }

            if dry_run {
                let report = migration_status_for_path(db_path)?;
                if report.needs_initialization {
                    println!("Database is uninitialized at {}.", db_path.display());
                    println!("Would initialize to schema v{}.", SCHEMA_VERSION);
                    return Ok(());
                }
                let plan = migration_plan_for_path(db_path, target_version)?;
                print_migration_plan(&plan);
                return Ok(());
            }

            let report = migration_status_for_path(db_path)?;
            if report.needs_initialization {
                if target_version != SCHEMA_VERSION {
                    anyhow::bail!(
                        "Database is uninitialized; can only initialize to schema v{}.",
                        SCHEMA_VERSION
                    );
                }
                println!(
                    "Database is uninitialized; will initialize to schema v{}.",
                    SCHEMA_VERSION
                );
                if !yes && !prompt_confirm("Proceed? [y/N]: ")? {
                    println!("Aborted.");
                    return Ok(());
                }
                let plan = migrate_database_to_version(db_path, target_version)?;
                println!("Migration complete.");
                print_migration_plan(&plan);
                return Ok(());
            }

            let plan = migration_plan_for_path(db_path, target_version)?;
            if plan.steps.is_empty() {
                println!("Database already at schema v{}.", plan.to_version);
                return Ok(());
            }

            if plan.direction == MigrationDirection::Down && !allow_downgrade {
                anyhow::bail!(
                    "Refusing to downgrade from v{} to v{} without --allow-downgrade.",
                    plan.from_version,
                    plan.to_version
                );
            }

            print_migration_plan(&plan);
            if !yes && !prompt_confirm("Apply migrations? [y/N]: ")? {
                println!("Aborted.");
                return Ok(());
            }

            let applied_plan = migrate_database_to_version(db_path, target_version)?;
            println!("Migration complete.");
            print_migration_plan(&applied_plan);
        }

        DbCommands::Check { format } => {
            use wa_core::output::{OutputFormat, detect_format};
            use wa_core::storage::{DbCheckStatus, check_database_health};

            let output_format = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };
            let report = check_database_health(db_path);

            if output_format == OutputFormat::Json {
                println!(
                    "{}",
                    serde_json::to_string_pretty(&report)
                        .unwrap_or_else(|e| format!("{{\"error\": \"{e}\"}}"))
                );
            } else {
                println!("Database: {}", report.db_path);
                if let Some(size) = report.db_size_bytes {
                    let size_display = if size > 1_048_576 {
                        format!("{:.1} MB", size as f64 / 1_048_576.0)
                    } else if size > 1024 {
                        format!("{:.1} KB", size as f64 / 1024.0)
                    } else {
                        format!("{size} bytes")
                    };
                    println!("Size: {size_display}");
                }
                println!();
                println!("Running health checks...");

                for check in &report.checks {
                    let icon = match check.status {
                        DbCheckStatus::Ok => "  [OK]",
                        DbCheckStatus::Warning => "  [WARN]",
                        DbCheckStatus::Error => "  [ERR]",
                    };
                    if let Some(detail) = &check.detail {
                        println!("{icon} {}: {detail}", check.name);
                    } else {
                        println!("{icon} {}", check.name);
                    }
                }

                let problems = report.problem_count();
                println!();
                if problems == 0 {
                    println!("Summary: Database is healthy");
                } else {
                    println!("Problems found: {problems}");
                    println!("Run: wa db repair --dry-run");
                }
            }

            if report.has_errors() {
                std::process::exit(1);
            } else if report.has_warnings() {
                std::process::exit(2);
            }
        }

        DbCommands::Repair {
            dry_run,
            yes,
            no_backup,
            format,
        } => {
            use wa_core::output::{OutputFormat, detect_format};
            use wa_core::storage::repair_database;

            let output_format = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            if dry_run {
                if output_format != OutputFormat::Json {
                    println!("Dry run  no changes will be made.\n");
                }
            } else if !yes {
                println!("This will repair the database at:");
                println!("  {}", db_path.display());
                if !no_backup {
                    println!("\nA backup will be created before repair.");
                }
                println!();
                if !prompt_confirm("Proceed with repair? [y/N]: ")? {
                    println!("Aborted.");
                    return Ok(());
                }
            }

            let report = repair_database(db_path, dry_run, no_backup)?;

            if output_format == OutputFormat::Json {
                println!(
                    "{}",
                    serde_json::to_string_pretty(&report)
                        .unwrap_or_else(|e| format!("{{\"error\": \"{e}\"}}"))
                );
            } else {
                if let Some(backup) = &report.backup_path {
                    println!("Backup created: {backup}");
                    println!();
                }

                let label = if dry_run {
                    "Would perform"
                } else {
                    "Repairing"
                };
                println!("{label}:");
                for (i, repair) in report.repairs.iter().enumerate() {
                    let status = if repair.success { "done" } else { "FAILED" };
                    if dry_run {
                        println!("  {}. {}", i + 1, repair.detail);
                    } else {
                        println!("  [{}] {} - {}", status, repair.name, repair.detail);
                    }
                }

                println!();
                if dry_run {
                    println!("No changes made. Run without --dry-run to apply.");
                } else if report.all_succeeded() {
                    println!("Repair complete. Run: wa db check");
                } else {
                    eprintln!("Some repairs failed. Check output above.");
                    std::process::exit(1);
                }
            }
        }

        DbCommands::Stats { format } => {
            use wa_core::output::{OutputFormat, detect_format};
            use wa_core::storage::database_stats;

            let output_format = match format.to_lowercase().as_str() {
                "json" => OutputFormat::Json,
                "plain" => OutputFormat::Plain,
                _ => detect_format(),
            };

            let report = database_stats(db_path, retention_days);

            if output_format == OutputFormat::Json {
                println!(
                    "{}",
                    serde_json::to_string_pretty(&report)
                        .unwrap_or_else(|e| format!("{{\"error\": \"{e}\"}}"))
                );
            } else {
                println!("Database: {}", report.db_path);
                if let Some(size) = report.db_size_bytes {
                    let size_display = if size > 1_048_576 {
                        format!("{:.1} MB", size as f64 / 1_048_576.0)
                    } else if size > 1024 {
                        format!("{:.1} KB", size as f64 / 1024.0)
                    } else {
                        format!("{size} bytes")
                    };
                    println!("Size: {size_display}");
                }

                println!();
                println!("Table row counts:");
                for table in &report.tables {
                    println!("  {:<25} {:>10}", table.name, table.row_count);
                }

                if !report.top_panes.is_empty() {
                    println!();
                    println!("Top panes by data volume:");
                    for pane in &report.top_panes {
                        let title = pane.title.as_deref().unwrap_or("(untitled)");
                        let seg_display = if pane.segment_bytes > 1_048_576 {
                            format!("{:.1} MB", pane.segment_bytes as f64 / 1_048_576.0)
                        } else if pane.segment_bytes > 1024 {
                            format!("{:.1} KB", pane.segment_bytes as f64 / 1024.0)
                        } else {
                            format!("{} B", pane.segment_bytes)
                        };
                        println!(
                            "  pane {} ({title}): {seg_display}, {} segments, {} events",
                            pane.pane_id, pane.segment_count, pane.event_count
                        );
                    }
                }

                if !report.event_types.is_empty() {
                    println!();
                    println!("Event type distribution:");
                    for et in &report.event_types {
                        println!("  {:<35} {:>8}", et.event_type, et.count);
                    }
                }

                println!();
                println!("Suggestions:");
                for suggestion in &report.suggestions {
                    println!("  - {suggestion}");
                }
            }
        }
    }

    Ok(())
}

fn resolve_notify_output_format(format: &str) -> wa_core::output::OutputFormat {
    use wa_core::output::{OutputFormat, detect_format};

    match format.to_lowercase().as_str() {
        "json" => OutputFormat::Json,
        "plain" => OutputFormat::Plain,
        "auto" => detect_format(),
        _ => {
            eprintln!("Error: Unknown output format '{format}'. Use auto, plain, or json.");
            std::process::exit(1);
        }
    }
}

fn parse_notify_severity(value: &str) -> Option<wa_core::patterns::Severity> {
    match value.to_lowercase().as_str() {
        "info" => Some(wa_core::patterns::Severity::Info),
        "warning" => Some(wa_core::patterns::Severity::Warning),
        "critical" => Some(wa_core::patterns::Severity::Critical),
        _ => None,
    }
}

fn parse_notify_agent_type(value: &str) -> Option<wa_core::patterns::AgentType> {
    match value.to_lowercase().as_str() {
        "codex" => Some(wa_core::patterns::AgentType::Codex),
        "claude_code" => Some(wa_core::patterns::AgentType::ClaudeCode),
        "gemini" => Some(wa_core::patterns::AgentType::Gemini),
        "wezterm" => Some(wa_core::patterns::AgentType::Wezterm),
        "unknown" => Some(wa_core::patterns::AgentType::Unknown),
        _ => None,
    }
}

fn notify_decision_label(decision: &wa_core::events::NotifyDecision) -> &'static str {
    use wa_core::events::NotifyDecision;

    match decision {
        NotifyDecision::Send { .. } => "send",
        NotifyDecision::Filtered => "filtered",
        NotifyDecision::Deduplicated { .. } => "deduplicated",
        NotifyDecision::Throttled { .. } => "throttled",
    }
}

fn glob_example(pattern: &str) -> String {
    let mut out = String::new();
    for ch in pattern.chars() {
        match ch {
            '*' => out.push_str("test"),
            '?' => out.push('x'),
            other => out.push(other),
        }
    }

    if out.trim().is_empty() {
        "wa.notify_test".to_string()
    } else {
        out
    }
}

fn notify_test_candidates(
    config: &wa_core::config::NotificationConfig,
    endpoint: Option<&wa_core::webhook::WebhookEndpointConfig>,
) -> Vec<String> {
    let mut seen = HashSet::new();
    let mut candidates = Vec::new();
    let mut push_candidate = |value: String| {
        if seen.insert(value.clone()) {
            candidates.push(value);
        }
    };

    if let Some(endpoint) = endpoint {
        for pattern in &endpoint.events {
            push_candidate(glob_example(pattern));
        }
    }

    for pattern in &config.include {
        push_candidate(glob_example(pattern));
    }

    push_candidate("wa.notify_test".to_string());
    candidates
}

fn build_notify_test_detection(
    rule_id: &str,
    agent_type: wa_core::patterns::AgentType,
    severity: wa_core::patterns::Severity,
) -> wa_core::patterns::Detection {
    wa_core::patterns::Detection {
        rule_id: rule_id.to_string(),
        agent_type,
        event_type: rule_id.to_string(),
        severity,
        confidence: 0.95,
        extracted: serde_json::json!({ "test": true }),
        matched_text: "wa notify test".to_string(),
        span: (0, 0),
    }
}

fn build_notify_test_rendered(
    secret: &str,
    severity: wa_core::patterns::Severity,
) -> wa_core::event_templates::RenderedEvent {
    wa_core::event_templates::RenderedEvent {
        summary: format!("wa notify test: secret {secret}"),
        description: format!("Testing redaction for {secret}"),
        suggestions: vec![wa_core::event_templates::Suggestion::with_command(
            "Rotate credentials",
            format!("export WA_NOTIFY_TOKEN={secret}"),
        )],
        severity,
    }
}

async fn handle_notify_command(
    command: NotifyCommands,
    config: &wa_core::config::Config,
) -> anyhow::Result<()> {
    match command {
        NotifyCommands::Test { channel, format } => {
            use wa_core::events::NotifyDecision;
            use wa_core::notifications::{NotificationPayload, NotificationSender};

            let output_format = resolve_notify_output_format(&format);
            let channel = channel.trim().to_string();

            if channel.is_empty() {
                let response = NotifyTestResponse {
                    ok: false,
                    error: Some("Channel name must not be empty".to_string()),
                    error_code: Some("E_CHANNEL_REQUIRED".to_string()),
                    hint: Some("Use `wa notify test --channel <name>`.".to_string()),
                    data: None,
                };
                emit_notify_test_response(&response, output_format);
                std::process::exit(1);
            }

            let warning = if !config.notifications.enabled {
                Some("notifications.enabled=false (test still attempted)".to_string())
            } else {
                None
            };

            let (channel_type, endpoint) = if channel.eq_ignore_ascii_case("desktop") {
                ("desktop".to_string(), None)
            } else {
                let endpoint = config
                    .notifications
                    .webhooks
                    .iter()
                    .find(|ep| ep.name.eq_ignore_ascii_case(&channel));
                match endpoint {
                    Some(ep) => ("webhook".to_string(), Some(ep)),
                    None => {
                        let mut available = vec!["desktop".to_string()];
                        available.extend(
                            config
                                .notifications
                                .webhooks
                                .iter()
                                .map(|ep| ep.name.clone()),
                        );
                        let response = NotifyTestResponse {
                            ok: false,
                            error: Some(format!("Unknown channel: {channel}")),
                            error_code: Some("E_CHANNEL_NOT_FOUND".to_string()),
                            hint: Some(format!("Available channels: {}", available.join(", "))),
                            data: None,
                        };
                        emit_notify_test_response(&response, output_format);
                        std::process::exit(1);
                    }
                }
            };

            if channel_type == "webhook" {
                if let Some(ep) = endpoint {
                    if !ep.enabled {
                        let response = NotifyTestResponse {
                            ok: false,
                            error: Some(format!("Channel '{channel}' is disabled")),
                            error_code: Some("E_CHANNEL_DISABLED".to_string()),
                            hint: Some(
                                "Enable the webhook endpoint in [notifications.webhooks]."
                                    .to_string(),
                            ),
                            data: None,
                        };
                        emit_notify_test_response(&response, output_format);
                        std::process::exit(1);
                    }
                }
            } else if !config.notifications.desktop.enabled {
                let response = NotifyTestResponse {
                    ok: false,
                    error: Some("Desktop notifications are disabled".to_string()),
                    error_code: Some("E_CHANNEL_DISABLED".to_string()),
                    hint: Some("Set [notifications.desktop].enabled = true to test.".to_string()),
                    data: None,
                };
                emit_notify_test_response(&response, output_format);
                std::process::exit(1);
            }

            let severity = match config
                .notifications
                .min_severity
                .as_deref()
                .and_then(parse_notify_severity)
            {
                Some(sev) => sev,
                None => wa_core::patterns::Severity::Warning,
            };

            let agent_type = if config.notifications.agent_types.is_empty() {
                wa_core::patterns::AgentType::Unknown
            } else {
                match parse_notify_agent_type(&config.notifications.agent_types[0]) {
                    Some(agent) => agent,
                    None => {
                        let response = NotifyTestResponse {
                            ok: false,
                            error: Some(
                                "Invalid notifications.agent_types configuration".to_string(),
                            ),
                            error_code: Some("E_NOTIFY_CONFIG".to_string()),
                            hint: Some(
                                "Use codex, claude_code, gemini, wezterm, or unknown.".to_string(),
                            ),
                            data: None,
                        };
                        emit_notify_test_response(&response, output_format);
                        std::process::exit(1);
                    }
                }
            };

            let mut gate = config.notifications.to_notification_gate();
            let event_type = {
                let filter = gate.filter();
                notify_test_candidates(&config.notifications, endpoint)
                    .into_iter()
                    .find(|candidate| {
                        let detection =
                            build_notify_test_detection(candidate, agent_type, severity);
                        if !filter.matches(&detection) {
                            return false;
                        }
                        if let Some(ep) = endpoint {
                            return ep.matches_event_type(candidate);
                        }
                        true
                    })
            };

            let Some(event_type) = event_type else {
                let response = NotifyTestResponse {
                    ok: false,
                    error: Some("Notification filters exclude test events".to_string()),
                    error_code: Some("E_NOTIFICATION_FILTERED".to_string()),
                    hint: Some(
                        "Adjust notifications.include/exclude/min_severity/agent_types or channel events."
                            .to_string(),
                    ),
                    data: None,
                };
                emit_notify_test_response(&response, output_format);
                std::process::exit(1);
            };

            let detection = build_notify_test_detection(&event_type, agent_type, severity);
            let pane_id = 0;
            let decision = gate.should_notify(&detection, pane_id, None);
            let suppressed_since_last = match decision {
                NotifyDecision::Send {
                    suppressed_since_last,
                } => suppressed_since_last,
                _ => 0,
            };

            let secret = "sk-abc123456789012345678901234567890123456789012345678901";
            let rendered = build_notify_test_rendered(secret, severity);
            let redactor = wa_core::policy::Redactor::new();
            let payload = NotificationPayload::from_detection_with_redactor(
                &detection,
                pane_id,
                &rendered,
                suppressed_since_last,
                &redactor,
            );

            let mut redaction_issues = Vec::new();
            if !payload.summary.contains("[REDACTED]") {
                redaction_issues.push("summary_not_redacted".to_string());
            }
            if redactor.contains_secrets(&payload.summary) {
                redaction_issues.push("summary_contains_secret".to_string());
            }
            if !payload.description.contains("[REDACTED]") {
                redaction_issues.push("description_not_redacted".to_string());
            }
            if redactor.contains_secrets(&payload.description) {
                redaction_issues.push("description_contains_secret".to_string());
            }
            if let Some(quick_fix) = payload.quick_fix.as_deref() {
                if !quick_fix.contains("[REDACTED]") {
                    redaction_issues.push("quick_fix_not_redacted".to_string());
                }
                if redactor.contains_secrets(quick_fix) {
                    redaction_issues.push("quick_fix_contains_secret".to_string());
                }
            } else {
                redaction_issues.push("quick_fix_missing".to_string());
            }

            let redaction_ok = redaction_issues.is_empty();
            let decision_label = notify_decision_label(&decision).to_string();

            let mut output = NotifyTestOutput {
                channel: channel.clone(),
                channel_type: channel_type.clone(),
                event_type: event_type.clone(),
                severity: payload.severity.clone(),
                agent_type: payload.agent_type.clone(),
                decision: decision_label.clone(),
                redaction_ok,
                redaction_issues,
                payload,
                delivery: None,
                warning,
            };

            if !redaction_ok {
                let response = NotifyTestResponse {
                    ok: false,
                    error: Some("Redaction failed for test payload".to_string()),
                    error_code: Some("E_REDACTION_FAILED".to_string()),
                    hint: Some("Check secret patterns in wa_core::policy::Redactor.".to_string()),
                    data: Some(output),
                };
                emit_notify_test_response(&response, output_format);
                std::process::exit(1);
            }

            if !matches!(decision, NotifyDecision::Send { .. }) {
                let response = NotifyTestResponse {
                    ok: false,
                    error: Some(format!(
                        "Notification gate returned decision: {decision_label}"
                    )),
                    error_code: Some("E_NOTIFICATION_BLOCKED".to_string()),
                    hint: Some("Review notification filters or cooldown settings.".to_string()),
                    data: Some(output),
                };
                emit_notify_test_response(&response, output_format);
                std::process::exit(1);
            }

            let delivery = if channel_type == "desktop" {
                let notifier = wa_core::desktop_notify::DesktopNotifier::new(
                    config.notifications.desktop.clone(),
                );
                notifier.send(&output.payload).await
            } else {
                let endpoint = endpoint.expect("endpoint exists for webhook channel");
                let dispatcher = wa_core::webhook::WebhookDispatcher::new(
                    vec![endpoint.clone()],
                    Box::new(ReqwestWebhookTransport::new()),
                );
                dispatcher.send(&output.payload).await
            };

            output.delivery = Some(delivery.clone());

            if !delivery.success {
                let response = NotifyTestResponse {
                    ok: false,
                    error: Some(
                        delivery
                            .error
                            .clone()
                            .unwrap_or_else(|| "Notification delivery failed".to_string()),
                    ),
                    error_code: Some("E_DELIVERY_FAILED".to_string()),
                    hint: Some(
                        "Check endpoint reachability, auth headers, or desktop backend."
                            .to_string(),
                    ),
                    data: Some(output),
                };
                emit_notify_test_response(&response, output_format);
                std::process::exit(1);
            }

            let response = NotifyTestResponse {
                ok: true,
                error: None,
                error_code: None,
                hint: None,
                data: Some(output),
            };
            emit_notify_test_response(&response, output_format);
        }
    }

    Ok(())
}

fn emit_notify_test_response(response: &NotifyTestResponse, format: wa_core::output::OutputFormat) {
    if format.is_json() {
        println!(
            "{}",
            serde_json::to_string_pretty(response).unwrap_or_else(|_| "{}".to_string())
        );
        return;
    }

    if let Some(data) = &response.data {
        println!("wa notify test\n");
        println!("Channel: {} ({})", data.channel, data.channel_type);
        println!("Event: {}", data.event_type);
        println!("Severity: {}", data.severity);
        println!("Agent type: {}", data.agent_type);
        println!("Decision: {}", data.decision);
        if data.redaction_ok {
            println!("Redaction: OK");
        } else {
            println!("Redaction: FAILED");
            if !data.redaction_issues.is_empty() {
                println!("Redaction issues: {}", data.redaction_issues.join(", "));
            }
        }

        if let Some(delivery) = &data.delivery {
            let status = if delivery.success {
                "success"
            } else {
                "failed"
            };
            println!("Delivery: {}", status);
            if let Some(err) = &delivery.error {
                println!("Delivery error: {err}");
            }
            if !delivery.records.is_empty() {
                println!("Delivery records:");
                for (idx, record) in delivery.records.iter().enumerate() {
                    let accepted = if record.accepted {
                        "accepted"
                    } else {
                        "rejected"
                    };
                    if let Some(err) = &record.error {
                        println!(
                            "  {}. {} ({accepted}, status {}, error: {})",
                            idx + 1,
                            record.target,
                            record.status_code,
                            err
                        );
                    } else {
                        println!(
                            "  {}. {} ({accepted}, status {})",
                            idx + 1,
                            record.target,
                            record.status_code
                        );
                    }
                }
            }
        }

        if let Some(warning) = &data.warning {
            println!("Warning: {warning}");
        }
    }

    if !response.ok {
        if let Some(error) = &response.error {
            eprintln!("Error: {error}");
        }
        if let Some(hint) = &response.hint {
            eprintln!("Hint: {hint}");
        }
    }
}

async fn handle_backup_command(
    command: BackupCommands,
    layout: &wa_core::config::WorkspaceLayout,
    workspace_root: &Path,
) -> anyhow::Result<()> {
    match command {
        BackupCommands::Export {
            output,
            sql_dump,
            no_verify,
            format,
        } => {
            let db_path = &layout.db_path;

            if !db_path.exists() {
                if format == "json" {
                    let resp = serde_json::json!({
                        "ok": false,
                        "error": format!("Database not found: {}", db_path.display()),
                        "error_code": "E_DB_NOT_FOUND",
                        "hint": "Run 'wa watch' first to create the database.",
                    });
                    println!("{}", serde_json::to_string_pretty(&resp)?);
                } else {
                    eprintln!("Error: Database not found at {}", db_path.display());
                    eprintln!("Hint: Run 'wa watch' first to create the database.");
                }
                std::process::exit(1);
            }

            let opts = wa_core::backup::ExportOptions {
                output: output.map(std::path::PathBuf::from),
                include_sql_dump: sql_dump,
                verify: !no_verify,
            };

            if format != "json" {
                println!("Exporting backup...");
                println!("  Source: {}", db_path.display());
            }

            match wa_core::backup::export_backup(db_path, workspace_root, &opts) {
                Ok(result) => {
                    if format == "json" {
                        let resp = serde_json::json!({
                            "ok": true,
                            "data": {
                                "output_path": result.output_path,
                                "manifest": result.manifest,
                                "total_size_bytes": result.total_size_bytes,
                            }
                        });
                        println!("{}", serde_json::to_string_pretty(&resp)?);
                    } else {
                        println!("Backup saved: {}", result.output_path);
                        println!();
                        println!("  Schema version: {}", result.manifest.schema_version);
                        println!("  Database size:  {} bytes", result.manifest.db_size_bytes);
                        println!("  Total size:     {} bytes", result.total_size_bytes);
                        println!("  Checksum:       {}", result.manifest.db_checksum);
                        println!();
                        println!("  Stats:");
                        println!("    Panes:      {}", result.manifest.stats.panes);
                        println!("    Segments:   {}", result.manifest.stats.segments);
                        println!("    Events:     {}", result.manifest.stats.events);
                        println!("    Audit:      {}", result.manifest.stats.audit_actions);
                        println!(
                            "    Workflows:  {}",
                            result.manifest.stats.workflow_executions
                        );
                        if !no_verify {
                            println!();
                            println!("  Verified: OK");
                        }
                    }
                }
                Err(e) => {
                    if format == "json" {
                        let resp = serde_json::json!({
                            "ok": false,
                            "error": format!("{e}"),
                            "error_code": "E_BACKUP_FAILED",
                        });
                        println!("{}", serde_json::to_string_pretty(&resp)?);
                    } else {
                        eprintln!("Backup failed: {e}");
                    }
                    std::process::exit(1);
                }
            }
        }

        BackupCommands::Import {
            path,
            dry_run,
            yes,
            no_safety_backup,
            verify,
            format,
        } => {
            let backup_dir = PathBuf::from(&path);

            if !backup_dir.exists() || !backup_dir.is_dir() {
                if format == "json" {
                    let resp = serde_json::json!({
                        "ok": false,
                        "error": format!("Backup directory not found: {path}"),
                        "error_code": "E_BACKUP_NOT_FOUND",
                        "hint": "Provide the path to a backup directory created by 'wa backup export'.",
                    });
                    println!("{}", serde_json::to_string_pretty(&resp)?);
                } else {
                    eprintln!("Error: Backup directory not found: {path}");
                    eprintln!(
                        "Hint: Provide the path to a backup directory created by 'wa backup export'."
                    );
                }
                std::process::exit(1);
            }

            // Verify-only mode
            if verify {
                let manifest = wa_core::backup::load_backup_manifest(&backup_dir)?;
                match wa_core::backup::verify_backup(&backup_dir, &manifest) {
                    Ok(()) => {
                        if format == "json" {
                            let resp = serde_json::json!({
                                "ok": true,
                                "data": {
                                    "verified": true,
                                    "manifest": manifest,
                                }
                            });
                            println!("{}", serde_json::to_string_pretty(&resp)?);
                        } else {
                            println!("Backup verified: OK");
                            println!("  Version:  {}", manifest.wa_version);
                            println!("  Schema:   {}", manifest.schema_version);
                            println!("  Created:  {}", manifest.created_at);
                            println!("  Checksum: {}", manifest.db_checksum);
                            println!("  Size:     {} bytes", manifest.db_size_bytes);
                            println!();
                            println!("  Stats:");
                            println!("    Panes:     {}", manifest.stats.panes);
                            println!("    Segments:  {}", manifest.stats.segments);
                            println!("    Events:    {}", manifest.stats.events);
                            println!("    Audit:     {}", manifest.stats.audit_actions);
                            println!("    Workflows: {}", manifest.stats.workflow_executions);
                        }
                    }
                    Err(e) => {
                        if format == "json" {
                            let resp = serde_json::json!({
                                "ok": false,
                                "error": format!("{e}"),
                                "error_code": "E_VERIFICATION_FAILED",
                            });
                            println!("{}", serde_json::to_string_pretty(&resp)?);
                        } else {
                            eprintln!("Backup verification failed: {e}");
                        }
                        std::process::exit(1);
                    }
                }
                return Ok(());
            }

            let db_path = &layout.db_path;
            let opts = wa_core::backup::ImportOptions {
                dry_run,
                yes,
                no_safety_backup,
            };

            if dry_run {
                if format != "json" {
                    println!("Dry-run: showing what would happen...");
                }
            } else if !yes {
                let manifest = wa_core::backup::load_backup_manifest(&backup_dir)?;
                println!("Import backup from: {path}");
                println!("  Version: {}", manifest.wa_version);
                println!("  Schema:  {}", manifest.schema_version);
                println!("  Created: {}", manifest.created_at);
                println!(
                    "  Data:    {} segments, {} events",
                    manifest.stats.segments, manifest.stats.events
                );
                println!();
                if db_path.exists() {
                    println!(
                        "WARNING: This will replace the current database at {}",
                        db_path.display()
                    );
                    if !no_safety_backup {
                        println!("  A safety backup will be created first.");
                    }
                }
                if !prompt_confirm("Proceed? [y/N]: ")? {
                    println!("Aborted.");
                    return Ok(());
                }
            }

            match wa_core::backup::import_backup(&backup_dir, db_path, workspace_root, &opts) {
                Ok(result) => {
                    if format == "json" {
                        let resp = serde_json::json!({
                            "ok": true,
                            "data": {
                                "source_path": result.source_path,
                                "manifest": result.manifest,
                                "safety_backup_path": result.safety_backup_path,
                                "dry_run": result.dry_run,
                            }
                        });
                        println!("{}", serde_json::to_string_pretty(&resp)?);
                    } else if result.dry_run {
                        println!("Would import from: {}", result.source_path);
                        println!("  Schema: {}", result.manifest.schema_version);
                        println!("  Segments: {}", result.manifest.stats.segments);
                        println!("  Events: {}", result.manifest.stats.events);
                        if let Some(ref safety) = result.safety_backup_path {
                            println!("  Safety backup would be created at: {safety}");
                        }
                        println!();
                        println!("No changes made (dry-run).");
                    } else {
                        println!("Import complete.");
                        if let Some(ref safety) = result.safety_backup_path {
                            println!("  Safety backup: {safety}");
                        }
                        println!(
                            "  Restored {} segments, {} events",
                            result.manifest.stats.segments, result.manifest.stats.events
                        );
                    }
                }
                Err(e) => {
                    if format == "json" {
                        let resp = serde_json::json!({
                            "ok": false,
                            "error": format!("{e}"),
                            "error_code": "E_IMPORT_FAILED",
                        });
                        println!("{}", serde_json::to_string_pretty(&resp)?);
                    } else {
                        eprintln!("Import failed: {e}");
                    }
                    std::process::exit(1);
                }
            }
        }
    }

    Ok(())
}

fn print_migration_status(report: &MigrationStatusReport, db_path: &Path) {
    println!("Database: {}", db_path.display());
    println!("Exists: {}", report.db_exists);
    println!("Needs initialization: {}", report.needs_initialization);
    println!("Current schema version: {}", report.current_version);
    println!("Target schema version: {}", report.target_version);
    println!();
    println!("Migrations:");
    for entry in &report.entries {
        let applied = if entry.applied { "[x]" } else { "[ ]" };
        let rollback = if entry.rollback_supported {
            "rollback: yes"
        } else {
            "rollback: no"
        };
        println!(
            "  {applied} v{version:02} {desc} ({rollback})",
            version = entry.version,
            desc = entry.description
        );
    }
}

fn print_migration_plan(plan: &MigrationPlan) {
    println!(
        "Migration plan ({direction}): v{from} -> v{to}",
        direction = plan.direction.as_str(),
        from = plan.from_version,
        to = plan.to_version
    );

    if plan.steps.is_empty() {
        println!("  (no steps)");
        return;
    }

    for step in &plan.steps {
        println!(
            "  - {dir} v{from} -> v{to}: {desc}",
            dir = step.direction.as_str(),
            from = step.migration_version,
            to = step.resulting_version,
            desc = step.description
        );
    }
}

// =============================================================================
// Auth command handler
// =============================================================================

#[cfg(feature = "browser")]
async fn handle_auth_command(
    command: AuthCommands,
    layout: &wa_core::config::WorkspaceLayout,
    verbose: bool,
) -> anyhow::Result<()> {
    use wa_core::browser::{BrowserConfig, BrowserContext, BrowserProfile};

    match command {
        AuthCommands::Test {
            service,
            account,
            headful,
            timeout_secs: _,
            json,
        } => {
            let config = BrowserConfig {
                headless: !headful,
                ..Default::default()
            };
            let mut ctx = BrowserContext::new(config, &layout.wa_dir);

            let outcome = match ctx.ensure_ready() {
                Ok(()) => {
                    let profile = ctx.profile(&service, &account);
                    if profile.has_storage_state() {
                        let metadata = profile.read_metadata().ok().flatten();
                        AuthTestOutcome::Success {
                            service: service.clone(),
                            account: account.clone(),
                            elapsed_ms: None,
                            last_bootstrapped: metadata
                                .as_ref()
                                .and_then(|m| m.bootstrapped_at.clone()),
                        }
                    } else if profile.exists() {
                        AuthTestOutcome::NeedsHuman {
                            service: service.clone(),
                            account: account.clone(),
                            reason: "Profile exists but no storage state \
                                     (session expired or never bootstrapped)"
                                .into(),
                            next_step: format!(
                                "Run: wa auth bootstrap {service} --account {account}"
                            ),
                        }
                    } else {
                        AuthTestOutcome::NeedsHuman {
                            service: service.clone(),
                            account: account.clone(),
                            reason: "No browser profile found for this service/account".into(),
                            next_step: format!(
                                "Run: wa auth bootstrap {service} --account {account}"
                            ),
                        }
                    }
                }
                Err(e) => AuthTestOutcome::Fail {
                    service: service.clone(),
                    account: account.clone(),
                    error: format!("Browser initialization failed: {e}"),
                    next_step: Some(
                        "Check that Playwright is installed: npx playwright install chromium"
                            .into(),
                    ),
                },
            };

            if json {
                println!(
                    "{}",
                    serde_json::to_string_pretty(&outcome)
                        .unwrap_or_else(|e| format!("{{\"error\": \"{e}\"}}"))
                );
            } else {
                match &outcome {
                    AuthTestOutcome::Success {
                        service,
                        account,
                        last_bootstrapped,
                        ..
                    } => {
                        println!(" Auth test passed: {service}/{account}");
                        if let Some(ts) = last_bootstrapped {
                            println!("  Bootstrapped: {ts}");
                        }
                        if verbose {
                            let profile = ctx.profile(service, account);
                            println!("  Profile: {}", profile.path().display());
                        }
                    }
                    AuthTestOutcome::NeedsHuman {
                        service,
                        account,
                        reason,
                        next_step,
                    } => {
                        println!(" Auth test: needs human: {service}/{account}");
                        println!("  Reason: {reason}");
                        println!("  Next: {next_step}");
                    }
                    AuthTestOutcome::Fail {
                        service,
                        account,
                        error,
                        next_step,
                    } => {
                        eprintln!(" Auth test failed: {service}/{account}");
                        eprintln!("  Error: {error}");
                        if let Some(step) = next_step {
                            eprintln!("  Next: {step}");
                        }
                        std::process::exit(1);
                    }
                }
            }
        }

        AuthCommands::Status {
            service,
            account,
            all,
            json,
        } => {
            let config = BrowserConfig::default();
            let ctx = BrowserContext::new(config, &layout.wa_dir);
            let profiles_root = ctx.profiles_root();

            let mut statuses: Vec<AuthProfileStatus> = Vec::new();

            if all {
                if profiles_root.is_dir() {
                    if let Ok(services) = std::fs::read_dir(profiles_root) {
                        for svc_entry in services.flatten() {
                            if !svc_entry.path().is_dir() {
                                continue;
                            }
                            let svc_name = svc_entry.file_name().to_string_lossy().to_string();
                            if let Ok(accounts) = std::fs::read_dir(svc_entry.path()) {
                                for acct_entry in accounts.flatten() {
                                    if !acct_entry.path().is_dir() {
                                        continue;
                                    }
                                    let acct_name =
                                        acct_entry.file_name().to_string_lossy().to_string();
                                    let profile =
                                        BrowserProfile::new(profiles_root, &svc_name, &acct_name);
                                    statuses.push(build_profile_status(&profile));
                                }
                            }
                        }
                    }
                }

                if statuses.is_empty() {
                    if json {
                        println!("[]");
                    } else {
                        println!("No browser profiles found.");
                        println!("  Profiles dir: {}", profiles_root.display());
                        println!("  Hint: Run 'wa auth bootstrap <service>' to create one.");
                    }
                    return Ok(());
                }
            } else {
                let svc = service.as_deref().unwrap_or_else(|| {
                    eprintln!("Error: --service is required unless --all is used.");
                    std::process::exit(1);
                });
                let profile = BrowserProfile::new(profiles_root, svc, &account);
                statuses.push(build_profile_status(&profile));
            }

            if json {
                println!(
                    "{}",
                    serde_json::to_string_pretty(&statuses)
                        .unwrap_or_else(|e| format!("{{\"error\": \"{e}\"}}"))
                );
            } else {
                for status in &statuses {
                    println!("Profile: {}/{}", status.service, status.account);
                    println!(
                        "  Exists: {}",
                        if status.profile_exists { "yes" } else { "no" }
                    );
                    println!(
                        "  Storage state: {}",
                        if status.has_storage_state {
                            "yes"
                        } else {
                            "no"
                        }
                    );
                    if let Some(ts) = &status.bootstrapped_at {
                        println!("  Bootstrapped: {ts}");
                    }
                    if let Some(method) = &status.bootstrap_method {
                        println!("  Method: {method}");
                    }
                    if let Some(ts) = &status.last_used_at {
                        println!("  Last used: {ts}");
                    }
                    if let Some(count) = status.automated_use_count {
                        println!("  Automated uses: {count}");
                    }
                    if verbose {
                        let profile =
                            BrowserProfile::new(profiles_root, &status.service, &status.account);
                        println!("  Path: {}", profile.path().display());
                    }
                    println!();
                }
            }
        }

        AuthCommands::Bootstrap {
            service,
            account,
            login_url,
            timeout_secs,
            json,
        } => {
            use wa_core::browser::bootstrap::{
                BootstrapConfig, BootstrapResult, InteractiveBootstrap,
            };

            let config = BrowserConfig {
                headless: false, // Bootstrap always visible
                ..Default::default()
            };
            let mut ctx = BrowserContext::new(config, &layout.wa_dir);

            if let Err(e) = ctx.ensure_ready() {
                if json {
                    let resp = serde_json::json!({
                        "ok": false,
                        "error": format!("Browser initialization failed: {e}"),
                        "error_code": "E_BROWSER_NOT_READY",
                        "hint": "Check that Playwright is installed: npx playwright install chromium",
                    });
                    println!("{}", serde_json::to_string_pretty(&resp)?);
                } else {
                    eprintln!("Error: Browser initialization failed: {e}");
                    eprintln!("Hint: npx playwright install chromium");
                }
                std::process::exit(1);
            }

            let profile = ctx.profile(&service, &account);

            let mut bootstrap_config = BootstrapConfig::default();
            if let Some(url) = &login_url {
                bootstrap_config.login_url.clone_from(url);
            }
            bootstrap_config.timeout_ms = timeout_secs * 1000;

            if !json {
                println!("Starting interactive bootstrap for {service}/{account}");
                println!("  Login URL: {}", bootstrap_config.login_url);
                println!("  Timeout: {timeout_secs}s");
                println!();
                println!("A browser window will open. Complete login manually.");
                println!("Press Ctrl+C to cancel.");
                println!();
            }

            let bootstrap = InteractiveBootstrap::new(bootstrap_config);
            let result = bootstrap.execute(&ctx, &profile, login_url.as_deref());

            match &result {
                BootstrapResult::Success {
                    elapsed_ms,
                    profile_dir,
                } => {
                    if json {
                        let resp = serde_json::json!({
                            "ok": true,
                            "status": "success",
                            "service": service,
                            "account": account,
                            "elapsed_ms": elapsed_ms,
                            "profile_dir": profile_dir.display().to_string(),
                        });
                        println!("{}", serde_json::to_string_pretty(&resp)?);
                    } else {
                        println!(" Bootstrap complete: {service}/{account}");
                        println!("  Elapsed: {elapsed_ms}ms");
                        if verbose {
                            println!("  Profile: {}", profile_dir.display());
                        }
                        println!();
                        println!("You can now run: wa auth test {service} --account {account}");
                    }
                }
                BootstrapResult::Timeout { waited_ms } => {
                    if json {
                        let resp = serde_json::json!({
                            "ok": false,
                            "status": "timeout",
                            "service": service,
                            "account": account,
                            "waited_ms": waited_ms,
                            "error_code": "E_BOOTSTRAP_TIMEOUT",
                        });
                        println!("{}", serde_json::to_string_pretty(&resp)?);
                    } else {
                        eprintln!(
                            " Bootstrap timed out after {}s: {service}/{account}",
                            waited_ms / 1000
                        );
                        eprintln!(
                            "  Hint: Use --timeout-secs to increase (current: {timeout_secs}s)"
                        );
                    }
                    std::process::exit(1);
                }
                BootstrapResult::Cancelled { reason } => {
                    if json {
                        let resp = serde_json::json!({
                            "ok": false,
                            "status": "cancelled",
                            "service": service,
                            "account": account,
                            "reason": reason,
                        });
                        println!("{}", serde_json::to_string_pretty(&resp)?);
                    } else {
                        println!("Bootstrap cancelled: {reason}");
                    }
                }
                BootstrapResult::Failed { error } => {
                    if json {
                        let resp = serde_json::json!({
                            "ok": false,
                            "status": "failed",
                            "service": service,
                            "account": account,
                            "error": error,
                            "error_code": "E_BOOTSTRAP_FAILED",
                        });
                        println!("{}", serde_json::to_string_pretty(&resp)?);
                    } else {
                        eprintln!(" Bootstrap failed: {service}/{account}");
                        eprintln!("  Error: {error}");
                    }
                    std::process::exit(1);
                }
            }
        }
    }

    Ok(())
}

#[cfg(feature = "browser")]
fn build_profile_status(profile: &wa_core::browser::BrowserProfile) -> AuthProfileStatus {
    let metadata = profile.read_metadata().ok().flatten();
    AuthProfileStatus {
        service: profile.service.clone(),
        account: profile.account.clone(),
        profile_exists: profile.exists(),
        has_storage_state: profile.has_storage_state(),
        bootstrapped_at: metadata.as_ref().and_then(|m| m.bootstrapped_at.clone()),
        bootstrap_method: metadata.as_ref().and_then(|m| {
            m.bootstrap_method
                .as_ref()
                .map(|b| format!("{b:?}").to_lowercase())
        }),
        last_used_at: metadata.as_ref().and_then(|m| m.last_used_at.clone()),
        automated_use_count: metadata.map(|m| m.automated_use_count),
    }
}

#[cfg(not(feature = "browser"))]
async fn handle_auth_command(
    _command: AuthCommands,
    _layout: &wa_core::config::WorkspaceLayout,
    _verbose: bool,
) -> anyhow::Result<()> {
    eprintln!("Error: Browser feature not enabled.");
    eprintln!("Rebuild with: cargo build -p wa --features browser");
    std::process::exit(1);
}

fn prompt_confirm(prompt: &str) -> anyhow::Result<bool> {
    use std::io::{self, Write};

    print!("{prompt}");
    io::stdout().flush()?;

    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    let value = input.trim().to_ascii_lowercase();
    Ok(matches!(value.as_str(), "y" | "yes"))
}

/// Generate default config TOML with comments
fn generate_default_config_toml() -> String {
    r#"# wa configuration file
# See: https://github.com/your-org/wezterm-automata for documentation

[general]
# Log level: trace, debug, info, warn, error
log_level = "info"
# Log format: pretty (human) or json (machine)
log_format = "pretty"
# Optional log file path
# log_file = "~/.wa/wa.log"

[ingest]
# Base poll interval in milliseconds
poll_interval_ms = 200
# Minimum poll interval (adaptive polling lower bound)
min_poll_interval_ms = 50
# Maximum concurrent pane captures
max_concurrent_captures = 10
# Enable gap detection
gap_detection = true

[storage]
# Database file name (relative to workspace .wa/ directory)
db_path = "wa.db"
# Retention period in days (0 = unlimited)
retention_days = 30
# Maximum database size in MB (0 = unlimited)
retention_max_mb = 1000

[patterns]
# Enabled pattern packs
enabled_packs = ["builtin:core"]

[workflows]
# Enabled workflows (by name)
enabled = ["handle_compaction", "handle_usage_limits"]
# Maximum concurrent workflows
max_concurrent = 3

[safety]
# Require prompt to be active for send operations
require_prompt_active = true
# Block sends during alt-screen
block_alt_screen = true
# Block sends when there's a recent capture gap
block_recent_gap = true
"#
    .to_string()
}

/// Validate config and return warnings (non-fatal issues)
fn validate_config_warnings(config: &wa_core::config::Config) -> Vec<String> {
    let mut warnings = Vec::new();

    if config.ingest.poll_interval_ms < 50 {
        warnings.push(format!(
            "poll_interval_ms ({}) is very low; may cause high CPU usage",
            config.ingest.poll_interval_ms
        ));
    }

    if config.storage.retention_days == 0 && config.storage.retention_max_mb == 0 {
        warnings.push(
            "Both retention_days and retention_max_mb are 0; database may grow unbounded"
                .to_string(),
        );
    }

    if config.ingest.max_concurrent_captures > 50 {
        warnings.push(format!(
            "max_concurrent_captures ({}) is very high; may cause system instability",
            config.ingest.max_concurrent_captures
        ));
    }

    warnings
}

/// Set a value in a TOML document using dot-notation path
fn set_toml_value(
    doc: &mut toml_edit::DocumentMut,
    path: &[&str],
    value: &str,
) -> anyhow::Result<()> {
    if path.is_empty() {
        anyhow::bail!("Empty path");
    }

    // Navigate to the parent table
    let mut current: &mut toml_edit::Item = doc.as_item_mut();
    for (i, part) in path.iter().enumerate() {
        if i == path.len() - 1 {
            // Last element - set the value
            if let Some(table) = current.as_table_mut() {
                // Try to parse the value as appropriate type
                let toml_value = parse_toml_value(value);
                table[*part] = toml_value;
            } else {
                anyhow::bail!("Cannot set value: parent is not a table");
            }
        } else {
            // Intermediate element - navigate or create table
            if let Some(table) = current.as_table_mut() {
                if !table.contains_key(part) {
                    table[*part] = toml_edit::Item::Table(toml_edit::Table::new());
                }
                current = &mut table[*part];
            } else {
                anyhow::bail!("Cannot navigate: {} is not a table", path[..=i].join("."));
            }
        }
    }

    Ok(())
}

/// Recommended minimum scrollback lines for wa to function reliably
const RECOMMENDED_SCROLLBACK_LINES: u64 = 50_000;

/// Check WezTerm scrollback configuration
///
/// Returns (scrollback_lines, config_path) if found, or an error message.
fn check_wezterm_scrollback() -> Result<(u64, std::path::PathBuf), String> {
    // Check common WezTerm config locations
    let config_paths: Vec<std::path::PathBuf> = vec![
        dirs::config_dir()
            .map(|p| p.join("wezterm/wezterm.lua"))
            .unwrap_or_default(),
        dirs::home_dir()
            .map(|p| p.join(".wezterm.lua"))
            .unwrap_or_default(),
        dirs::home_dir()
            .map(|p| p.join(".config/wezterm/wezterm.lua"))
            .unwrap_or_default(),
    ];

    for config_path in config_paths {
        if config_path.exists() {
            match std::fs::read_to_string(&config_path) {
                Ok(content) => {
                    // Parse scrollback_lines from Lua config
                    // Patterns: config.scrollback_lines = N or scrollback_lines = N
                    for line in content.lines() {
                        let line = line.trim();
                        // Skip comments
                        if line.starts_with("--") {
                            continue;
                        }
                        // Match: config.scrollback_lines = 50000 or scrollback_lines = 50000
                        if line.contains("scrollback_lines") && line.contains('=') {
                            // Extract the number after '='
                            if let Some(value_part) = line.split('=').nth(1) {
                                let value_str = value_part.trim().trim_end_matches(',');
                                if let Ok(lines) = value_str.parse::<u64>() {
                                    return Ok((lines, config_path));
                                }
                            }
                        }
                    }
                    return Err(format!(
                        "scrollback_lines not set in {}",
                        config_path.display()
                    ));
                }
                Err(e) => {
                    return Err(format!("Failed to read {}: {}", config_path.display(), e));
                }
            }
        }
    }

    Err(
        "No WezTerm config file found (~/.config/wezterm/wezterm.lua or ~/.wezterm.lua)"
            .to_string(),
    )
}

fn format_backup_hint(path: &Path) -> String {
    let filename = path.file_name().unwrap_or_default().to_string_lossy();
    let backup_name = format!("{filename}.bak.<timestamp>");
    path.with_file_name(backup_name).display().to_string()
}

async fn run_guided_setup(apply: bool, dry_run: bool, verbose: u8) -> anyhow::Result<()> {
    use wa_core::environment::DetectedEnvironment;
    use wa_core::setup::{self, SetupWizard, ShellType, WizardChoice, default_config_save_path};

    let apply_changes = apply && !dry_run;

    println!("wa setup - Guided setup\n");
    if dry_run {
        println!("(dry run) No changes will be made.\n");
    } else if apply_changes {
        println!("Applying non-destructive changes where needed.\n");
    } else {
        println!("Run with --apply to make changes automatically.\n");
    }

    // ---- Phase 1: Environment detection ----
    println!("Detecting your setup...\n");
    let env = DetectedEnvironment::detect(None).await;
    let wizard = SetupWizard::new(env);
    let steps = wizard.detect();

    for step in &steps {
        if step.ok {
            println!("   {}: {}", step.label, step.detail);
        } else {
            println!("   {}: {}", step.label, step.detail);
        }
    }

    // ---- Phase 1b: Scrollback check (not part of wizard but useful) ----
    match check_wezterm_scrollback() {
        Ok((lines, path)) => {
            if verbose > 0 {
                println!("  WezTerm config: {}", path.display());
            }
            if lines >= RECOMMENDED_SCROLLBACK_LINES {
                println!("   scrollback_lines = {} (ok)", lines);
            } else {
                println!(
                    "   scrollback_lines = {} (recommended  {})",
                    lines, RECOMMENDED_SCROLLBACK_LINES
                );
            }
        }
        Err(err) => {
            if verbose > 0 {
                println!("   scrollback check: {err}");
            }
        }
    }

    // ---- Phase 2: Recommended configuration ----
    let auto = wizard.auto_config();
    println!("\nRecommended configuration:\n");
    println!("  Poll interval:    {}ms", auto.poll_interval_ms);
    println!("  Min poll:         {}ms", auto.min_poll_interval_ms);
    println!(
        "  Concurrency:      {} captures",
        auto.max_concurrent_captures
    );
    println!("  Pattern packs:    {}", auto.pattern_packs.join(", "));
    println!(
        "  Safety mode:      {}",
        if auto.strict_safety {
            "strict"
        } else {
            "standard"
        }
    );
    println!(
        "  Rate limit:       {}/min per pane",
        auto.rate_limit_per_pane
    );

    if !auto.recommendations.is_empty() {
        println!("\n  Reasons:");
        for rec in &auto.recommendations {
            println!("    {} = {} ({})", rec.key, rec.value, rec.reason);
        }
    }

    // ---- Phase 3: WezTerm patching ----
    match setup::locate_wezterm_config() {
        Ok(path) => {
            if verbose > 0 {
                println!("\n  WezTerm config: {}", path.display());
            }
            match std::fs::read_to_string(&path) {
                Ok(content) => {
                    if setup::has_wa_block(&content) {
                        println!("\n wezterm.lua already patched (wa block present)");
                    } else if apply_changes {
                        let result = setup::patch_wezterm_config_at(&path)?;
                        println!("\n {}", result.message);
                        if let Some(backup) = result.backup_path {
                            println!("  Backup: {}", backup.display());
                        }
                    } else {
                        println!("\n wezterm.lua missing wa block: {}", path.display());
                        println!(
                            "  Would patch and create backup: {}",
                            format_backup_hint(&path)
                        );
                        println!("  Run: wa setup patch");
                    }
                }
                Err(err) => {
                    println!("\n Failed to read {}: {}", path.display(), err);
                }
            }
        }
        Err(err) => {
            println!("\n WezTerm config not found: {err}");
            println!("  Create ~/.config/wezterm/wezterm.lua then run: wa setup patch");
        }
    }

    // ---- Phase 4: Shell OSC 133 ----
    match ShellType::detect() {
        Some(shell_type) => match setup::locate_shell_rc(shell_type) {
            Ok(rc_path) => {
                if verbose > 0 {
                    println!("  Shell rc: {}", rc_path.display());
                }
                let content = if rc_path.exists() {
                    std::fs::read_to_string(&rc_path).unwrap_or_default()
                } else {
                    String::new()
                };
                if setup::has_shell_wa_block(&content) {
                    println!(" shell rc already patched ({})", shell_type.name());
                } else if apply_changes {
                    let result = setup::patch_shell_rc_at(&rc_path, shell_type)?;
                    println!(" {}", result.message);
                    if let Some(backup) = result.backup_path {
                        println!("  Backup: {}", backup.display());
                    }
                } else {
                    println!(" shell rc missing OSC 133 markers ({})", shell_type.name());
                    println!("  Run: wa setup shell");
                }
            }
            Err(err) => {
                println!(" Shell rc not found: {err}");
            }
        },
        None => {
            println!(" Could not detect shell from $SHELL (skip OSC 133 setup)");
        }
    }

    // ---- Phase 5: SSH hosts (optional) ----
    match setup::locate_ssh_config() {
        Ok(path) => match setup::load_ssh_hosts(&path) {
            Ok(hosts) => {
                println!(
                    " SSH config found: {} ({} host(s))",
                    path.display(),
                    hosts.len()
                );
            }
            Err(err) => {
                println!(" Failed to parse SSH config: {err}");
            }
        },
        Err(_) => {
            println!(" No SSH config detected (optional).");
        }
    }

    // ---- Phase 6: Save config ----
    if apply_changes {
        let choice = WizardChoice::Accept;
        let save_path = default_config_save_path();
        let result = wizard.finish(choice, false, save_path.as_deref())?;

        if let Some(ref path) = result.config_path {
            println!("\n Configuration saved to: {}", path.display());
        }
    } else if !dry_run {
        if let Some(save_path) = default_config_save_path() {
            println!(
                "\nRun with --apply to save configuration to: {}",
                save_path.display()
            );
        }
    }

    println!("\nNext steps:");
    println!("  wa daemon start");
    println!("  wa status");
    println!("  wa robot state");

    Ok(())
}

/// Generate a systemd unit for the WezTerm mux server using the resolved binary path.
fn remote_mux_service_unit(mux_path: &str) -> String {
    format!(
        r"[Unit]
Description=WezTerm Mux Server
After=network.target

[Service]
Type=simple
ExecStart={mux_path} --daemonize=false
Restart=on-failure
RestartSec=2

[Install]
WantedBy=default.target
"
    )
}

struct RemoteCommandOutput {
    status: std::process::ExitStatus,
    stdout: String,
    stderr: String,
    duration_ms: u128,
}

struct RemoteSetupOptions<'a> {
    apply: bool,
    dry_run: bool,
    yes: bool,
    install_wa: bool,
    wa_path: Option<&'a Path>,
    wa_version: Option<&'a str>,
    timeout_secs: u64,
    verbose: u8,
}

fn run_remote_command(
    host: &str,
    command: &str,
    timeout: std::time::Duration,
) -> anyhow::Result<RemoteCommandOutput> {
    use std::process::{Command, Stdio};
    use std::thread::sleep;

    let start = std::time::Instant::now();
    let mut child = Command::new("ssh")
        .arg("-o")
        .arg("BatchMode=yes")
        .arg("-o")
        .arg(format!("ConnectTimeout={}", timeout.as_secs()))
        .arg(host)
        .arg(command)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()?;

    loop {
        if let Some(_status) = child.try_wait()? {
            break;
        }
        if start.elapsed() > timeout {
            let _ = child.kill();
            anyhow::bail!("timeout after {}s", timeout.as_secs());
        }
        sleep(std::time::Duration::from_millis(100));
    }

    let output = child.wait_with_output()?;
    Ok(RemoteCommandOutput {
        status: output.status,
        stdout: String::from_utf8_lossy(&output.stdout).to_string(),
        stderr: String::from_utf8_lossy(&output.stderr).to_string(),
        duration_ms: start.elapsed().as_millis(),
    })
}

fn print_remote_output(redactor: &wa_core::policy::Redactor, label: &str, text: &str, verbose: u8) {
    if verbose == 0 {
        return;
    }
    let trimmed = text.trim();
    if trimmed.is_empty() {
        return;
    }
    let redacted = redactor.redact(trimmed);
    println!("  {label}: {redacted}");
}

fn run_remote_step<F>(
    name: &str,
    host: &str,
    command: &str,
    timeout: std::time::Duration,
    runner: &F,
    redactor: &wa_core::policy::Redactor,
    verbose: u8,
    require_success: bool,
) -> anyhow::Result<RemoteCommandOutput>
where
    F: Fn(&str, &str, std::time::Duration) -> anyhow::Result<RemoteCommandOutput>,
{
    if verbose > 0 {
        let redacted_cmd = redactor.redact(command);
        println!(" {name}");
        println!("  cmd: {redacted_cmd}");
    } else {
        println!(" {name}");
    }

    let output = runner(host, command, timeout)?;
    if require_success && !output.status.success() {
        print_remote_output(redactor, "stdout", &output.stdout, 1);
        print_remote_output(redactor, "stderr", &output.stderr, 1);
        anyhow::bail!(
            "{} failed (exit {:?})",
            name,
            output.status.code().unwrap_or(-1)
        );
    }

    print_remote_output(redactor, "stdout", &output.stdout, verbose);
    print_remote_output(redactor, "stderr", &output.stderr, verbose);
    println!("   done in {} ms", output.duration_ms);
    Ok(output)
}

fn run_remote_setup(host: &str, options: &RemoteSetupOptions<'_>) -> anyhow::Result<()> {
    run_remote_setup_with_runner(host, options, &run_remote_command)
}

fn run_remote_setup_with_runner<F>(
    host: &str,
    options: &RemoteSetupOptions<'_>,
    runner: &F,
) -> anyhow::Result<()>
where
    F: Fn(&str, &str, std::time::Duration) -> anyhow::Result<RemoteCommandOutput>,
{
    use std::io::Write;
    use wa_core::policy::Redactor;

    let timeout = std::time::Duration::from_secs(options.timeout_secs.max(5));
    let apply_changes = options.apply && !options.dry_run;
    let redactor = Redactor::new();

    println!("wa setup remote - Remote Host Setup for '{host}'\n");
    if options.dry_run || !apply_changes {
        println!("(dry run) No changes will be made.\n");
    } else {
        println!("Applying non-destructive changes.\n");
    }

    if apply_changes && !options.yes {
        println!("This will run remote commands on {host}.");
        print!("Proceed? [y/N]: ");
        std::io::stdout().flush().ok();
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).ok();
        let confirmed = matches!(input.trim().to_lowercase().as_str(), "y" | "yes");
        if !confirmed {
            println!("Aborted.");
            return Ok(());
        }
    }

    // Step 1: Connectivity check
    run_remote_step(
        "Check SSH connectivity",
        host,
        "true",
        timeout,
        runner,
        &redactor,
        options.verbose,
        true,
    )?;

    // Step 2: Detect package manager
    let pkg_output = run_remote_step(
        "Detect package manager",
        host,
        "command -v apt-get || command -v dnf || command -v yum || command -v pacman || true",
        timeout,
        runner,
        &redactor,
        options.verbose,
        false,
    )?;
    let pkg_manager = pkg_output
        .stdout
        .lines()
        .next()
        .map(|line| line.trim().to_string())
        .filter(|line| !line.is_empty());

    // Step 3: Detect WezTerm
    let wezterm_output = run_remote_step(
        "Detect WezTerm",
        host,
        "command -v wezterm || true",
        timeout,
        runner,
        &redactor,
        options.verbose,
        false,
    )?;
    let wezterm_installed = !wezterm_output.stdout.trim().is_empty();
    if wezterm_installed {
        let version_output = run_remote_step(
            "WezTerm version",
            host,
            "wezterm --version || true",
            timeout,
            runner,
            &redactor,
            options.verbose,
            false,
        )?;
        let remote_version = version_output.stdout.trim().to_string();
        if !remote_version.is_empty() {
            println!("  Remote version: {remote_version}");
            // Compare with local version to warn about mismatches
            if let Ok(local_out) = std::process::Command::new(wezterm_binary())
                .arg("--version")
                .output()
            {
                let local_version = String::from_utf8_lossy(&local_out.stdout)
                    .trim()
                    .to_string();
                if !local_version.is_empty() {
                    if local_version != remote_version {
                        println!(
                            "   Version mismatch: local={local_version}, remote={remote_version}"
                        );
                        println!("    WezTerm multiplexing works best with matching versions.");
                    } else {
                        println!("   Local and remote versions match");
                    }
                }
            }
        }
    }

    if !wezterm_installed {
        match pkg_manager.as_deref() {
            Some(path) if path.contains("apt-get") => {
                if apply_changes {
                    // Set up WezTerm apt repository (not in default distro repos)
                    run_remote_step(
                        "Add WezTerm apt repo",
                        host,
                        "curl -fsSL https://apt.fury.io/wez/gpg.key | sudo gpg --yes --dearmor -o /usr/share/keyrings/wezterm-fury.gpg && \
                         echo 'deb [signed-by=/usr/share/keyrings/wezterm-fury.gpg] https://apt.fury.io/wez/ * *' | sudo tee /etc/apt/sources.list.d/wezterm.list >/dev/null",
                        timeout,
                        runner,
                        &redactor,
                        options.verbose,
                        true,
                    )?;
                    run_remote_step(
                        "Install WezTerm (apt)",
                        host,
                        "sudo apt-get update && sudo apt-get install -y wezterm",
                        timeout,
                        runner,
                        &redactor,
                        options.verbose,
                        true,
                    )?;
                } else {
                    println!(" Would add WezTerm apt repository (apt.fury.io/wez)");
                    println!(" Would install WezTerm via apt");
                }
            }
            Some(path) if path.contains("dnf") => {
                if apply_changes {
                    run_remote_step(
                        "Add WezTerm COPR repo",
                        host,
                        "sudo dnf copr enable -y wezfurlong/wezterm-nightly 2>/dev/null || true",
                        timeout,
                        runner,
                        &redactor,
                        options.verbose,
                        true,
                    )?;
                    run_remote_step(
                        "Install WezTerm (dnf)",
                        host,
                        "sudo dnf install -y wezterm",
                        timeout,
                        runner,
                        &redactor,
                        options.verbose,
                        true,
                    )?;
                } else {
                    println!(" Would add WezTerm COPR repo");
                    println!(" Would install WezTerm via dnf");
                }
            }
            Some(path) if path.contains("yum") => {
                if apply_changes {
                    run_remote_step(
                        "Install WezTerm (yum)",
                        host,
                        "sudo yum install -y wezterm",
                        timeout,
                        runner,
                        &redactor,
                        options.verbose,
                        true,
                    )?;
                } else {
                    println!(" Would install WezTerm via yum");
                    println!("  cmd: sudo yum install -y wezterm");
                }
            }
            Some(path) if path.contains("pacman") => {
                if apply_changes {
                    run_remote_step(
                        "Install WezTerm (pacman)",
                        host,
                        "sudo pacman -Sy --noconfirm wezterm",
                        timeout,
                        runner,
                        &redactor,
                        options.verbose,
                        true,
                    )?;
                } else {
                    println!(" Would install WezTerm via pacman");
                    println!("  cmd: sudo pacman -Sy --noconfirm wezterm");
                }
            }
            _ => {
                println!(" No supported package manager detected; install WezTerm manually.");
            }
        }
    }

    // Step 4: Resolve mux-server path and install user service unit
    let mux_path_output = run_remote_step(
        "Locate wezterm-mux-server",
        host,
        "command -v wezterm-mux-server || which wezterm-mux-server 2>/dev/null || echo /usr/bin/wezterm-mux-server",
        timeout,
        runner,
        &redactor,
        options.verbose,
        false,
    )?;
    let mux_server_path = mux_path_output
        .stdout
        .trim()
        .lines()
        .next()
        .unwrap_or("/usr/bin/wezterm-mux-server")
        .trim()
        .to_string();
    let mux_unit = remote_mux_service_unit(&mux_server_path);

    let service_path = "~/.config/systemd/user/wezterm-mux-server.service";
    let check_service_cmd = format!("cat {service_path} 2>/dev/null || true");
    let service_output = run_remote_step(
        "Check mux service unit",
        host,
        &check_service_cmd,
        timeout,
        runner,
        &redactor,
        options.verbose,
        false,
    )?;
    let existing_service = service_output.stdout.trim();
    let expected_service = mux_unit.trim();
    if existing_service == expected_service {
        println!(" mux service unit already up to date");
    } else if existing_service.is_empty() {
        if apply_changes {
            let install_cmd = format!(
                "mkdir -p ~/.config/systemd/user && cat > {service_path} <<'EOF'\n{mux_unit}EOF"
            );
            run_remote_step(
                "Install mux service unit",
                host,
                &install_cmd,
                timeout,
                runner,
                &redactor,
                options.verbose,
                true,
            )?;
        } else {
            println!(" Would install mux service unit at {service_path}");
        }
    } else {
        println!(" mux service unit exists but differs; leaving unchanged.");
        if apply_changes {
            println!("  Remove or update {service_path} manually if desired.");
        }
    }

    if apply_changes {
        run_remote_step(
            "systemctl --user daemon-reload",
            host,
            "systemctl --user daemon-reload",
            timeout,
            runner,
            &redactor,
            options.verbose,
            true,
        )?;
        run_remote_step(
            "Enable mux service",
            host,
            "systemctl --user enable --now wezterm-mux-server",
            timeout,
            runner,
            &redactor,
            options.verbose,
            true,
        )?;
    } else {
        println!(" Would run: systemctl --user daemon-reload");
        println!(" Would run: systemctl --user enable --now wezterm-mux-server");
    }

    let status_output = run_remote_step(
        "Check mux service status",
        host,
        "systemctl --user is-active wezterm-mux-server || true",
        timeout,
        runner,
        &redactor,
        options.verbose,
        false,
    )?;
    let status = status_output.stdout.trim();
    if status == "active" {
        println!(" mux service is active");
    } else if !status.is_empty() {
        println!(" mux service status: {status}");
    }

    // Step 5: Enable linger
    let linger_output = run_remote_step(
        "Check linger",
        host,
        "loginctl show-user $USER -p Linger || true",
        timeout,
        runner,
        &redactor,
        options.verbose,
        false,
    )?;
    let linger_enabled = linger_output
        .stdout
        .lines()
        .any(|line| line.trim_end() == "Linger=yes");
    if linger_enabled {
        println!(" linger already enabled");
    } else if apply_changes {
        run_remote_step(
            "Enable linger",
            host,
            "sudo loginctl enable-linger $USER",
            timeout,
            runner,
            &redactor,
            options.verbose,
            true,
        )?;
    } else {
        println!(" Would run: sudo loginctl enable-linger $USER");
    }

    // Step 6: Optional wa install
    if options.install_wa {
        if apply_changes {
            run_remote_step(
                "Ensure ~/.local/bin exists",
                host,
                "mkdir -p ~/.local/bin",
                timeout,
                runner,
                &redactor,
                options.verbose,
                true,
            )?;

            if let Some(path) = options.wa_path {
                if !path.exists() {
                    anyhow::bail!("wa_path does not exist: {}", path.display());
                }
                let scp_status = std::process::Command::new("scp")
                    .arg(path)
                    .arg(format!("{host}:~/.local/bin/wa"))
                    .status()?;
                if !scp_status.success() {
                    anyhow::bail!("scp failed with status {:?}", scp_status.code());
                }
                run_remote_step(
                    "chmod +x ~/.local/bin/wa",
                    host,
                    "chmod +x ~/.local/bin/wa",
                    timeout,
                    runner,
                    &redactor,
                    options.verbose,
                    true,
                )?;
            } else if let Some(version) = options.wa_version {
                let install_cmd = if version.eq_ignore_ascii_case("git") {
                    "cargo install --git https://github.com/Dicklesworthstone/wezterm_automata.git wa"
                        .to_string()
                } else {
                    format!(
                        "cargo install --git https://github.com/Dicklesworthstone/wezterm_automata.git --tag {} wa",
                        version
                    )
                };
                run_remote_step(
                    "Install wa via cargo",
                    host,
                    &install_cmd,
                    timeout,
                    runner,
                    &redactor,
                    options.verbose,
                    true,
                )?;
            } else {
                println!(" --install-wa set but no --wa-path or --wa-version provided.");
            }
        } else {
            println!(" Would install wa on remote host");
            if let Some(path) = options.wa_path {
                println!("  Would scp {}", path.display());
            } else if let Some(version) = options.wa_version {
                println!("  Would cargo install wa ({version})");
            } else {
                println!("  Provide --wa-path or --wa-version to install wa");
            }
        }
    }

    println!("\nRemote setup summary:");
    println!("  Host: {host}");
    println!(
        "  Mode: {}",
        if apply_changes { "apply" } else { "dry-run" }
    );
    println!("  Next: verify with `ssh {host} 'systemctl --user status wezterm-mux-server'`");

    Ok(())
}

/// Diagnostic result for a single check
struct DiagnosticCheck {
    name: &'static str,
    status: DiagnosticStatus,
    detail: Option<String>,
    recommendation: Option<String>,
}

#[derive(Debug, PartialEq)]
enum DiagnosticStatus {
    Ok,
    Warning,
    Error,
}

impl DiagnosticCheck {
    fn ok(name: &'static str) -> Self {
        Self {
            name,
            status: DiagnosticStatus::Ok,
            detail: None,
            recommendation: None,
        }
    }

    fn ok_with_detail(name: &'static str, detail: impl Into<String>) -> Self {
        Self {
            name,
            status: DiagnosticStatus::Ok,
            detail: Some(detail.into()),
            recommendation: None,
        }
    }

    fn warning(
        name: &'static str,
        detail: impl Into<String>,
        recommendation: impl Into<String>,
    ) -> Self {
        Self {
            name,
            status: DiagnosticStatus::Warning,
            detail: Some(detail.into()),
            recommendation: Some(recommendation.into()),
        }
    }

    fn error(
        name: &'static str,
        detail: impl Into<String>,
        recommendation: impl Into<String>,
    ) -> Self {
        Self {
            name,
            status: DiagnosticStatus::Error,
            detail: Some(detail.into()),
            recommendation: Some(recommendation.into()),
        }
    }

    fn print(&self) {
        let status_icon = match self.status {
            DiagnosticStatus::Ok => "[OK]",
            DiagnosticStatus::Warning => "[WARN]",
            DiagnosticStatus::Error => "[ERR]",
        };

        if let Some(detail) = &self.detail {
            println!("  {} {} - {}", status_icon, self.name, detail);
        } else {
            println!("  {} {}", status_icon, self.name);
        }

        if let Some(rec) = &self.recommendation {
            println!("        {rec}");
        }
    }

    fn to_json_value(&self) -> serde_json::Value {
        let mut obj = serde_json::json!({
            "name": self.name,
            "status": self.status.as_str(),
        });
        if let Some(detail) = &self.detail {
            obj["detail"] = serde_json::json!(detail);
        }
        if let Some(rec) = &self.recommendation {
            obj["recommendation"] = serde_json::json!(rec);
        }
        obj
    }
}

impl DiagnosticStatus {
    fn as_str(&self) -> &'static str {
        match self {
            Self::Ok => "ok",
            Self::Warning => "warning",
            Self::Error => "error",
        }
    }
}

fn is_loopback_bind_addr(bind_addr: &str) -> bool {
    if let Ok(addr) = bind_addr.parse::<std::net::SocketAddr>() {
        return addr.ip().is_loopback();
    }

    let host = bind_addr.split(':').next().unwrap_or(bind_addr).trim();
    host.eq_ignore_ascii_case("localhost") || host.starts_with("127.")
}

fn distributed_security_check(config: &wa_core::config::Config) -> DiagnosticCheck {
    let dist = &config.distributed;
    if !dist.enabled {
        return DiagnosticCheck::ok_with_detail("distributed security", "disabled");
    }

    let auth_label = match dist.auth_mode {
        wa_core::config::DistributedAuthMode::Token => "token",
        wa_core::config::DistributedAuthMode::Mtls => "mtls",
        wa_core::config::DistributedAuthMode::TokenAndMtls => "token+mtls",
    };

    let (token_label, token_resolve_err) = if dist.auth_mode.requires_token() {
        let kind_label = match wa_core::distributed::configured_token_source_kind(dist) {
            Some(wa_core::distributed::DistributedTokenSourceKind::Inline) => "inline",
            Some(wa_core::distributed::DistributedTokenSourceKind::Env) => "env",
            Some(wa_core::distributed::DistributedTokenSourceKind::File) => "file",
            None => "missing",
        };

        match wa_core::distributed::resolve_expected_token(dist) {
            Ok(Some(_)) => (format!("{kind_label}:ok"), None),
            Ok(None) => (format!("{kind_label}:n/a"), None),
            Err(e) => (format!("{kind_label}:err"), Some(e.to_string())),
        }
    } else {
        ("n/a".to_string(), None)
    };
    let tls_label = if dist.tls.enabled {
        format!("on (min {})", dist.tls.min_tls_version)
    } else {
        "off".to_string()
    };
    let mut detail = format!(
        "bind={}, auth={}, tls={}, token={}, allowlist={}",
        dist.bind_addr,
        auth_label,
        tls_label,
        token_label,
        dist.allow_agent_ids.len()
    );
    if let Some(err) = &token_resolve_err {
        detail.push_str(&format!(", token_err={err}"));
    }

    let mut status = DiagnosticStatus::Ok;
    let mut recommendation = None;

    if dist.auth_mode.requires_token() {
        if token_label.starts_with("missing") {
            status = DiagnosticStatus::Error;
            recommendation =
                Some("Set distributed.token_env or distributed.token_path".to_string());
        } else if token_resolve_err.is_some() {
            status = DiagnosticStatus::Error;
            recommendation = Some("Fix distributed token source (env/file)".to_string());
        } else if token_label.starts_with("inline") && status != DiagnosticStatus::Error {
            status = DiagnosticStatus::Warning;
            recommendation.get_or_insert_with(|| {
                "Prefer distributed.token_path (file) for rotation; avoid inline tokens".to_string()
            });
        }
    }

    if dist.allow_insecure {
        if status != DiagnosticStatus::Error {
            status = DiagnosticStatus::Warning;
        }
        recommendation
            .get_or_insert_with(|| "Disable distributed.allow_insecure or enable TLS".to_string());
    }

    if dist.require_tls_for_non_loopback
        && !is_loopback_bind_addr(&dist.bind_addr)
        && !dist.tls.enabled
        && !dist.allow_insecure
    {
        status = DiagnosticStatus::Error;
        recommendation = Some("Enable distributed.tls or bind to loopback".to_string());
    }

    match status {
        DiagnosticStatus::Ok => DiagnosticCheck::ok_with_detail("distributed security", detail),
        DiagnosticStatus::Warning => DiagnosticCheck::warning(
            "distributed security",
            detail,
            recommendation.unwrap_or_else(|| "Review distributed config".to_string()),
        ),
        DiagnosticStatus::Error => DiagnosticCheck::error(
            "distributed security",
            detail,
            recommendation.unwrap_or_else(|| "Fix distributed configuration".to_string()),
        ),
    }
}

/// Resolve the wezterm binary, respecting `WA_WEZTERM_CLI` env var.
fn wezterm_binary() -> String {
    std::env::var("WA_WEZTERM_CLI").unwrap_or_else(|_| "wezterm".to_string())
}

/// Run a command with a timeout, returning an error if the process doesn't complete in time.
fn run_cmd_with_timeout(
    cmd: &mut std::process::Command,
    timeout: std::time::Duration,
) -> std::io::Result<std::process::Output> {
    let mut child = cmd
        .stdout(std::process::Stdio::piped())
        .stderr(std::process::Stdio::piped())
        .spawn()?;

    let start = std::time::Instant::now();
    loop {
        match child.try_wait()? {
            Some(_) => return child.wait_with_output(),
            None if start.elapsed() >= timeout => {
                let _ = child.kill();
                let _ = child.wait();
                return Err(std::io::Error::new(
                    std::io::ErrorKind::TimedOut,
                    "process timed out",
                ));
            }
            None => std::thread::sleep(std::time::Duration::from_millis(50)),
        }
    }
}

/// Run all diagnostic checks and return results
fn run_diagnostics(
    permission_warnings: &[wa_core::config::PermissionWarning],
    config: &wa_core::config::Config,
    layout: &wa_core::config::WorkspaceLayout,
) -> Vec<DiagnosticCheck> {
    let mut checks = Vec::new();

    // Check 1: wa-core loaded with version
    checks.push(DiagnosticCheck::ok_with_detail(
        "wa-core loaded",
        format!("v{}", env!("CARGO_PKG_VERSION")),
    ));

    // Check 2: Workspace resolution
    checks.push(DiagnosticCheck::ok_with_detail(
        "workspace root",
        layout.root.display().to_string(),
    ));

    // Check 3: .wa directory
    if layout.wa_dir.exists() {
        checks.push(DiagnosticCheck::ok_with_detail(
            ".wa directory",
            layout.wa_dir.display().to_string(),
        ));
    } else {
        checks.push(DiagnosticCheck::warning(
            ".wa directory",
            format!("{} does not exist", layout.wa_dir.display()),
            "Will be created on first daemon start",
        ));
    }

    // Check 4: Database path and status
    if layout.db_path.exists() {
        // Try to open and check DB
        match rusqlite::Connection::open_with_flags(
            &layout.db_path,
            rusqlite::OpenFlags::SQLITE_OPEN_READ_ONLY,
        ) {
            Ok(conn) => {
                // Check schema version
                match conn.query_row("PRAGMA user_version", [], |row| row.get::<_, i32>(0)) {
                    Ok(version) => {
                        let target = wa_core::storage::SCHEMA_VERSION;
                        match version.cmp(&target) {
                            std::cmp::Ordering::Equal => {
                                // Check WAL mode
                                let wal_mode: String = conn
                                    .query_row("PRAGMA journal_mode", [], |row| row.get(0))
                                    .unwrap_or_else(|_| "unknown".to_string());
                                checks.push(DiagnosticCheck::ok_with_detail(
                                    "database",
                                    format!(
                                        "schema v{}, journal={} ({})",
                                        version,
                                        wal_mode,
                                        layout.db_path.display()
                                    ),
                                ));
                            }
                            std::cmp::Ordering::Less => {
                                checks.push(DiagnosticCheck::warning(
                                    "database",
                                    format!("schema v{} (needs migration to v{})", version, target),
                                    "Run 'wa daemon start' to auto-migrate",
                                ));
                            }
                            std::cmp::Ordering::Greater => {
                                checks.push(DiagnosticCheck::error(
                                    "database",
                                    format!(
                                        "schema v{} is newer than wa supports (v{})",
                                        version, target
                                    ),
                                    "Update wa to a newer version",
                                ));
                            }
                        }
                    }
                    Err(e) => {
                        checks.push(DiagnosticCheck::warning(
                            "database",
                            format!("could not read schema version: {}", e),
                            "Database may be corrupt or locked",
                        ));
                    }
                }
            }
            Err(e) => {
                checks.push(DiagnosticCheck::error(
                    "database",
                    format!("could not open: {}", e),
                    "Check file permissions or if another process has locked it",
                ));
            }
        }
    } else {
        checks.push(DiagnosticCheck::warning(
            "database",
            format!("{} does not exist", layout.db_path.display()),
            "Will be created on first daemon start",
        ));
    }

    // Check 5: Lock file (watcher status)
    if layout.lock_path.exists() {
        // Try to read lock file to see if daemon is running
        match std::fs::read_to_string(&layout.lock_path) {
            Ok(content) => {
                let pid = content.trim();
                // Check if process is actually running
                let is_running = std::process::Command::new("kill")
                    .args(["-0", pid])
                    .output()
                    .is_ok_and(|o| o.status.success());

                if is_running {
                    checks.push(DiagnosticCheck::ok_with_detail(
                        "daemon status",
                        format!("running (PID {})", pid),
                    ));
                } else {
                    checks.push(DiagnosticCheck::warning(
                        "daemon status",
                        format!("stale lock (PID {} not running)", pid),
                        format!("Remove lock: rm {}", layout.lock_path.display()),
                    ));
                }
            }
            Err(_) => {
                checks.push(DiagnosticCheck::warning(
                    "daemon status",
                    "lock file exists but unreadable",
                    format!("Check permissions: {}", layout.lock_path.display()),
                ));
            }
        }
    } else {
        checks.push(DiagnosticCheck::ok_with_detail(
            "daemon status",
            "not running",
        ));
    }

    // Check 6: Logs directory writability
    if layout.logs_dir.exists() {
        let test_file = layout.logs_dir.join(".wa_doctor_test");
        match std::fs::write(&test_file, "test") {
            Ok(()) => {
                let _ = std::fs::remove_file(&test_file);
                checks.push(DiagnosticCheck::ok_with_detail(
                    "logs directory",
                    layout.logs_dir.display().to_string(),
                ));
            }
            Err(e) => {
                checks.push(DiagnosticCheck::error(
                    "logs directory",
                    format!("not writable: {}", e),
                    format!("Check permissions: chmod 755 {}", layout.logs_dir.display()),
                ));
            }
        }
    } else {
        checks.push(DiagnosticCheck::warning(
            "logs directory",
            format!("{} does not exist", layout.logs_dir.display()),
            "Will be created on first daemon start",
        ));
    }

    // Check 7: Feature flags
    let features: Vec<&str> = [
        (cfg!(feature = "tui"), "tui"),
        (cfg!(feature = "browser"), "browser"),
        (cfg!(feature = "mcp"), "mcp"),
        (cfg!(feature = "web"), "web"),
        (cfg!(feature = "metrics"), "metrics"),
    ]
    .into_iter()
    .filter_map(|(enabled, name)| enabled.then_some(name))
    .collect();

    if features.is_empty() {
        checks.push(DiagnosticCheck::ok_with_detail(
            "features",
            "default (no optional features)",
        ));
    } else {
        checks.push(DiagnosticCheck::ok_with_detail(
            "features",
            features.join(", "),
        ));
    }

    // Check 8: Config source (without exposing secrets)
    let config_source = if config.general.log_level.is_empty() {
        "defaults".to_string()
    } else {
        format!("log_level={}", config.general.log_level)
    };
    checks.push(DiagnosticCheck::ok_with_detail("config", config_source));
    checks.push(distributed_security_check(config));

    // Check 2: WezTerm CLI available
    let wezterm_timeout = std::time::Duration::from_secs(5);
    #[cfg(feature = "vendored")]
    let mut local_wezterm_version: Option<wa_core::vendored::WeztermVersion> = None;
    match run_cmd_with_timeout(
        std::process::Command::new(wezterm_binary()).arg("--version"),
        wezterm_timeout,
    ) {
        Ok(output) if output.status.success() => {
            let version = String::from_utf8_lossy(&output.stdout);
            let version = version.trim();
            checks.push(DiagnosticCheck::ok_with_detail("WezTerm CLI", version));
            #[cfg(feature = "vendored")]
            {
                local_wezterm_version = Some(wa_core::vendored::WeztermVersion::parse(version));
            }
        }
        Ok(_) => {
            checks.push(DiagnosticCheck::error(
                "WezTerm CLI",
                "wezterm command failed",
                "Ensure WezTerm is installed and in PATH",
            ));
        }
        Err(e) if e.kind() == std::io::ErrorKind::TimedOut => {
            checks.push(DiagnosticCheck::error(
                "WezTerm CLI",
                "wezterm --version timed out",
                "WezTerm may be unresponsive; try restarting it",
            ));
        }
        Err(_) => {
            checks.push(DiagnosticCheck::error(
                "WezTerm CLI",
                "wezterm not found",
                "Install WezTerm from https://wezfurlong.org/wezterm/",
            ));
        }
    }

    // Check 2b: Vendored compatibility (only meaningful when vendored feature is enabled)
    #[cfg(feature = "vendored")]
    {
        let compat = wa_core::vendored::compatibility_report(local_wezterm_version.as_ref());
        if !compat.vendored_enabled {
            checks.push(DiagnosticCheck::ok_with_detail(
                "WezTerm vendored",
                "vendored feature not enabled",
            ));
        } else {
            match compat.status {
                wa_core::vendored::VendoredCompatibilityStatus::Matched => {
                    checks.push(DiagnosticCheck::ok_with_detail(
                        "WezTerm vendored",
                        compat.message,
                    ));
                }
                wa_core::vendored::VendoredCompatibilityStatus::Compatible => {
                    let recommendation = compat
                        .recommendation
                        .unwrap_or_else(|| "Review vendored compatibility".to_string());
                    checks.push(DiagnosticCheck::warning(
                        "WezTerm vendored",
                        compat.message,
                        recommendation,
                    ));
                }
                wa_core::vendored::VendoredCompatibilityStatus::Incompatible => {
                    let recommendation = compat
                        .recommendation
                        .unwrap_or_else(|| "Update WezTerm or rebuild wa".to_string());
                    checks.push(DiagnosticCheck::error(
                        "WezTerm vendored",
                        compat.message,
                        recommendation,
                    ));
                }
            }
        }
    }
    #[cfg(not(feature = "vendored"))]
    {
        checks.push(DiagnosticCheck::ok_with_detail(
            "WezTerm vendored",
            "vendored feature not enabled",
        ));
    }

    // Check 3: WezTerm scrollback configuration
    match check_wezterm_scrollback() {
        Ok((lines, path)) => {
            if lines >= RECOMMENDED_SCROLLBACK_LINES {
                checks.push(DiagnosticCheck::ok_with_detail(
                    "WezTerm scrollback",
                    format!("{} lines ({})", lines, path.display()),
                ));
            } else {
                checks.push(DiagnosticCheck::warning(
                    "WezTerm scrollback",
                    format!(
                        "{lines} lines (below {RECOMMENDED_SCROLLBACK_LINES} recommended)"
                    ),
                    format!(
                        "Add to wezterm.lua: config.scrollback_lines = {RECOMMENDED_SCROLLBACK_LINES}"
                    ),
                ));
            }
        }
        Err(msg) => {
            checks.push(DiagnosticCheck::warning(
                "WezTerm scrollback",
                msg,
                format!(
                    "Add to wezterm.lua: config.scrollback_lines = {RECOMMENDED_SCROLLBACK_LINES}"
                ),
            ));
        }
    }

    // Check 4: Filesystem permissions
    if permission_warnings.is_empty() {
        checks.push(DiagnosticCheck::ok("filesystem permissions"));
    } else {
        for warning in permission_warnings {
            checks.push(DiagnosticCheck::warning(
                "filesystem permissions",
                format!(
                    "{} permissions too open ({:o})",
                    warning.label, warning.actual_mode
                ),
                format!(
                    "chmod {:o} {}",
                    warning.expected_mode,
                    warning.path.display()
                ),
            ));
        }
    }

    // Check 5: WezTerm running and responding
    match run_cmd_with_timeout(
        std::process::Command::new(wezterm_binary()).args(["cli", "list", "--format", "json"]),
        wezterm_timeout,
    ) {
        Ok(output) if output.status.success() => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            match serde_json::from_str::<Vec<serde_json::Value>>(&stdout) {
                Ok(panes) => {
                    checks.push(DiagnosticCheck::ok_with_detail(
                        "WezTerm connection",
                        format!("{} pane(s) detected", panes.len()),
                    ));
                }
                Err(_) => {
                    checks.push(DiagnosticCheck::warning(
                        "WezTerm connection",
                        "Could not parse pane list",
                        "Check WezTerm version compatibility",
                    ));
                }
            }
        }
        Ok(output) => {
            let stderr = String::from_utf8_lossy(&output.stderr);
            checks.push(DiagnosticCheck::error(
                "WezTerm connection",
                format!("CLI failed: {}", stderr.trim()),
                "Ensure WezTerm GUI is running",
            ));
        }
        Err(e) if e.kind() == std::io::ErrorKind::TimedOut => {
            checks.push(DiagnosticCheck::error(
                "WezTerm connection",
                "wezterm cli list timed out",
                "WezTerm mux server may not be running; start the WezTerm GUI",
            ));
        }
        Err(e) => {
            checks.push(DiagnosticCheck::error(
                "WezTerm connection",
                format!("CLI error: {e}"),
                "Ensure WezTerm is installed and running",
            ));
        }
    }

    // Browser automation checks (when browser feature is enabled)
    #[cfg(feature = "browser")]
    {
        // Profile directory check only  no browser launch needed

        // Check: Playwright available
        match std::process::Command::new("npx")
            .args(["playwright", "--version"])
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::piped())
            .output()
        {
            Ok(output) if output.status.success() => {
                let version = String::from_utf8_lossy(&output.stdout);
                checks.push(DiagnosticCheck::ok_with_detail(
                    "Playwright",
                    format!("v{}", version.trim()),
                ));
            }
            Ok(_) => {
                checks.push(DiagnosticCheck::warning(
                    "Playwright",
                    "npx playwright returned non-zero",
                    "Install Playwright: npx playwright install chromium",
                ));
            }
            Err(_) => {
                checks.push(DiagnosticCheck::warning(
                    "Playwright",
                    "npx not found or playwright not installed",
                    "Install Node.js and Playwright: npm install -D playwright && npx playwright install chromium",
                ));
            }
        }

        // Check browser profiles for each service
        let data_dir = layout.wa_dir.join("browser_profiles");
        for service in &["openai", "anthropic", "google"] {
            let service_dir = data_dir.join(service);
            if service_dir.exists() {
                // Count account profiles
                let profile_count = std::fs::read_dir(&service_dir)
                    .map(|rd| {
                        rd.filter(|e| e.as_ref().is_ok_and(|e| e.path().is_dir()))
                            .count()
                    })
                    .unwrap_or(0);

                if profile_count > 0 {
                    // Check if any profile has been bootstrapped
                    let mut bootstrapped = 0u32;
                    if let Ok(entries) = std::fs::read_dir(&service_dir) {
                        for entry in entries.flatten() {
                            let meta_path = entry.path().join(".wa_profile.json");
                            if meta_path.exists() {
                                if let Ok(content) = std::fs::read_to_string(&meta_path) {
                                    if let Ok(meta) =
                                        serde_json::from_str::<serde_json::Value>(&content)
                                    {
                                        if meta
                                            .get("bootstrapped_at")
                                            .and_then(|v| v.as_str())
                                            .is_some()
                                        {
                                            bootstrapped += 1;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    let check_name: &'static str = match *service {
                        "openai" => "Browser: OpenAI",
                        "anthropic" => "Browser: Anthropic",
                        "google" => "Browser: Google",
                        _ => "Browser: unknown",
                    };

                    if bootstrapped > 0 {
                        checks.push(DiagnosticCheck::ok_with_detail(
                            check_name,
                            format!(
                                "{} profile(s), {} bootstrapped  Automated",
                                profile_count, bootstrapped
                            ),
                        ));
                    } else {
                        checks.push(DiagnosticCheck::warning(
                            check_name,
                            format!(
                                "{} profile(s), none bootstrapped  NeedsHuman",
                                profile_count
                            ),
                            "Run interactive bootstrap to authenticate",
                        ));
                    }
                } else {
                    let check_name: &'static str = match *service {
                        "openai" => "Browser: OpenAI",
                        "anthropic" => "Browser: Anthropic",
                        "google" => "Browser: Google",
                        _ => "Browser: unknown",
                    };
                    checks.push(DiagnosticCheck::ok_with_detail(
                        check_name,
                        "no profiles (not yet configured)",
                    ));
                }
            }
        }
    }

    checks
}

/// Parse a string value into appropriate TOML type
fn parse_toml_value(value: &str) -> toml_edit::Item {
    // Try integer
    if let Ok(n) = value.parse::<i64>() {
        return toml_edit::value(n);
    }

    // Try float
    if let Ok(f) = value.parse::<f64>() {
        return toml_edit::value(f);
    }

    // Try boolean
    match value.to_lowercase().as_str() {
        "true" => return toml_edit::value(true),
        "false" => return toml_edit::value(false),
        _ => {}
    }

    // Default to string
    toml_edit::value(value)
}

/// Format a duration in milliseconds as a short human-readable string.
fn format_duration_short(ms: u64) -> String {
    if ms < 1_000 {
        return format!("{ms}ms");
    }
    let total_secs = ms / 1_000;
    let hours = total_secs / 3600;
    let minutes = (total_secs % 3600) / 60;
    let seconds = total_secs % 60;
    if hours > 0 {
        format!("{hours}h{minutes:02}m{seconds:02}s")
    } else if minutes > 0 {
        format!("{minutes}m{seconds:02}s")
    } else {
        format!("{seconds}s")
    }
}

/// Format a byte size as a short human-readable string.
fn format_size_short(bytes: u64) -> String {
    if bytes < 1024 {
        return format!("{bytes}B");
    }
    let kb = bytes as f64 / 1024.0;
    if kb < 1024.0 {
        return format!("{kb:.0}KB");
    }
    let mb = kb / 1024.0;
    format!("{mb:.1}MB")
}

#[cfg(test)]
mod tests {
    use super::*;
    use wa_core::approval::hash_allow_once_code;
    use wa_core::storage::{ApprovalTokenRecord, PaneRecord, PreparedPlanRecord, StorageHandle};

    fn now_ms() -> i64 {
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map_or(0, |d| d.as_millis() as i64)
    }

    async fn setup_storage(label: &str) -> (StorageHandle, String) {
        let temp_dir = std::env::temp_dir();
        let unique = now_ms();
        let db_path = temp_dir.join(format!(
            "wa_robot_approve_{label}_{}_{}.db",
            std::process::id(),
            unique
        ));
        let db_path_str = db_path.to_string_lossy().to_string();
        let storage = StorageHandle::new(&db_path_str).await.unwrap();
        (storage, db_path_str)
    }

    async fn cleanup_storage(storage: StorageHandle, db_path: &str) {
        let _ = storage.shutdown().await;
        let _ = std::fs::remove_file(db_path);
        let _ = std::fs::remove_file(format!("{db_path}-wal"));
        let _ = std::fs::remove_file(format!("{db_path}-shm"));
    }

    fn unique_temp_dir(label: &str) -> std::path::PathBuf {
        let dir = std::env::temp_dir().join(format!(
            "wa_profile_test_{}_{}_{}",
            label,
            std::process::id(),
            now_ms()
        ));
        std::fs::create_dir_all(&dir).unwrap();
        dir
    }

    fn write_file(path: &std::path::Path, contents: &str) {
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent).unwrap();
        }
        std::fs::write(path, contents).unwrap();
    }

    #[test]
    fn merge_toml_documents_overlays_nested_tables() {
        let base = r#"
[general]
log_level = "info"
log_format = "pretty"

[storage]
retention_days = 30
"#;
        let overlay = r#"
[general]
log_level = "debug"
"#;
        let merged = merge_toml_documents(base, overlay).unwrap();
        assert!(merged.contains("log_level = \"debug\""));
        assert!(merged.contains("log_format = \"pretty\""));
        assert!(merged.contains("retention_days = 30"));
    }

    #[test]
    fn config_profile_create_updates_manifest() {
        let root = unique_temp_dir("create_manifest");
        let config_path = root.join("wa.toml");
        write_file(&config_path, "[general]\nlog_level = \"info\"\n");

        handle_config_profile_command(
            ConfigProfileCommands::Create {
                name: "incident".to_string(),
                from: "current".to_string(),
                description: Some("Incident response".to_string()),
                force: false,
                path: Some(config_path.display().to_string()),
            },
            None,
        )
        .unwrap();

        let profiles_dir = wa_core::config_profiles::resolve_profiles_dir(Some(&config_path));
        let manifest = wa_core::config_profiles::load_manifest(&profiles_dir)
            .unwrap()
            .unwrap();
        assert!(
            manifest
                .profiles
                .iter()
                .any(|entry| entry.name == "incident" && entry.description.is_some())
        );
    }

    #[test]
    fn config_profile_diff_detects_change() {
        let root = unique_temp_dir("diff");
        let config_path = root.join("wa.toml");
        write_file(&config_path, "[general]\nlog_level = \"info\"\n");

        let profiles_dir = wa_core::config_profiles::resolve_profiles_dir(Some(&config_path));
        let profile_path = profiles_dir.join("incident.toml");
        write_file(&profile_path, "[general]\nlog_level = \"debug\"\n");

        let (base_toml, merged_toml) =
            load_and_merge_config_profile(&config_path, "incident").unwrap();
        let diff_lines = compute_config_diff(&base_toml, &merged_toml);
        assert!(
            diff_lines
                .iter()
                .any(|line| line.contains("log_level = \"debug\""))
        );
        assert!(
            diff_lines
                .iter()
                .any(|line| line.contains("log_level = \"info\""))
        );
    }

    #[test]
    fn config_profile_apply_and_rollback_restores_base() {
        let root = unique_temp_dir("apply_rollback");
        let config_path = root.join("wa.toml");
        write_file(&config_path, "[general]\nlog_level = \"info\"\n");

        let profiles_dir = wa_core::config_profiles::resolve_profiles_dir(Some(&config_path));
        let profile_path = profiles_dir.join("incident.toml");
        write_file(&profile_path, "[general]\nlog_level = \"debug\"\n");

        handle_config_profile_command(
            ConfigProfileCommands::Apply {
                name: "incident".to_string(),
                dry_run: false,
                path: Some(config_path.display().to_string()),
            },
            None,
        )
        .unwrap();

        let updated = std::fs::read_to_string(&config_path).unwrap();
        assert!(updated.contains("log_level = \"debug\""));

        handle_config_profile_command(
            ConfigProfileCommands::Rollback {
                yes: true,
                path: Some(config_path.display().to_string()),
            },
            None,
        )
        .unwrap();

        let rolled_back = std::fs::read_to_string(&config_path).unwrap();
        assert!(rolled_back.contains("log_level = \"info\""));
    }

    #[test]
    fn config_profile_invalid_toml_is_rejected() {
        let root = unique_temp_dir("invalid");
        let config_path = root.join("wa.toml");
        write_file(&config_path, "[general]\nlog_level = \"info\"\n");

        let profiles_dir = wa_core::config_profiles::resolve_profiles_dir(Some(&config_path));
        let profile_path = profiles_dir.join("incident.toml");
        write_file(&profile_path, "[general]\nlog_level = 42\n");

        let err = load_and_merge_config_profile(&config_path, "incident").unwrap_err();
        let message = err.to_string();
        assert!(
            message.contains("invalid") || message.contains("parse") || message.contains("config")
        );
    }

    async fn insert_token(
        storage: &StorageHandle,
        workspace_id: &str,
        code: &str,
        pane_id: Option<u64>,
        expires_at: i64,
        used_at: Option<i64>,
        fingerprint: &str,
    ) {
        // approval_tokens.pane_id has a FK to panes(pane_id).
        if let Some(pid) = pane_id {
            let now = now_ms();
            let pane = PaneRecord {
                pane_id: pid,
                pane_uuid: None,
                domain: "local".to_string(),
                window_id: None,
                tab_id: None,
                title: None,
                cwd: None,
                tty_name: None,
                first_seen_at: now,
                last_seen_at: now,
                observed: true,
                ignore_reason: None,
                last_decision_at: None,
            };
            storage.upsert_pane(pane).await.unwrap();
        }

        let token = ApprovalTokenRecord {
            id: 0,
            code_hash: hash_allow_once_code(code),
            created_at: now_ms(),
            expires_at,
            used_at,
            workspace_id: workspace_id.to_string(),
            action_kind: "send_text".to_string(),
            pane_id,
            action_fingerprint: fingerprint.to_string(),
            plan_hash: None,
            plan_version: None,
            risk_summary: None,
        };
        storage.insert_approval_token(token).await.unwrap();
    }

    fn sample_prepared_plan_record(expires_at: i64) -> PreparedPlanRecord {
        let params = PreparedPlanParams::SendText {
            pane_id: 7,
            no_paste: false,
            no_newline: false,
            wait_for: None,
            wait_for_regex: false,
            timeout_secs: 30,
        };
        PreparedPlanRecord {
            plan_id: "plan:deadbeef".to_string(),
            plan_hash: "sha256:deadbeef".to_string(),
            workspace_id: "ws-test".to_string(),
            action_kind: wa_core::policy::ActionKind::SendText.as_str().to_string(),
            pane_id: Some(7),
            pane_uuid: None,
            params_json: Some(serde_json::to_string(&params).unwrap()),
            plan_json: "{}".to_string(),
            requires_approval: false,
            created_at: 1000,
            expires_at,
            consumed_at: None,
        }
    }

    #[test]
    fn workflow_dry_run_report_includes_steps() {
        let command_ctx = wa_core::dry_run::CommandContext::new("workflow run", true);
        let config = wa_core::config::Config::default();
        let report =
            build_workflow_dry_run_report(&command_ctx, "handle_compaction", 42, None, &config);

        assert!(!report.expected_actions.is_empty());
        assert!(
            report
                .expected_actions
                .iter()
                .any(|action| action.action_type == wa_core::dry_run::ActionType::AcquireLock)
        );

        let send_actions: Vec<_> = report
            .expected_actions
            .iter()
            .filter(|action| action.action_type == wa_core::dry_run::ActionType::SendText)
            .collect();
        assert!(!send_actions.is_empty());
        assert!(
            send_actions
                .iter()
                .all(|action| action.description.contains("policy-gated"))
        );
        assert!(send_actions.iter().all(|action| {
            action
                .metadata
                .as_ref()
                .and_then(|value| value.get("policy_gated"))
                .and_then(serde_json::Value::as_bool)
                .unwrap_or(false)
        }));

        let workflow_check = report
            .policy_evaluation
            .as_ref()
            .and_then(|policy| policy.checks.iter().find(|check| check.name == "workflow"));
        assert!(workflow_check.is_some());
        assert!(workflow_check.unwrap().passed);
    }

    #[test]
    fn workflow_dry_run_report_unknown_workflow() {
        let command_ctx = wa_core::dry_run::CommandContext::new("workflow run", true);
        let config = wa_core::config::Config::default();
        let report =
            build_workflow_dry_run_report(&command_ctx, "unknown_workflow", 7, None, &config);

        assert!(report.expected_actions.is_empty());
        assert!(
            report
                .warnings
                .iter()
                .any(|warning| warning.contains("No workflow steps available"))
        );

        let workflow_check = report
            .policy_evaluation
            .as_ref()
            .and_then(|policy| policy.checks.iter().find(|check| check.name == "workflow"));
        assert!(workflow_check.is_some());
        assert!(!workflow_check.unwrap().passed);
    }

    #[test]
    fn workflow_dry_run_report_step_metadata_includes_step_id() {
        let command_ctx = wa_core::dry_run::CommandContext::new("workflow run", true);
        let config = wa_core::config::Config::default();
        let report =
            build_workflow_dry_run_report(&command_ctx, "handle_compaction", 42, None, &config);

        // Workflow body steps (not lock/unlock) should have metadata with a step_id
        let body_steps: Vec<_> = report
            .expected_actions
            .iter()
            .filter(|a| {
                a.action_type != wa_core::dry_run::ActionType::AcquireLock
                    && a.action_type != wa_core::dry_run::ActionType::ReleaseLock
                    && a.action_type != wa_core::dry_run::ActionType::MarkEventHandled
            })
            .collect();
        assert!(!body_steps.is_empty(), "should have workflow body steps");
        for action in &body_steps {
            let meta = action
                .metadata
                .as_ref()
                .expect("body step metadata should be present");
            assert!(meta["step_id"].is_string(), "step_id should be a string");
            assert!(
                meta.get("idempotent").is_some(),
                "idempotent field should be present"
            );
        }
    }

    #[test]
    fn workflow_dry_run_report_has_lock_and_release() {
        let command_ctx = wa_core::dry_run::CommandContext::new("workflow run", true);
        let config = wa_core::config::Config::default();
        let report =
            build_workflow_dry_run_report(&command_ctx, "handle_compaction", 7, None, &config);

        // First action must be AcquireLock
        assert_eq!(
            report.expected_actions.first().unwrap().action_type,
            wa_core::dry_run::ActionType::AcquireLock
        );
        // Last action must be ReleaseLock
        assert_eq!(
            report.expected_actions.last().unwrap().action_type,
            wa_core::dry_run::ActionType::ReleaseLock
        );
    }

    #[test]
    fn workflow_dry_run_report_json_roundtrip() {
        let command_ctx = wa_core::dry_run::CommandContext::new("workflow run", true);
        let config = wa_core::config::Config::default();
        let report =
            build_workflow_dry_run_report(&command_ctx, "handle_compaction", 7, None, &config);

        // JSON serialization should succeed
        let json_str =
            wa_core::dry_run::format_json(&report).expect("JSON serialization should succeed");
        let parsed: serde_json::Value =
            serde_json::from_str(&json_str).expect("should be valid JSON");

        assert!(parsed.get("command").is_some());
        assert!(parsed.get("expected_actions").is_some());
        let actions = parsed["expected_actions"].as_array().unwrap();
        assert!(!actions.is_empty());
    }

    #[test]
    fn workflow_dry_run_report_triggers_shown_for_claude_code_limits() {
        let command_ctx = wa_core::dry_run::CommandContext::new("workflow run", true);
        let config = wa_core::config::Config::default();
        let report = build_workflow_dry_run_report(
            &command_ctx,
            "handle_claude_code_limits",
            7,
            None,
            &config,
        );

        // handle_claude_code_limits has trigger_event_types; should show MarkEventHandled
        let mark_actions: Vec<_> = report
            .expected_actions
            .iter()
            .filter(|a| a.action_type == wa_core::dry_run::ActionType::MarkEventHandled)
            .collect();
        assert!(
            !mark_actions.is_empty(),
            "should show MarkEventHandled for trigger events"
        );
        assert!(mark_actions[0].description.contains("usage"));
    }

    #[test]
    fn workflow_dry_run_report_usage_limits_steps() {
        let command_ctx = wa_core::dry_run::CommandContext::new("workflow run", true);
        let config = wa_core::config::Config::default();
        let report =
            build_workflow_dry_run_report(&command_ctx, "handle_usage_limits", 10, None, &config);

        // Should have steps (lock + workflow steps + release)
        assert!(
            report.expected_actions.len() >= 3,
            "usage limits workflow should have at least 3 actions"
        );

        // Workflow check should pass
        let workflow_check = report
            .policy_evaluation
            .as_ref()
            .and_then(|p| p.checks.iter().find(|c| c.name == "workflow"));
        assert!(workflow_check.unwrap().passed);
    }

    #[test]
    fn workflow_dry_run_human_format_completeness() {
        let command_ctx = wa_core::dry_run::CommandContext::new("workflow run", true);
        let config = wa_core::config::Config::default();
        let report =
            build_workflow_dry_run_report(&command_ctx, "handle_compaction", 7, None, &config);

        let formatted = wa_core::dry_run::format_human(&report);

        // Human format should include key sections
        assert!(formatted.contains("DRY RUN"));
        assert!(formatted.contains("Command:"));
        assert!(formatted.contains("Policy Evaluation:"));
        assert!(formatted.contains("Expected Actions:"));
        assert!(formatted.contains("[send-text]"));
        assert!(formatted.contains("[acquire-lock]"));
        assert!(formatted.contains("[release-lock]"));
        assert!(formatted.contains("remove --dry-run"));
    }

    #[cfg(unix)]
    #[test]
    fn remote_setup_dry_run_avoids_install_commands() {
        use std::os::unix::process::ExitStatusExt;
        use std::sync::Mutex;

        let commands = Mutex::new(Vec::new());
        let runner = |_: &str, command: &str, _timeout: std::time::Duration| {
            commands.lock().unwrap().push(command.to_string());
            let stdout = if command.contains("command -v apt-get") {
                "/usr/bin/apt-get\n".to_string()
            } else if command.contains("command -v wezterm") {
                String::new()
            } else if command.contains("systemctl --user is-active") {
                "inactive\n".to_string()
            } else if command.contains("loginctl show-user") {
                "Linger=no\n".to_string()
            } else {
                String::new()
            };

            Ok(RemoteCommandOutput {
                status: std::process::ExitStatus::from_raw(0),
                stdout,
                stderr: String::new(),
                duration_ms: 5,
            })
        };

        let options = RemoteSetupOptions {
            apply: false,
            dry_run: true,
            yes: true,
            install_wa: true,
            wa_path: None,
            wa_version: Some("git"),
            timeout_secs: 5,
            verbose: 0,
        };

        run_remote_setup_with_runner("example", &options, &runner).unwrap();

        let cmds = { commands.lock().unwrap().clone() };
        assert!(cmds.iter().any(|cmd| cmd == "true"));
        assert!(cmds.iter().any(|cmd| cmd.contains("command -v apt-get")));
        assert!(cmds.iter().any(|cmd| cmd.contains("command -v wezterm")));
        assert!(!cmds.iter().any(|cmd| cmd.contains("apt-get install")));
        assert!(!cmds.iter().any(|cmd| cmd.contains("cargo install")));
        assert!(!cmds.iter().any(|cmd| cmd.contains("scp ")));
    }

    #[test]
    fn structured_uservar_name_detection() {
        assert!(is_structured_uservar_name("wa_event"));
        assert!(is_structured_uservar_name("wa-foo"));
        assert!(is_structured_uservar_name("WA_FOO"));
        assert!(!is_structured_uservar_name("other_event"));
    }

    #[test]
    fn robot_help_toon_roundtrip() {
        fn normalize_numbers_to_int(v: &mut serde_json::Value) {
            match v {
                serde_json::Value::Array(items) => {
                    for item in items {
                        normalize_numbers_to_int(item);
                    }
                }
                serde_json::Value::Object(map) => {
                    for (_, value) in map.iter_mut() {
                        normalize_numbers_to_int(value);
                    }
                }
                serde_json::Value::Number(n) => {
                    // toon_rust currently decodes numbers as floats; normalize integral floats back
                    // to integers so comparisons against serde_json::to_value(...) are stable.
                    if let Some(f) = n.as_f64() {
                        #[allow(clippy::cast_precision_loss)]
                        let max_u64 = u64::MAX as f64;
                        if f.fract() == 0.0 && f >= 0.0 && f <= max_u64 {
                            #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
                            let as_u64 = f as u64;
                            *v = serde_json::Value::Number(serde_json::Number::from(as_u64));
                        }
                    }
                }
                serde_json::Value::Null
                | serde_json::Value::Bool(_)
                | serde_json::Value::String(_) => {}
            }
        }

        let resp = RobotResponse::success(build_robot_help(), 0);
        let toon = toon_rust::encode(serde_json::to_value(&resp).unwrap(), None);

        let decoded = toon_rust::try_decode(&toon, None).unwrap();
        let json = toon_rust::cli::json_stringify::json_stringify_lines(&decoded, 0).join("\n");

        let mut decoded_value: serde_json::Value = serde_json::from_str(&json).unwrap();
        normalize_numbers_to_int(&mut decoded_value);
        let expected_value: serde_json::Value = serde_json::to_value(&resp).unwrap();

        assert_eq!(decoded_value, expected_value);
    }

    #[test]
    fn send_dry_run_report_includes_wait_for_and_no_paste_warning() {
        let config = wa_core::config::Config::default();
        let command_ctx = wa_core::dry_run::CommandContext::new("wa send", true);
        let report = build_send_dry_run_report(
            &command_ctx,
            1,
            None,
            None,
            "echo hi",
            true,
            Some("READY"),
            5,
            &config,
            wa_core::policy::ActorKind::Human,
        );

        assert!(
            report
                .expected_actions
                .iter()
                .any(|action| action.action_type == wa_core::dry_run::ActionType::SendText)
        );
        assert!(
            report
                .expected_actions
                .iter()
                .any(|action| action.action_type == wa_core::dry_run::ActionType::WaitFor)
        );
        assert!(
            report
                .warnings
                .iter()
                .any(|warning| warning.contains("no_paste"))
        );
    }

    #[test]
    fn format_send_result_human_includes_approval_and_wait_for_skip() {
        let approval = wa_core::policy::ApprovalRequest {
            allow_once_code: "ABC123".to_string(),
            allow_once_full_hash: "sha256:deadbeef".to_string(),
            expires_at: 0,
            summary: "Needs approval".to_string(),
            command: "wa approve ABC123".to_string(),
        };
        let decision = wa_core::policy::PolicyDecision::RequireApproval {
            reason: "Alt-screen unknown".to_string(),
            rule_id: Some("policy.alt_screen_unknown".to_string()),
            approval: Some(approval),
            context: None,
        };
        let injection = wa_core::policy::InjectionResult::RequiresApproval {
            decision,
            summary: "[redacted]".to_string(),
            pane_id: 7,
            action: wa_core::policy::ActionKind::SendText,
            audit_action_id: Some(42),
        };
        let data = HumanSendData {
            pane_id: 7,
            injection,
            wait_for: None,
            verification_error: None,
            no_paste: false,
            no_newline: false,
        };

        let output = format_send_result_human(&data, "[redacted]", Some("READY"));

        assert!(output.contains("approval_required"));
        assert!(output.contains("wa approve ABC123"));
        assert!(output.contains("Audit ID: 42"));
        assert!(output.contains("Wait-for: skipped"));
    }

    #[test]
    fn format_send_result_human_includes_wait_for_match() {
        let decision = wa_core::policy::PolicyDecision::Allow {
            rule_id: Some("policy.allow".to_string()),
            context: None,
        };
        let injection = wa_core::policy::InjectionResult::Allowed {
            decision,
            summary: "[redacted]".to_string(),
            pane_id: 1,
            action: wa_core::policy::ActionKind::SendText,
            audit_action_id: Some(7),
        };
        let wait_for = RobotWaitForData {
            pane_id: 1,
            pattern: "READY".to_string(),
            matched: true,
            elapsed_ms: 10,
            polls: 2,
            is_regex: false,
        };
        let data = HumanSendData {
            pane_id: 1,
            injection,
            wait_for: Some(wait_for),
            verification_error: None,
            no_paste: false,
            no_newline: false,
        };

        let output = format_send_result_human(&data, "[redacted]", None);

        assert!(output.contains("matched"));
        assert!(output.contains("Wait-for"));
        assert!(output.contains("Audit ID: 7"));
    }

    #[test]
    fn format_send_result_human_includes_denial_and_verification_error() {
        let decision = wa_core::policy::PolicyDecision::Deny {
            reason: "Alt-screen active".to_string(),
            rule_id: Some("policy.alt_screen".to_string()),
            context: None,
        };
        let injection = wa_core::policy::InjectionResult::Denied {
            decision,
            summary: "[redacted]".to_string(),
            pane_id: 9,
            action: wa_core::policy::ActionKind::SendText,
            audit_action_id: Some(99),
        };
        let data = HumanSendData {
            pane_id: 9,
            injection,
            wait_for: None,
            verification_error: Some("Timeout waiting for pattern 'READY'".to_string()),
            no_paste: false,
            no_newline: false,
        };

        let output = format_send_result_human(&data, "[redacted]", Some("READY"));

        assert!(output.contains("Status: denied"));
        assert!(output.contains("policy.alt_screen"));
        assert!(output.contains("Alt-screen active"));
        assert!(output.contains("Wait-for: skipped"));
        assert!(output.contains("Verification"));
        assert!(output.contains("Audit ID: 99"));
    }

    #[test]
    fn send_dry_run_report_redacts_command() {
        let config = wa_core::config::Config::default();
        let command_ctx = wa_core::dry_run::CommandContext::new(
            "wa send 1 \"sk-abc123456789012345678901234567890123456789012345678901\"",
            true,
        );
        let report = build_send_dry_run_report(
            &command_ctx,
            1,
            None,
            None,
            "sk-abc123456789012345678901234567890123456789012345678901",
            false,
            None,
            10,
            &config,
            wa_core::policy::ActorKind::Human,
        );

        let redacted = report.redacted();
        assert!(redacted.command.contains("[REDACTED]"));
        assert!(!redacted.command.contains("sk-abc"));
    }

    // ========================================================================
    // wa-y2e: Robot mode dry-run tests
    // ========================================================================

    /// Helper to create a StoredEvent for testing.
    fn make_stored_event(id: i64, rule_id: &str, handled: bool) -> wa_core::storage::StoredEvent {
        wa_core::storage::StoredEvent {
            id,
            pane_id: 3,
            rule_id: rule_id.to_string(),
            agent_type: "codex".to_string(),
            event_type: "usage.warning".to_string(),
            severity: "warning".to_string(),
            confidence: 0.95,
            extracted: None,
            matched_text: None,
            segment_id: None,
            detected_at: 1700000000000,
            dedupe_key: None,
            handled_at: if handled { Some(1700000001000) } else { None },
            handled_by_workflow_id: if handled {
                Some("wf-123".to_string())
            } else {
                None
            },
            handled_status: if handled {
                Some("completed".to_string())
            } else {
                None
            },
        }
    }

    /// Helper to create a RuleDef with an optional workflow.
    fn make_rule_def(id: &str, workflow: Option<&str>) -> wa_core::patterns::RuleDef {
        wa_core::patterns::RuleDef {
            id: id.to_string(),
            agent_type: wa_core::patterns::AgentType::Codex,
            event_type: "usage.warning".to_string(),
            severity: wa_core::patterns::Severity::Warning,
            anchors: vec!["usage".to_string()],
            regex: None,
            description: "Test rule".to_string(),
            remediation: None,
            workflow: workflow.map(String::from),
            manual_fix: None,
            preview_command: Some("wa robot workflow run {workflow} --pane {pane}".to_string()),
            learn_more_url: None,
        }
    }

    #[test]
    fn event_would_handle_with_workflow_rule() {
        let event = make_stored_event(1, "core.codex:session_compaction", false);
        let rule = make_rule_def("core.codex:session_compaction", Some("handle_compaction"));
        let config = wa_core::config::Config::default();

        let result = build_event_would_handle(&event, Some(&rule), &config);
        assert!(result.is_some());
        let preview = result.unwrap();
        assert_eq!(preview.workflow, "handle_compaction");
        // handle_compaction is in both enabled and auto_run_allowlist by default
        assert_eq!(preview.would_run, Some(true));
        assert!(preview.reason.is_none());
    }

    #[test]
    fn event_would_handle_without_workflow_returns_none() {
        let event = make_stored_event(2, "codex.info", false);
        let rule = make_rule_def("codex.info", None);
        let config = wa_core::config::Config::default();

        let result = build_event_would_handle(&event, Some(&rule), &config);
        assert!(result.is_none());
    }

    #[test]
    fn event_would_handle_no_rule_returns_none() {
        let event = make_stored_event(3, "unknown.rule", false);
        let config = wa_core::config::Config::default();

        let result = build_event_would_handle(&event, None, &config);
        assert!(result.is_none());
    }

    #[test]
    fn event_would_handle_already_handled_event() {
        let event = make_stored_event(4, "codex.usage_limit_reached", true);
        let rule = make_rule_def("codex.usage_limit_reached", Some("handle_usage_limits"));
        let config = wa_core::config::Config::default();

        let result = build_event_would_handle(&event, Some(&rule), &config);
        assert!(result.is_some());
        let preview = result.unwrap();
        assert_eq!(preview.would_run, Some(false));
        assert!(
            preview
                .reason
                .as_deref()
                .unwrap()
                .contains("already handled")
        );
    }

    #[test]
    fn event_would_handle_workflow_disabled_by_config() {
        let event = make_stored_event(5, "codex.usage_limit_reached", false);
        let rule = make_rule_def("codex.usage_limit_reached", Some("handle_usage_limits"));
        let mut config = wa_core::config::Config::default();
        // Set enabled list to only include a different workflow
        config.workflows.enabled = vec!["handle_compaction".to_string()];

        let result = build_event_would_handle(&event, Some(&rule), &config);
        assert!(result.is_some());
        let preview = result.unwrap();
        assert_eq!(preview.would_run, Some(false));
        assert!(
            preview
                .reason
                .as_deref()
                .unwrap()
                .contains("disabled by config")
        );
    }

    #[test]
    fn event_would_handle_workflow_not_in_auto_run() {
        let event = make_stored_event(6, "codex.usage_limit_reached", false);
        let rule = make_rule_def("codex.usage_limit_reached", Some("handle_usage_limits"));
        let mut config = wa_core::config::Config::default();
        config
            .workflows
            .auto_run_denylist
            .push("handle_usage_limits".to_string());

        let result = build_event_would_handle(&event, Some(&rule), &config);
        assert!(result.is_some());
        let preview = result.unwrap();
        assert_eq!(preview.would_run, Some(false));
        assert!(
            preview
                .reason
                .as_deref()
                .unwrap()
                .contains("not in auto-run allowlist")
        );
    }

    #[test]
    fn event_would_handle_preview_fields_serializable() {
        let event = make_stored_event(7, "core.codex:session_compaction", false);
        let rule = make_rule_def("core.codex:session_compaction", Some("handle_compaction"));
        let config = wa_core::config::Config::default();

        let preview = build_event_would_handle(&event, Some(&rule), &config).unwrap();
        let json = serde_json::to_value(&preview).expect("should serialize");
        assert_eq!(json["workflow"], "handle_compaction");
        assert_eq!(json["would_run"], true);
        // reason should be absent (serialized as null or missing via skip_serializing_if)
    }

    #[test]
    fn send_dry_run_report_json_roundtrip() {
        let config = wa_core::config::Config::default();
        let command_ctx =
            wa_core::dry_run::CommandContext::new("wa robot send 0 \"echo hi\" --dry-run", true);
        let report = build_send_dry_run_report(
            &command_ctx,
            0,
            None,
            None,
            "echo hi",
            false,
            None,
            10,
            &config,
            wa_core::policy::ActorKind::Robot,
        );

        let json_str =
            wa_core::dry_run::format_json(&report).expect("JSON serialization should succeed");
        let parsed: serde_json::Value =
            serde_json::from_str(&json_str).expect("should be valid JSON");

        assert!(parsed.get("command").is_some());
        assert!(parsed.get("target_resolution").is_some());
        assert!(parsed.get("policy_evaluation").is_some());
        assert!(parsed.get("expected_actions").is_some());
        let actions = parsed["expected_actions"].as_array().unwrap();
        assert!(!actions.is_empty());
    }

    #[test]
    fn send_dry_run_report_policy_evaluation_always_present() {
        let config = wa_core::config::Config::default();
        let command_ctx = wa_core::dry_run::CommandContext::new("wa robot send 0 \"test\"", true);
        let report = build_send_dry_run_report(
            &command_ctx,
            0,
            None,
            None,
            "test",
            false,
            None,
            10,
            &config,
            wa_core::policy::ActorKind::Robot,
        );

        assert!(
            report.policy_evaluation.is_some(),
            "policy evaluation must always be present in dry-run"
        );
        let eval = report.policy_evaluation.unwrap();
        assert!(!eval.checks.is_empty(), "policy checks must not be empty");
    }

    #[test]
    fn send_dry_run_report_without_wait_for_has_no_wait_action() {
        let config = wa_core::config::Config::default();
        let command_ctx = wa_core::dry_run::CommandContext::new("wa robot send 0 \"x\"", true);
        let report = build_send_dry_run_report(
            &command_ctx,
            0,
            None,
            None,
            "x",
            false,
            None, // no wait-for
            10,
            &config,
            wa_core::policy::ActorKind::Robot,
        );

        assert!(
            !report
                .expected_actions
                .iter()
                .any(|a| a.action_type == wa_core::dry_run::ActionType::WaitFor),
            "should not have WaitFor action when no --wait-for provided"
        );
        assert!(
            report
                .expected_actions
                .iter()
                .any(|a| a.action_type == wa_core::dry_run::ActionType::SendText),
            "should always have SendText action"
        );
    }

    #[test]
    fn send_dry_run_report_with_wait_for_has_both_actions() {
        let config = wa_core::config::Config::default();
        let command_ctx = wa_core::dry_run::CommandContext::new(
            "wa robot send 0 \"test\" --wait-for READY",
            true,
        );
        let report = build_send_dry_run_report(
            &command_ctx,
            0,
            None,
            None,
            "test",
            false,
            Some("READY"),
            15,
            &config,
            wa_core::policy::ActorKind::Robot,
        );

        assert!(
            report
                .expected_actions
                .iter()
                .any(|a| a.action_type == wa_core::dry_run::ActionType::SendText)
        );
        assert!(
            report
                .expected_actions
                .iter()
                .any(|a| a.action_type == wa_core::dry_run::ActionType::WaitFor)
        );
        // WaitFor description should contain the pattern and timeout
        let wait_action = report
            .expected_actions
            .iter()
            .find(|a| a.action_type == wa_core::dry_run::ActionType::WaitFor)
            .unwrap();
        assert!(wait_action.description.contains("READY"));
        assert!(wait_action.description.contains("15000"));
    }

    #[test]
    fn send_dry_run_report_deterministic() {
        let config = wa_core::config::Config::default();
        let build = || {
            let ctx = wa_core::dry_run::CommandContext::new("wa robot send 0 \"hello\"", true);
            build_send_dry_run_report(
                &ctx,
                0,
                None,
                None,
                "hello",
                false,
                None,
                10,
                &config,
                wa_core::policy::ActorKind::Robot,
            )
        };

        let r1 = build();
        let r2 = build();

        let j1 = wa_core::dry_run::format_json(&r1).unwrap();
        let j2 = wa_core::dry_run::format_json(&r2).unwrap();
        assert_eq!(j1, j2, "dry-run reports must be deterministic");
    }

    #[test]
    fn workflow_dry_run_report_deterministic() {
        let config = wa_core::config::Config::default();
        let build = || {
            let ctx = wa_core::dry_run::CommandContext::new("workflow run", true);
            build_workflow_dry_run_report(&ctx, "handle_compaction", 7, None, &config)
        };

        let r1 = build();
        let r2 = build();

        let j1 = wa_core::dry_run::format_json(&r1).unwrap();
        let j2 = wa_core::dry_run::format_json(&r2).unwrap();
        assert_eq!(j1, j2, "workflow dry-run reports must be deterministic");
    }

    #[test]
    fn workflow_dry_run_report_no_mutation_fields() {
        let command_ctx = wa_core::dry_run::CommandContext::new("workflow run", true);
        let config = wa_core::config::Config::default();
        let report =
            build_workflow_dry_run_report(&command_ctx, "handle_compaction", 7, None, &config);

        let json_str = wa_core::dry_run::format_json(&report).unwrap();

        // Dry-run should never contain execution-specific mutation markers
        assert!(!json_str.contains("\"execution_id\""));
        assert!(!json_str.contains("\"executed\":true"));
        assert!(!json_str.contains("\"started_at\""));
        assert!(!json_str.contains("\"completed_at\""));
    }

    #[test]
    fn step_action_to_dry_run_type_maps_all_variants() {
        use wa_core::dry_run::ActionType;
        use wa_core::plan::StepAction;

        assert_eq!(
            step_action_to_dry_run_type(&StepAction::SendText {
                pane_id: 0,
                text: String::new(),
                paste_mode: None,
            }),
            ActionType::SendText
        );

        assert_eq!(
            step_action_to_dry_run_type(&StepAction::AcquireLock {
                lock_name: "test".to_string(),
                timeout_ms: None,
            }),
            ActionType::AcquireLock
        );

        assert_eq!(
            step_action_to_dry_run_type(&StepAction::ReleaseLock {
                lock_name: "test".to_string(),
            }),
            ActionType::ReleaseLock
        );

        assert_eq!(
            step_action_to_dry_run_type(&StepAction::MarkEventHandled { event_id: 1 }),
            ActionType::MarkEventHandled
        );
    }

    #[test]
    fn infer_action_type_from_name_covers_variants() {
        use wa_core::dry_run::ActionType;

        assert_eq!(
            infer_action_type_from_name("send_text_to_pane"),
            ActionType::SendText
        );
        assert_eq!(
            infer_action_type_from_name("wait_for_prompt"),
            ActionType::WaitFor
        );
        assert_eq!(
            infer_action_type_from_name("verify_compaction"),
            ActionType::WaitFor
        );
        assert_eq!(
            infer_action_type_from_name("check_status"),
            ActionType::WaitFor
        );
        assert_eq!(
            infer_action_type_from_name("stabilize_output"),
            ActionType::WaitFor
        );
        assert_eq!(
            infer_action_type_from_name("acquire_lock"),
            ActionType::AcquireLock
        );
        assert_eq!(
            infer_action_type_from_name("mark_event_handled"),
            ActionType::MarkEventHandled
        );
        assert_eq!(
            infer_action_type_from_name("run_workflow"),
            ActionType::WorkflowStep
        );
    }

    #[test]
    fn event_would_handle_first_step_for_handle_compaction() {
        let event = make_stored_event(8, "core.codex:session_compaction", false);
        let rule = make_rule_def("core.codex:session_compaction", Some("handle_compaction"));
        let config = wa_core::config::Config::default();

        let preview = build_event_would_handle(&event, Some(&rule), &config).unwrap();
        assert_eq!(preview.workflow, "handle_compaction");
        // handle_compaction is the only workflow with first_step support
        assert!(preview.first_step.is_some());
    }

    #[test]
    fn event_would_handle_first_step_unknown_workflow_is_none() {
        let event = make_stored_event(9, "codex.usage_limit_reached", false);
        let rule = make_rule_def("codex.usage_limit_reached", Some("handle_custom_workflow"));
        let config = wa_core::config::Config::default();

        let preview = build_event_would_handle(&event, Some(&rule), &config).unwrap();
        assert!(
            preview.first_step.is_none(),
            "first_step should be None for unknown workflows"
        );
    }

    #[test]
    fn cli_robot_events_dry_run_flag() {
        let cli = Cli::try_parse_from(["wa", "robot", "events", "--dry-run"])
            .expect("robot events --dry-run should parse");

        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Events { dry_run, .. }) => {
                    assert!(dry_run, "--dry-run flag should be true");
                }
                _ => panic!("expected Events"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn cli_robot_events_would_handle_flag() {
        let cli = Cli::try_parse_from(["wa", "robot", "events", "--would-handle"])
            .expect("robot events --would-handle should parse");

        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Events {
                    would_handle,
                    dry_run,
                    ..
                }) => {
                    assert!(would_handle, "--would-handle flag should be true");
                    assert!(!dry_run, "--dry-run should be false when not set");
                }
                _ => panic!("expected Events"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn cli_robot_send_dry_run_flag() {
        let cli = Cli::try_parse_from(["wa", "robot", "send", "0", "echo hello", "--dry-run"])
            .expect("robot send --dry-run should parse");

        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Send { dry_run, .. }) => {
                    assert!(dry_run, "--dry-run flag should be true");
                }
                _ => panic!("expected Send"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn validate_uservar_rejects_empty_fields() {
        assert!(validate_uservar_request(1, "", "x").is_err());
        assert!(validate_uservar_request(1, "wa_event", "").is_err());
    }

    #[test]
    fn validate_uservar_rejects_oversize_payload() {
        // MAX_MESSAGE_SIZE is 131072 (128KB) - must match validate_uservar_request
        const MAX_MESSAGE_SIZE: usize = 131_072;
        let name = "wa_event";
        let value = "a".repeat(MAX_MESSAGE_SIZE);
        let err = validate_uservar_request(1, name, &value).unwrap_err();
        assert!(err.contains("too large"));
    }

    #[test]
    fn validate_uservar_accepts_base64_json() {
        let name = "wa_event";
        let value = "eyJraW5kIjoicHJvbXB0In0="; // {"kind":"prompt"}
        assert!(validate_uservar_request(1, name, value).is_ok());
    }

    #[tokio::test]
    async fn robot_approve_valid_code_consumes() {
        let (storage, db_path) = setup_storage("valid").await;
        let workspace_id = "ws-valid";
        let code = "ABC12345";
        let fingerprint = "sha256:valid";
        let expires_at = now_ms() + 60_000;

        insert_token(
            &storage,
            workspace_id,
            code,
            Some(5),
            expires_at,
            None,
            fingerprint,
        )
        .await;

        let data = evaluate_robot_approve(
            &storage,
            workspace_id,
            code,
            Some(5),
            Some(fingerprint),
            false,
        )
        .await
        .unwrap();

        assert!(data.valid);
        assert_eq!(data.code, code);
        assert_eq!(data.pane_id, Some(5));
        assert!(data.consumed_at.is_some());

        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn robot_approve_dry_run_does_not_consume() {
        let (storage, db_path) = setup_storage("dry_run").await;
        let workspace_id = "ws-dry";
        let code = "DRY12345";
        let fingerprint = "sha256:dry";
        let expires_at = now_ms() + 60_000;

        insert_token(
            &storage,
            workspace_id,
            code,
            Some(1),
            expires_at,
            None,
            fingerprint,
        )
        .await;

        let data = evaluate_robot_approve(
            &storage,
            workspace_id,
            code,
            Some(1),
            Some(fingerprint),
            true,
        )
        .await
        .unwrap();

        assert_eq!(data.dry_run, Some(true));
        assert!(data.consumed_at.is_none());

        let data2 = evaluate_robot_approve(
            &storage,
            workspace_id,
            code,
            Some(1),
            Some(fingerprint),
            false,
        )
        .await
        .unwrap();

        assert!(data2.consumed_at.is_some());

        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn robot_approve_expired_code() {
        let (storage, db_path) = setup_storage("expired").await;
        let workspace_id = "ws-expired";
        let code = "EXP12345";
        let fingerprint = "sha256:expired";

        insert_token(
            &storage,
            workspace_id,
            code,
            Some(2),
            now_ms() - 1,
            None,
            fingerprint,
        )
        .await;

        let err = evaluate_robot_approve(
            &storage,
            workspace_id,
            code,
            Some(2),
            Some(fingerprint),
            false,
        )
        .await
        .unwrap_err();

        assert_eq!(err.code, "E_APPROVAL_EXPIRED");

        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn robot_approve_consumed_code() {
        let (storage, db_path) = setup_storage("consumed").await;
        let workspace_id = "ws-consumed";
        let code = "CON12345";
        let fingerprint = "sha256:consumed";
        let used_at = now_ms() - 10;

        insert_token(
            &storage,
            workspace_id,
            code,
            Some(3),
            now_ms() + 60_000,
            Some(used_at),
            fingerprint,
        )
        .await;

        let err = evaluate_robot_approve(
            &storage,
            workspace_id,
            code,
            Some(3),
            Some(fingerprint),
            false,
        )
        .await
        .unwrap_err();

        assert_eq!(err.code, "E_APPROVAL_CONSUMED");

        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn robot_approve_wrong_pane() {
        let (storage, db_path) = setup_storage("wrong_pane").await;
        let workspace_id = "ws-pane";
        let code = "PANE1234";
        let fingerprint = "sha256:pane";
        let expires_at = now_ms() + 60_000;

        insert_token(
            &storage,
            workspace_id,
            code,
            Some(9),
            expires_at,
            None,
            fingerprint,
        )
        .await;

        let err = evaluate_robot_approve(
            &storage,
            workspace_id,
            code,
            Some(7),
            Some(fingerprint),
            false,
        )
        .await
        .unwrap_err();

        assert_eq!(err.code, "E_WRONG_PANE");

        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn robot_approve_wrong_workspace() {
        let (storage, db_path) = setup_storage("wrong_ws").await;
        let code = "WS123456";
        let fingerprint = "sha256:ws";
        let expires_at = now_ms() + 60_000;

        insert_token(&storage, "ws-a", code, None, expires_at, None, fingerprint).await;

        let err = evaluate_robot_approve(&storage, "ws-b", code, None, Some(fingerprint), false)
            .await
            .unwrap_err();

        assert_eq!(err.code, "E_WRONG_WORKSPACE");

        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn robot_approve_fingerprint_mismatch() {
        let (storage, db_path) = setup_storage("fingerprint").await;
        let workspace_id = "ws-fp";
        let code = "FP123456";
        let expires_at = now_ms() + 60_000;

        insert_token(
            &storage,
            workspace_id,
            code,
            Some(4),
            expires_at,
            None,
            "sha256:expected",
        )
        .await;

        let err = evaluate_robot_approve(
            &storage,
            workspace_id,
            code,
            Some(4),
            Some("sha256:other"),
            false,
        )
        .await
        .unwrap_err();

        assert_eq!(err.code, "E_FINGERPRINT_MISMATCH");

        cleanup_storage(storage, &db_path).await;
    }

    // ---- Triage scoring / ordering tests ----

    /// Helper: the severity ranking function used in the triage handler.
    /// Mirrors the closure in the Triage command handler exactly.
    fn triage_severity_rank(s: &str) -> u8 {
        match s {
            "error" => 3,
            "warning" => 2,
            "info" => 1,
            _ => 0,
        }
    }

    /// Helper: build a triage item JSON value for testing.
    fn triage_item(section: &str, severity: &str, title: &str) -> serde_json::Value {
        serde_json::json!({
            "section": section,
            "severity": severity,
            "title": title,
            "detail": "",
            "action": "wa doctor",
        })
    }

    /// Helper: sort triage items the same way the handler does.
    fn triage_sort(items: &mut Vec<serde_json::Value>) {
        items.sort_by(|a, b| {
            let sa = triage_severity_rank(a["severity"].as_str().unwrap_or("info"));
            let sb = triage_severity_rank(b["severity"].as_str().unwrap_or("info"));
            sb.cmp(&sa)
        });
    }

    /// Helper: apply severity filter the same way the handler does.
    fn triage_filter(items: &mut Vec<serde_json::Value>, min_severity: &str) {
        let min_rank = triage_severity_rank(min_severity);
        items.retain(|item| {
            let sev = item["severity"].as_str().unwrap_or("info");
            triage_severity_rank(sev) >= min_rank
        });
    }

    #[test]
    fn triage_severity_rank_ordering() {
        assert!(triage_severity_rank("error") > triage_severity_rank("warning"));
        assert!(triage_severity_rank("warning") > triage_severity_rank("info"));
        assert!(triage_severity_rank("info") > triage_severity_rank("unknown"));
        assert_eq!(triage_severity_rank("error"), 3);
        assert_eq!(triage_severity_rank("warning"), 2);
        assert_eq!(triage_severity_rank("info"), 1);
        assert_eq!(triage_severity_rank("other"), 0);
    }

    #[test]
    fn triage_sort_errors_first() {
        let mut items = vec![
            triage_item("events", "info", "workflow running"),
            triage_item("health", "error", "db timeout"),
            triage_item("crashes", "warning", "recent crash"),
            triage_item("events", "warning", "unhandled event"),
            triage_item("health", "error", "circuit open"),
        ];

        triage_sort(&mut items);

        let severities: Vec<&str> = items
            .iter()
            .map(|i| i["severity"].as_str().unwrap())
            .collect();
        assert_eq!(
            severities,
            vec!["error", "error", "warning", "warning", "info"]
        );
    }

    #[test]
    fn triage_sort_deterministic_within_same_severity() {
        // Items with the same severity should maintain stable relative order
        let mut items = vec![
            triage_item("events", "warning", "alpha"),
            triage_item("crashes", "warning", "beta"),
            triage_item("health", "warning", "gamma"),
        ];

        // Sort twice and verify same result (stability)
        triage_sort(&mut items);
        let first: Vec<String> = items
            .iter()
            .map(|i| i["title"].as_str().unwrap().to_string())
            .collect();

        triage_sort(&mut items);
        let second: Vec<String> = items
            .iter()
            .map(|i| i["title"].as_str().unwrap().to_string())
            .collect();

        assert_eq!(first, second, "Sort must be stable across invocations");
    }

    #[test]
    fn triage_filter_by_severity_error() {
        let mut items = vec![
            triage_item("health", "error", "db timeout"),
            triage_item("crashes", "warning", "recent crash"),
            triage_item("events", "info", "workflow"),
        ];

        triage_filter(&mut items, "error");
        assert_eq!(items.len(), 1);
        assert_eq!(items[0]["severity"], "error");
    }

    #[test]
    fn triage_filter_by_severity_warning() {
        let mut items = vec![
            triage_item("health", "error", "db timeout"),
            triage_item("crashes", "warning", "recent crash"),
            triage_item("events", "info", "workflow"),
        ];

        triage_filter(&mut items, "warning");
        assert_eq!(items.len(), 2);
        let severities: Vec<&str> = items
            .iter()
            .map(|i| i["severity"].as_str().unwrap())
            .collect();
        assert!(severities.contains(&"error"));
        assert!(severities.contains(&"warning"));
    }

    #[test]
    fn triage_filter_by_severity_info_keeps_all() {
        let mut items = vec![
            triage_item("health", "error", "db timeout"),
            triage_item("crashes", "warning", "recent crash"),
            triage_item("events", "info", "workflow"),
        ];

        triage_filter(&mut items, "info");
        assert_eq!(items.len(), 3);
    }

    #[test]
    fn triage_json_schema_structure() {
        // The triage JSON output has a specific contract; verify the shape
        let items = vec![
            triage_item("health", "error", "db timeout"),
            triage_item("events", "warning", "unhandled"),
        ];

        let result = serde_json::json!({
            "ok": true,
            "version": wa_core::VERSION,
            "total": items.len(),
            "items": items,
        });

        // Top-level fields
        assert_eq!(result["ok"], true);
        assert!(result["version"].is_string());
        assert_eq!(result["total"], 2);
        assert!(result["items"].is_array());

        // Per-item fields
        let first = &result["items"][0];
        assert!(first["section"].is_string());
        assert!(first["severity"].is_string());
        assert!(first["title"].is_string());
        assert!(first["detail"].is_string());
        assert!(first["action"].is_string());
    }

    #[test]
    fn triage_json_schema_empty_output() {
        let items: Vec<serde_json::Value> = vec![];
        let result = serde_json::json!({
            "ok": true,
            "version": wa_core::VERSION,
            "total": items.len(),
            "items": items,
        });

        assert_eq!(result["ok"], true);
        assert_eq!(result["total"], 0);
        assert_eq!(result["items"].as_array().unwrap().len(), 0);
    }

    #[test]
    fn triage_item_sections_are_valid() {
        let valid_sections = ["health", "crashes", "events", "workflows"];
        let items = vec![
            triage_item("health", "error", "a"),
            triage_item("crashes", "warning", "b"),
            triage_item("events", "info", "c"),
            triage_item("workflows", "info", "d"),
        ];
        for item in &items {
            let section = item["section"].as_str().unwrap();
            assert!(
                valid_sections.contains(&section),
                "Invalid section: {section}"
            );
        }
    }

    #[test]
    fn triage_severity_values_are_valid() {
        let valid_severities = ["error", "warning", "info"];
        let items = vec![
            triage_item("health", "error", "a"),
            triage_item("crashes", "warning", "b"),
            triage_item("events", "info", "c"),
        ];
        for item in &items {
            let sev = item["severity"].as_str().unwrap();
            assert!(valid_severities.contains(&sev), "Invalid severity: {sev}");
        }
    }

    #[test]
    fn triage_sort_then_filter_produces_correct_order() {
        let mut items = vec![
            triage_item("events", "info", "wf-running"),
            triage_item("health", "error", "db-timeout"),
            triage_item("crashes", "warning", "crash-1"),
            triage_item("events", "warning", "unhandled-1"),
            triage_item("health", "error", "circuit-open"),
            triage_item("events", "info", "wf-waiting"),
        ];

        triage_sort(&mut items);
        triage_filter(&mut items, "warning");

        // Should have 4 items: 2 errors + 2 warnings, in that order
        assert_eq!(items.len(), 4);
        assert_eq!(items[0]["severity"], "error");
        assert_eq!(items[1]["severity"], "error");
        assert_eq!(items[2]["severity"], "warning");
        assert_eq!(items[3]["severity"], "warning");
    }

    // ---- Triage quick-fix / explainability tests ----

    /// Helper: build a rich triage item with actions and explain fields.
    fn triage_rich_item(
        section: &str,
        severity: &str,
        title: &str,
        actions: Vec<(&str, &str)>,
        explain: Option<&str>,
    ) -> serde_json::Value {
        let actions_json: Vec<serde_json::Value> = actions
            .into_iter()
            .map(|(cmd, label)| serde_json::json!({"command": cmd, "label": label}))
            .collect();
        let mut item = serde_json::json!({
            "section": section,
            "severity": severity,
            "title": title,
            "detail": "",
            "action": actions_json.first()
                .and_then(|a| a["command"].as_str())
                .unwrap_or(""),
            "actions": actions_json,
        });
        if let Some(exp) = explain {
            item["explain"] = serde_json::Value::String(exp.to_string());
        }
        item
    }

    #[test]
    fn triage_rich_item_has_actions_array() {
        let item = triage_rich_item(
            "events",
            "warning",
            "unhandled event",
            vec![
                ("wa events --pane 3 --unhandled", "List unhandled events"),
                ("wa why --recent --pane 3", "Explain detection"),
                ("wa show 3", "Show pane details"),
            ],
            Some("wa why --recent --pane 3"),
        );

        let actions = item["actions"].as_array().unwrap();
        assert_eq!(actions.len(), 3);
        assert_eq!(actions[0]["command"], "wa events --pane 3 --unhandled");
        assert_eq!(actions[0]["label"], "List unhandled events");
        assert_eq!(actions[1]["command"], "wa why --recent --pane 3");
        assert_eq!(actions[2]["command"], "wa show 3");
    }

    #[test]
    fn triage_rich_item_primary_action_matches_first_action() {
        let item = triage_rich_item(
            "crashes",
            "warning",
            "Recent crash",
            vec![
                ("wa reproduce export --kind crash", "Export incident bundle"),
                ("wa doctor", "Check system health"),
            ],
            None,
        );

        // Primary action field matches first entry in actions array
        assert_eq!(item["action"], item["actions"][0]["command"]);
    }

    #[test]
    fn triage_rich_item_explain_field() {
        let with_explain = triage_rich_item(
            "events",
            "warning",
            "event",
            vec![("wa events", "List")],
            Some("wa why --recent --pane 5"),
        );
        assert_eq!(with_explain["explain"], "wa why --recent --pane 5");

        let without_explain = triage_rich_item(
            "health",
            "error",
            "issue",
            vec![("wa doctor", "Diagnose")],
            None,
        );
        assert!(without_explain.get("explain").is_none());
    }

    #[test]
    fn triage_all_section_types_map_to_suggested_commands() {
        // Every section type should produce at least one suggested action
        let section_actions: Vec<(&str, &str)> = vec![
            ("health", "wa doctor"),
            ("crashes", "wa reproduce export --kind crash"),
            ("events", "wa events --pane 1 --unhandled"),
            ("workflows", "wa workflow status wf-1"),
        ];

        for (section, expected_cmd) in &section_actions {
            let item = triage_rich_item(
                section,
                "warning",
                "test",
                vec![(expected_cmd, "Primary")],
                None,
            );
            let actions = item["actions"].as_array().unwrap();
            assert!(
                !actions.is_empty(),
                "Section '{section}' must have at least one action"
            );
            assert_eq!(
                actions[0]["command"].as_str().unwrap(),
                *expected_cmd,
                "Section '{section}' primary action mismatch"
            );
        }
    }

    #[test]
    fn triage_event_items_link_to_why_explain() {
        // Event triage items should include wa why as an explain command
        let item = triage_rich_item(
            "events",
            "error",
            "[pane 7] pattern_match: error_detect",
            vec![
                ("wa events --pane 7 --unhandled", "List unhandled"),
                ("wa why --recent --pane 7", "Explain detection"),
                ("wa show 7", "Show pane"),
            ],
            Some("wa why --recent --pane 7"),
        );

        // Explain field references wa why
        let explain = item["explain"].as_str().unwrap();
        assert!(
            explain.starts_with("wa why"),
            "Event explain should use 'wa why': {explain}"
        );

        // Actions should include wa why
        let actions = item["actions"].as_array().unwrap();
        let has_why = actions
            .iter()
            .any(|a| a["command"].as_str().unwrap_or("").contains("wa why"));
        assert!(has_why, "Event actions must include 'wa why' command");
    }

    #[test]
    fn triage_crash_items_link_to_reproduce() {
        let item = triage_rich_item(
            "crashes",
            "warning",
            "Recent crash",
            vec![
                ("wa reproduce export --kind crash", "Export incident bundle"),
                ("wa doctor", "Check system health"),
            ],
            Some("ls /tmp/crash_dir"),
        );

        let primary = item["action"].as_str().unwrap();
        assert!(
            primary.contains("reproduce"),
            "Crash primary action should reference reproduce: {primary}"
        );
    }

    // =========================================================================
    // Robot accounts tests (wa-nu4.1.5.4)
    // =========================================================================

    fn make_robot_account_info(id: &str, pct: f64, last_used: Option<i64>) -> RobotAccountInfo {
        RobotAccountInfo {
            account_id: id.to_string(),
            service: "openai".to_string(),
            name: Some(format!("{id}-name")),
            percent_remaining: pct,
            reset_at: None,
            tokens_used: Some(1000),
            tokens_remaining: Some(9000),
            tokens_limit: Some(10000),
            last_refreshed_at: 1000,
            last_used_at: last_used,
        }
    }

    #[test]
    fn robot_accounts_list_json_schema() {
        let data = RobotAccountsListData {
            accounts: vec![
                make_robot_account_info("acc-1", 80.0, None),
                make_robot_account_info("acc-2", 20.0, Some(5000)),
            ],
            total: 2,
            service: "openai".to_string(),
            pick_preview: None,
        };

        let json = serde_json::to_value(&data).unwrap();

        // Verify required fields
        assert_eq!(json["total"].as_u64().unwrap(), 2);
        assert_eq!(json["service"].as_str().unwrap(), "openai");
        assert!(json["accounts"].is_array());
        assert_eq!(json["accounts"].as_array().unwrap().len(), 2);

        // pick_preview should be absent (skip_serializing_if)
        assert!(json.get("pick_preview").is_none());
    }

    #[test]
    fn robot_account_info_json_schema() {
        let info = make_robot_account_info("acc-1", 75.5, Some(3000));
        let json = serde_json::to_value(&info).unwrap();

        // Required fields
        assert_eq!(json["account_id"].as_str().unwrap(), "acc-1");
        assert_eq!(json["service"].as_str().unwrap(), "openai");
        assert!((json["percent_remaining"].as_f64().unwrap() - 75.5).abs() < 0.001);
        assert_eq!(json["last_refreshed_at"].as_i64().unwrap(), 1000);
        assert_eq!(json["last_used_at"].as_i64().unwrap(), 3000);

        // Optional fields present
        assert_eq!(json["name"].as_str().unwrap(), "acc-1-name");
        assert_eq!(json["tokens_used"].as_i64().unwrap(), 1000);
        assert_eq!(json["tokens_remaining"].as_i64().unwrap(), 9000);
        assert_eq!(json["tokens_limit"].as_i64().unwrap(), 10000);
    }

    #[test]
    fn robot_account_info_skips_none_fields() {
        let info = RobotAccountInfo {
            account_id: "acc-1".to_string(),
            service: "openai".to_string(),
            name: None,
            percent_remaining: 50.0,
            reset_at: None,
            tokens_used: None,
            tokens_remaining: None,
            tokens_limit: None,
            last_refreshed_at: 1000,
            last_used_at: None,
        };
        let json = serde_json::to_value(&info).unwrap();

        // None fields should not appear
        assert!(json.get("name").is_none());
        assert!(json.get("reset_at").is_none());
        assert!(json.get("tokens_used").is_none());
        assert!(json.get("tokens_remaining").is_none());
        assert!(json.get("tokens_limit").is_none());
        assert!(json.get("last_used_at").is_none());

        // Required fields always present
        assert!(json.get("account_id").is_some());
        assert!(json.get("service").is_some());
        assert!(json.get("percent_remaining").is_some());
        assert!(json.get("last_refreshed_at").is_some());
    }

    #[test]
    fn robot_accounts_pick_preview_json_schema() {
        let preview = RobotAccountPickPreview {
            selected_account_id: Some("acc-best".to_string()),
            selected_name: Some("Best Account".to_string()),
            selection_reason: "Highest percent_remaining (90.0% vs 50.0%)".to_string(),
            threshold_percent: 5.0,
            candidates_count: 2,
            filtered_count: 1,
        };
        let json = serde_json::to_value(&preview).unwrap();

        assert_eq!(json["selected_account_id"].as_str().unwrap(), "acc-best");
        assert_eq!(json["selected_name"].as_str().unwrap(), "Best Account");
        assert!(
            json["selection_reason"]
                .as_str()
                .unwrap()
                .contains("Highest")
        );
        assert!((json["threshold_percent"].as_f64().unwrap() - 5.0).abs() < 0.001);
        assert_eq!(json["candidates_count"].as_u64().unwrap(), 2);
        assert_eq!(json["filtered_count"].as_u64().unwrap(), 1);
    }

    #[test]
    fn robot_accounts_pick_preview_none_selected() {
        let preview = RobotAccountPickPreview {
            selected_account_id: None,
            selected_name: None,
            selection_reason: "All 3 accounts below threshold (5.0%)".to_string(),
            threshold_percent: 5.0,
            candidates_count: 0,
            filtered_count: 3,
        };
        let json = serde_json::to_value(&preview).unwrap();

        assert!(json.get("selected_account_id").is_none());
        assert!(json.get("selected_name").is_none());
        assert_eq!(json["candidates_count"].as_u64().unwrap(), 0);
        assert_eq!(json["filtered_count"].as_u64().unwrap(), 3);
    }

    #[test]
    fn robot_accounts_list_with_pick_preview() {
        let data = RobotAccountsListData {
            accounts: vec![
                make_robot_account_info("best", 90.0, None),
                make_robot_account_info("ok", 50.0, Some(2000)),
                make_robot_account_info("low", 3.0, None),
            ],
            total: 3,
            service: "openai".to_string(),
            pick_preview: Some(RobotAccountPickPreview {
                selected_account_id: Some("best".to_string()),
                selected_name: Some("best-name".to_string()),
                selection_reason: "Highest percent_remaining (90.0% vs 50.0%)".to_string(),
                threshold_percent: 5.0,
                candidates_count: 2,
                filtered_count: 1,
            }),
        };
        let json = serde_json::to_value(&data).unwrap();

        // pick_preview should now be present
        assert!(json.get("pick_preview").is_some());
        let pp = &json["pick_preview"];
        assert_eq!(pp["selected_account_id"].as_str().unwrap(), "best");
        assert_eq!(pp["candidates_count"].as_u64().unwrap(), 2);
    }

    #[test]
    fn robot_accounts_mapping_from_account_record() {
        // Verify that AccountRecord maps correctly to RobotAccountInfo
        let record = wa_core::accounts::AccountRecord {
            id: 42,
            account_id: "acc-test".to_string(),
            service: "openai".to_string(),
            name: Some("Test Account".to_string()),
            percent_remaining: 65.5,
            reset_at: Some("2026-02-01T00:00:00Z".to_string()),
            tokens_used: Some(3450),
            tokens_remaining: Some(6550),
            tokens_limit: Some(10000),
            last_refreshed_at: 1234567890,
            last_used_at: Some(1234567800),
            created_at: 1234560000,
            updated_at: 1234567890,
        };

        // This mimics the mapping in the handler
        let info = RobotAccountInfo {
            account_id: record.account_id.clone(),
            service: record.service.clone(),
            name: record.name.clone(),
            percent_remaining: record.percent_remaining,
            reset_at: record.reset_at.clone(),
            tokens_used: record.tokens_used,
            tokens_remaining: record.tokens_remaining,
            tokens_limit: record.tokens_limit,
            last_refreshed_at: record.last_refreshed_at,
            last_used_at: record.last_used_at,
        };

        assert_eq!(info.account_id, "acc-test");
        assert_eq!(info.service, "openai");
        assert_eq!(info.name.as_deref(), Some("Test Account"));
        assert!((info.percent_remaining - 65.5).abs() < 0.001);
        assert_eq!(info.reset_at.as_deref(), Some("2026-02-01T00:00:00Z"));
        assert_eq!(info.tokens_used, Some(3450));

        // Verify id and created_at/updated_at are NOT in the output (internal fields)
        let json = serde_json::to_value(&info).unwrap();
        assert!(json.get("id").is_none());
        assert!(json.get("created_at").is_none());
        assert!(json.get("updated_at").is_none());
    }

    #[test]
    fn robot_accounts_pick_matches_select_account() {
        // The pick preview must use the same selection logic as workflows
        use wa_core::accounts::{AccountRecord, AccountSelectionConfig, select_account};

        let accounts = vec![
            AccountRecord {
                id: 0,
                account_id: "depleted".to_string(),
                service: "openai".to_string(),
                name: Some("Depleted".to_string()),
                percent_remaining: 2.0,
                reset_at: None,
                tokens_used: None,
                tokens_remaining: None,
                tokens_limit: None,
                last_refreshed_at: 1000,
                last_used_at: None,
                created_at: 1000,
                updated_at: 1000,
            },
            AccountRecord {
                id: 0,
                account_id: "best".to_string(),
                service: "openai".to_string(),
                name: Some("Best".to_string()),
                percent_remaining: 90.0,
                reset_at: None,
                tokens_used: None,
                tokens_remaining: None,
                tokens_limit: None,
                last_refreshed_at: 1000,
                last_used_at: Some(5000),
                created_at: 1000,
                updated_at: 1000,
            },
            AccountRecord {
                id: 0,
                account_id: "mid".to_string(),
                service: "openai".to_string(),
                name: Some("Mid".to_string()),
                percent_remaining: 50.0,
                reset_at: None,
                tokens_used: None,
                tokens_remaining: None,
                tokens_limit: None,
                last_refreshed_at: 1000,
                last_used_at: None,
                created_at: 1000,
                updated_at: 1000,
            },
        ];

        let config = AccountSelectionConfig::default();
        let result = select_account(&accounts, &config);

        // Build pick preview the same way the handler does
        let preview = RobotAccountPickPreview {
            selected_account_id: result.selected.as_ref().map(|a| a.account_id.clone()),
            selected_name: result.selected.as_ref().and_then(|a| a.name.clone()),
            selection_reason: result.explanation.selection_reason.clone(),
            threshold_percent: config.threshold_percent,
            candidates_count: result.explanation.candidates.len(),
            filtered_count: result.explanation.filtered_out.len(),
        };

        // Verify pick matches expected behavior
        assert_eq!(preview.selected_account_id.as_deref(), Some("best"));
        assert_eq!(preview.selected_name.as_deref(), Some("Best"));
        assert_eq!(preview.candidates_count, 2); // best + mid
        assert_eq!(preview.filtered_count, 1); // depleted below 5%
        assert!(
            preview
                .selection_reason
                .contains("Highest percent_remaining")
        );
    }

    #[test]
    fn robot_accounts_list_ordering_deterministic() {
        // Same input data produces same JSON output every time
        let build_data = || RobotAccountsListData {
            accounts: vec![
                make_robot_account_info("c", 30.0, Some(100)),
                make_robot_account_info("a", 90.0, None),
                make_robot_account_info("b", 50.0, Some(200)),
            ],
            total: 3,
            service: "openai".to_string(),
            pick_preview: None,
        };

        let json1 = serde_json::to_string(&build_data()).unwrap();
        let json2 = serde_json::to_string(&build_data()).unwrap();
        let json3 = serde_json::to_string(&build_data()).unwrap();

        assert_eq!(json1, json2);
        assert_eq!(json2, json3);
    }

    #[test]
    fn robot_accounts_refresh_json_schema() {
        let data = RobotAccountsRefreshData {
            service: "openai".to_string(),
            refreshed_count: 2,
            refreshed_at: Some("2026-01-28T12:00:00Z".to_string()),
            accounts: vec![
                make_robot_account_info("acc-1", 80.0, None),
                make_robot_account_info("acc-2", 40.0, None),
            ],
        };
        let json = serde_json::to_value(&data).unwrap();

        assert_eq!(json["service"].as_str().unwrap(), "openai");
        assert_eq!(json["refreshed_count"].as_u64().unwrap(), 2);
        assert_eq!(
            json["refreshed_at"].as_str().unwrap(),
            "2026-01-28T12:00:00Z"
        );
        assert_eq!(json["accounts"].as_array().unwrap().len(), 2);
    }

    #[test]
    fn robot_accounts_empty_list() {
        let data = RobotAccountsListData {
            accounts: vec![],
            total: 0,
            service: "openai".to_string(),
            pick_preview: None,
        };
        let json = serde_json::to_value(&data).unwrap();

        assert_eq!(json["total"].as_u64().unwrap(), 0);
        assert!(json["accounts"].as_array().unwrap().is_empty());
    }

    #[tokio::test]
    async fn robot_accounts_db_round_trip() {
        // End-to-end: insert accounts into DB, fetch, build robot response
        let (storage, db_path) = setup_storage("robot_accounts").await;

        let record = wa_core::accounts::AccountRecord {
            id: 0,
            account_id: "test-acc".to_string(),
            service: "openai".to_string(),
            name: Some("Test".to_string()),
            percent_remaining: 75.0,
            reset_at: None,
            tokens_used: Some(2500),
            tokens_remaining: Some(7500),
            tokens_limit: Some(10000),
            last_refreshed_at: 1000,
            last_used_at: None,
            created_at: 1000,
            updated_at: 1000,
        };
        storage.upsert_account(record).await.unwrap();

        let accounts = storage.get_accounts_by_service("openai").await.unwrap();
        assert_eq!(accounts.len(), 1);

        // Build the same robot response the handler would
        let total = accounts.len();
        let account_infos: Vec<RobotAccountInfo> = accounts
            .into_iter()
            .map(|a| RobotAccountInfo {
                account_id: a.account_id,
                service: a.service,
                name: a.name,
                percent_remaining: a.percent_remaining,
                reset_at: a.reset_at,
                tokens_used: a.tokens_used,
                tokens_remaining: a.tokens_remaining,
                tokens_limit: a.tokens_limit,
                last_refreshed_at: a.last_refreshed_at,
                last_used_at: a.last_used_at,
            })
            .collect();

        let data = RobotAccountsListData {
            accounts: account_infos,
            total,
            service: "openai".to_string(),
            pick_preview: None,
        };
        let json = serde_json::to_value(&data).unwrap();

        assert_eq!(json["total"].as_u64().unwrap(), 1);
        let acc = &json["accounts"][0];
        assert_eq!(acc["account_id"].as_str().unwrap(), "test-acc");
        assert!((acc["percent_remaining"].as_f64().unwrap() - 75.0).abs() < 0.001);

        cleanup_storage(storage, &db_path).await;
    }

    // =========================================================================
    // Robot accounts refresh + rate limiting tests (wa-nu4.1.5.5)
    // =========================================================================

    #[test]
    fn refresh_cooldown_allows_when_no_prior_refresh() {
        // No prior refresh (timestamp = 0) should always be allowed
        assert!(check_refresh_cooldown(0, 100_000, 30_000).is_none());
    }

    #[test]
    fn refresh_cooldown_allows_after_cooldown_expires() {
        let last_refresh = 100_000;
        let now = 131_000; // 31s later, cooldown is 30s
        assert!(check_refresh_cooldown(last_refresh, now, 30_000).is_none());
    }

    #[test]
    fn refresh_cooldown_blocks_within_cooldown() {
        let last_refresh = 100_000;
        let now = 110_000; // 10s later, cooldown is 30s
        let result = check_refresh_cooldown(last_refresh, now, 30_000);
        assert!(result.is_some());
        let (secs_ago, wait_secs) = result.unwrap();
        assert_eq!(secs_ago, 10);
        assert_eq!(wait_secs, 20);
    }

    #[test]
    fn refresh_cooldown_blocks_at_exact_boundary() {
        let last_refresh = 100_000;
        let now = 129_999; // 29.999s later, still within 30s
        let result = check_refresh_cooldown(last_refresh, now, 30_000);
        assert!(result.is_some());
    }

    #[test]
    fn refresh_cooldown_allows_at_exact_boundary() {
        let last_refresh = 100_000;
        let now = 130_000; // exactly 30s later
        assert!(check_refresh_cooldown(last_refresh, now, 30_000).is_none());
    }

    #[test]
    fn refresh_cooldown_allows_negative_timestamp() {
        // Negative last_refresh should be treated as no prior refresh
        assert!(check_refresh_cooldown(-1, 100_000, 30_000).is_none());
    }

    #[test]
    fn refresh_cooldown_constant_is_30_seconds() {
        assert_eq!(ROBOT_REFRESH_COOLDOWN_MS, 30_000);
    }

    #[tokio::test]
    async fn robot_refresh_db_mirror_round_trip() {
        // Simulate the refresh  DB mirror path:
        // Parse CautRefresh fixture  from_caut  upsert  verify DB state
        let (storage, db_path) = setup_storage("refresh_mirror").await;

        let fixture = wa_core::caut::CautRefresh {
            service: Some("openai".to_string()),
            refreshed_at: Some("2026-01-28T12:00:00Z".to_string()),
            accounts: vec![
                wa_core::caut::CautAccountUsage {
                    id: Some("acc-1".to_string()),
                    name: Some("Primary".to_string()),
                    percent_remaining: Some(85.0),
                    tokens_used: Some(1500),
                    tokens_remaining: Some(8500),
                    tokens_limit: Some(10000),
                    ..Default::default()
                },
                wa_core::caut::CautAccountUsage {
                    id: Some("acc-2".to_string()),
                    name: Some("Backup".to_string()),
                    percent_remaining: Some(20.0),
                    tokens_used: Some(8000),
                    tokens_remaining: Some(2000),
                    tokens_limit: Some(10000),
                    ..Default::default()
                },
            ],
            extra: Default::default(),
        };

        let now = 1706400000000_i64; // fixed timestamp for determinism

        // Mirror into DB (same as handler does)
        let mut account_infos = Vec::new();
        for usage in &fixture.accounts {
            let record = wa_core::accounts::AccountRecord::from_caut(
                usage,
                wa_core::caut::CautService::OpenAI,
                now,
            );
            storage.upsert_account(record.clone()).await.unwrap();
            account_infos.push(RobotAccountInfo {
                account_id: record.account_id,
                service: record.service,
                name: record.name,
                percent_remaining: record.percent_remaining,
                reset_at: record.reset_at,
                tokens_used: record.tokens_used,
                tokens_remaining: record.tokens_remaining,
                tokens_limit: record.tokens_limit,
                last_refreshed_at: record.last_refreshed_at,
                last_used_at: record.last_used_at,
            });
        }

        // Build response
        let data = RobotAccountsRefreshData {
            service: "openai".to_string(),
            refreshed_count: account_infos.len(),
            refreshed_at: fixture.refreshed_at,
            accounts: account_infos,
        };
        let json = serde_json::to_value(&data).unwrap();

        // Verify response structure
        assert_eq!(json["service"].as_str().unwrap(), "openai");
        assert_eq!(json["refreshed_count"].as_u64().unwrap(), 2);
        assert_eq!(json["accounts"].as_array().unwrap().len(), 2);

        // Verify DB state
        let db_accounts = storage.get_accounts_by_service("openai").await.unwrap();
        assert_eq!(db_accounts.len(), 2);
        // Sorted by percent_remaining DESC
        assert_eq!(db_accounts[0].account_id, "acc-1");
        assert!((db_accounts[0].percent_remaining - 85.0).abs() < 0.001);
        assert_eq!(db_accounts[1].account_id, "acc-2");
        assert!((db_accounts[1].percent_remaining - 20.0).abs() < 0.001);

        // Verify DB mirror is idempotent (refresh again with same data)
        for usage in &fixture.accounts {
            let record = wa_core::accounts::AccountRecord::from_caut(
                usage,
                wa_core::caut::CautService::OpenAI,
                now + 1000,
            );
            storage.upsert_account(record).await.unwrap();
        }
        let db_after = storage.get_accounts_by_service("openai").await.unwrap();
        assert_eq!(db_after.len(), 2); // still 2, not 4

        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn robot_refresh_db_mirror_updates_existing() {
        // Verify that refresh updates percent_remaining for existing accounts
        let (storage, db_path) = setup_storage("refresh_update").await;

        let now = 1706400000000_i64;

        // Initial insert
        let initial = wa_core::accounts::AccountRecord {
            id: 0,
            account_id: "acc-1".to_string(),
            service: "openai".to_string(),
            name: Some("Test".to_string()),
            percent_remaining: 90.0,
            reset_at: None,
            tokens_used: Some(1000),
            tokens_remaining: Some(9000),
            tokens_limit: Some(10000),
            last_refreshed_at: now,
            last_used_at: None,
            created_at: now,
            updated_at: now,
        };
        storage.upsert_account(initial).await.unwrap();

        // Simulate refresh with new usage data
        let refreshed_usage = wa_core::caut::CautAccountUsage {
            id: Some("acc-1".to_string()),
            name: Some("Test".to_string()),
            percent_remaining: Some(50.0), // changed
            tokens_used: Some(5000),       // changed
            tokens_remaining: Some(5000),  // changed
            tokens_limit: Some(10000),
            ..Default::default()
        };

        let record = wa_core::accounts::AccountRecord::from_caut(
            &refreshed_usage,
            wa_core::caut::CautService::OpenAI,
            now + 60_000, // 1 minute later
        );
        storage.upsert_account(record).await.unwrap();

        let db_accounts = storage.get_accounts_by_service("openai").await.unwrap();
        assert_eq!(db_accounts.len(), 1);
        assert!((db_accounts[0].percent_remaining - 50.0).abs() < 0.001);
        assert_eq!(db_accounts[0].tokens_used, Some(5000));
        assert_eq!(db_accounts[0].last_refreshed_at, now + 60_000);

        cleanup_storage(storage, &db_path).await;
    }

    // =========================================================================
    // Reservation data structure tests
    // =========================================================================

    #[test]
    fn robot_reservation_info_json_schema() {
        let info = RobotReservationInfo {
            id: 1,
            pane_id: 42,
            owner_kind: "workflow".to_string(),
            owner_id: "wf-123".to_string(),
            reason: Some("testing".to_string()),
            created_at: 1000,
            expires_at: 2000,
            released_at: None,
            status: "active".to_string(),
        };

        let json = serde_json::to_value(&info).unwrap();
        assert_eq!(json["id"].as_i64().unwrap(), 1);
        assert_eq!(json["pane_id"].as_u64().unwrap(), 42);
        assert_eq!(json["owner_kind"].as_str().unwrap(), "workflow");
        assert_eq!(json["owner_id"].as_str().unwrap(), "wf-123");
        assert_eq!(json["reason"].as_str().unwrap(), "testing");
        assert_eq!(json["status"].as_str().unwrap(), "active");
        // released_at should be absent (skip_serializing_if)
        assert!(json.get("released_at").is_none());
    }

    #[test]
    fn robot_reservation_info_skip_optional_fields() {
        let info = RobotReservationInfo {
            id: 1,
            pane_id: 1,
            owner_kind: "agent".to_string(),
            owner_id: "agent-x".to_string(),
            reason: None,
            created_at: 1000,
            expires_at: 2000,
            released_at: None,
            status: "active".to_string(),
        };

        let json = serde_json::to_value(&info).unwrap();
        // Both optional fields should be absent
        assert!(json.get("reason").is_none());
        assert!(json.get("released_at").is_none());
    }

    #[test]
    fn robot_reserve_data_json_schema() {
        let data = RobotReserveData {
            reservation: RobotReservationInfo {
                id: 5,
                pane_id: 7,
                owner_kind: "manual".to_string(),
                owner_id: "user-1".to_string(),
                reason: Some("testing reserve".to_string()),
                created_at: 3000,
                expires_at: 4000,
                released_at: None,
                status: "active".to_string(),
            },
        };

        let json = serde_json::to_value(&data).unwrap();
        assert!(json["reservation"].is_object());
        assert_eq!(json["reservation"]["id"].as_i64().unwrap(), 5);
        assert_eq!(json["reservation"]["pane_id"].as_u64().unwrap(), 7);
    }

    #[test]
    fn robot_release_data_json_schema() {
        let data = RobotReleaseData {
            reservation_id: 42,
            released: true,
        };

        let json = serde_json::to_value(&data).unwrap();
        assert_eq!(json["reservation_id"].as_i64().unwrap(), 42);
        assert_eq!(json["released"].as_bool().unwrap(), true);
    }

    #[test]
    fn robot_release_data_not_found() {
        let data = RobotReleaseData {
            reservation_id: 999,
            released: false,
        };

        let json = serde_json::to_value(&data).unwrap();
        assert_eq!(json["released"].as_bool().unwrap(), false);
    }

    #[test]
    fn robot_reservations_list_data_json_schema() {
        let data = RobotReservationsListData {
            reservations: vec![
                RobotReservationInfo {
                    id: 1,
                    pane_id: 10,
                    owner_kind: "workflow".to_string(),
                    owner_id: "wf-a".to_string(),
                    reason: Some("first".to_string()),
                    created_at: 1000,
                    expires_at: 2000,
                    released_at: None,
                    status: "active".to_string(),
                },
                RobotReservationInfo {
                    id: 2,
                    pane_id: 20,
                    owner_kind: "agent".to_string(),
                    owner_id: "agent-b".to_string(),
                    reason: None,
                    created_at: 1500,
                    expires_at: 2500,
                    released_at: None,
                    status: "active".to_string(),
                },
            ],
            total: 2,
        };

        let json = serde_json::to_value(&data).unwrap();
        assert_eq!(json["total"].as_u64().unwrap(), 2);
        assert_eq!(json["reservations"].as_array().unwrap().len(), 2);
        assert_eq!(
            json["reservations"][0]["owner_id"].as_str().unwrap(),
            "wf-a"
        );
        assert_eq!(
            json["reservations"][1]["owner_kind"].as_str().unwrap(),
            "agent"
        );
    }

    #[test]
    fn robot_reservations_list_empty() {
        let data = RobotReservationsListData {
            reservations: vec![],
            total: 0,
        };

        let json = serde_json::to_value(&data).unwrap();
        assert_eq!(json["total"].as_u64().unwrap(), 0);
        assert!(json["reservations"].as_array().unwrap().is_empty());
    }

    // =========================================================================
    // Reservation DB integration tests
    // =========================================================================

    #[tokio::test]
    async fn reservation_create_and_list() {
        let (storage, db_path) = setup_storage("res_create_list").await;

        // Insert a pane for FK
        let pane = PaneRecord {
            pane_id: 100,
            pane_uuid: None,
            domain: "local".to_string(),
            window_id: None,
            tab_id: None,
            title: Some("test".to_string()),
            cwd: Some("/tmp".to_string()),
            tty_name: None,
            first_seen_at: now_ms(),
            last_seen_at: now_ms(),
            observed: true,
            ignore_reason: None,
            last_decision_at: None,
        };
        storage.upsert_pane(pane).await.unwrap();

        // Create a reservation
        let r = storage
            .create_reservation(100, "agent", "test-agent", Some("testing"), 60_000)
            .await
            .unwrap();
        assert_eq!(r.pane_id, 100);
        assert_eq!(r.owner_kind, "agent");

        // List should show it
        let list = storage.list_active_reservations().await.unwrap();
        assert_eq!(list.len(), 1);
        assert_eq!(list[0].id, r.id);

        // Release it
        let released = storage.release_reservation(r.id).await.unwrap();
        assert!(released);

        // List should be empty now
        let list = storage.list_active_reservations().await.unwrap();
        assert!(list.is_empty());

        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn reservation_conflict_detection() {
        let (storage, db_path) = setup_storage("res_conflict").await;

        let pane = PaneRecord {
            pane_id: 200,
            pane_uuid: None,
            domain: "local".to_string(),
            window_id: None,
            tab_id: None,
            title: Some("test".to_string()),
            cwd: Some("/tmp".to_string()),
            tty_name: None,
            first_seen_at: now_ms(),
            last_seen_at: now_ms(),
            observed: true,
            ignore_reason: None,
            last_decision_at: None,
        };
        storage.upsert_pane(pane).await.unwrap();

        // First reservation succeeds
        let _r1 = storage
            .create_reservation(200, "workflow", "wf-1", None, 600_000)
            .await
            .unwrap();

        // Second reservation on same pane fails
        let r2 = storage
            .create_reservation(200, "workflow", "wf-2", None, 60_000)
            .await;
        assert!(r2.is_err());

        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn reservation_expire_stale() {
        let (storage, db_path) = setup_storage("res_expire").await;

        let pane = PaneRecord {
            pane_id: 300,
            pane_uuid: None,
            domain: "local".to_string(),
            window_id: None,
            tab_id: None,
            title: Some("test".to_string()),
            cwd: Some("/tmp".to_string()),
            tty_name: None,
            first_seen_at: now_ms(),
            last_seen_at: now_ms(),
            observed: true,
            ignore_reason: None,
            last_decision_at: None,
        };
        storage.upsert_pane(pane).await.unwrap();

        // Create a reservation with very short TTL (already effectively expired in processing)
        // Use the storage directly - insert a past-expiry record
        let r = storage
            .create_reservation(300, "workflow", "wf-old", None, 60_000)
            .await
            .unwrap();

        // Active before expiry
        let active = storage.get_active_reservation(300).await.unwrap();
        assert!(active.is_some());

        // Release it so we can test the list is clean after
        storage.release_reservation(r.id).await.unwrap();
        let active = storage.get_active_reservation(300).await.unwrap();
        assert!(active.is_none());

        cleanup_storage(storage, &db_path).await;
    }

    #[test]
    fn reservation_info_from_pane_reservation() {
        // Verify the mapping from PaneReservation to RobotReservationInfo
        let r = wa_core::storage::PaneReservation {
            id: 10,
            pane_id: 5,
            owner_kind: "agent".to_string(),
            owner_id: "agent-x".to_string(),
            reason: Some("migration".to_string()),
            created_at: 1000,
            expires_at: 61_000,
            released_at: None,
            status: "active".to_string(),
        };

        let info = RobotReservationInfo {
            id: r.id,
            pane_id: r.pane_id,
            owner_kind: r.owner_kind.clone(),
            owner_id: r.owner_id.clone(),
            reason: r.reason.clone(),
            created_at: r.created_at,
            expires_at: r.expires_at,
            released_at: r.released_at,
            status: r.status.clone(),
        };

        assert_eq!(info.id, 10);
        assert_eq!(info.pane_id, 5);
        assert_eq!(info.owner_kind, "agent");
        assert_eq!(info.reason.as_deref(), Some("migration"));
        assert!(r.is_active(30_000));
    }

    // =========================================================================
    // Auth command tests (browser feature)
    // =========================================================================

    #[cfg(feature = "browser")]
    mod auth_tests {
        use super::*;

        #[test]
        fn auth_test_outcome_success_json() {
            let outcome = AuthTestOutcome::Success {
                service: "openai".into(),
                account: "default".into(),
                elapsed_ms: Some(1234),
                last_bootstrapped: Some("2025-01-01T00:00:00Z".into()),
            };
            let json = serde_json::to_string(&outcome).unwrap();
            assert!(json.contains(r#""outcome":"success""#));
            assert!(json.contains(r#""service":"openai""#));
            assert!(json.contains(r#""elapsed_ms":1234"#));
        }

        #[test]
        fn auth_test_outcome_needs_human_json() {
            let outcome = AuthTestOutcome::NeedsHuman {
                service: "openai".into(),
                account: "work".into(),
                reason: "No profile".into(),
                next_step: "wa auth bootstrap openai".into(),
            };
            let json = serde_json::to_string(&outcome).unwrap();
            assert!(json.contains(r#""outcome":"needs_human""#));
            assert!(json.contains(r#""reason":"No profile""#));
            assert!(json.contains(r#""next_step""#));
        }

        #[test]
        fn auth_test_outcome_fail_json() {
            let outcome = AuthTestOutcome::Fail {
                service: "openai".into(),
                account: "default".into(),
                error: "Browser init failed".into(),
                next_step: None,
            };
            let json = serde_json::to_string(&outcome).unwrap();
            assert!(json.contains(r#""outcome":"fail""#));
            assert!(json.contains(r#""error":"Browser init failed""#));
            // next_step should be absent (skip_serializing_if = None)
            assert!(!json.contains(r#""next_step""#));
        }

        #[test]
        fn auth_test_outcome_fail_with_next_step() {
            let outcome = AuthTestOutcome::Fail {
                service: "openai".into(),
                account: "default".into(),
                error: "something".into(),
                next_step: Some("do this".into()),
            };
            let json = serde_json::to_string(&outcome).unwrap();
            assert!(json.contains(r#""next_step":"do this""#));
        }

        #[test]
        fn auth_test_outcome_success_omits_none_fields() {
            let outcome = AuthTestOutcome::Success {
                service: "openai".into(),
                account: "default".into(),
                elapsed_ms: None,
                last_bootstrapped: None,
            };
            let json = serde_json::to_string(&outcome).unwrap();
            assert!(!json.contains("elapsed_ms"));
            assert!(!json.contains("last_bootstrapped"));
        }

        #[test]
        fn auth_profile_status_serialization() {
            let status = AuthProfileStatus {
                service: "openai".into(),
                account: "default".into(),
                profile_exists: true,
                has_storage_state: true,
                bootstrapped_at: Some("2025-06-01T00:00:00Z".into()),
                bootstrap_method: Some("interactive".into()),
                last_used_at: Some("2025-06-02T00:00:00Z".into()),
                automated_use_count: Some(42),
            };
            let json = serde_json::to_string_pretty(&status).unwrap();
            assert!(json.contains(r#""profile_exists": true"#));
            assert!(json.contains(r#""has_storage_state": true"#));
            assert!(json.contains(r#""automated_use_count": 42"#));
        }

        #[test]
        fn auth_profile_status_omits_none_fields() {
            let status = AuthProfileStatus {
                service: "openai".into(),
                account: "default".into(),
                profile_exists: false,
                has_storage_state: false,
                bootstrapped_at: None,
                bootstrap_method: None,
                last_used_at: None,
                automated_use_count: None,
            };
            let json = serde_json::to_string(&status).unwrap();
            assert!(!json.contains("bootstrapped_at"));
            assert!(!json.contains("bootstrap_method"));
            assert!(!json.contains("last_used_at"));
            assert!(!json.contains("automated_use_count"));
        }

        #[test]
        fn build_profile_status_no_profile() {
            let tmp = std::env::temp_dir().join(format!("wa_auth_test_{}", std::process::id()));
            let _ = std::fs::create_dir_all(&tmp);

            let profile = wa_core::browser::BrowserProfile::new(
                &tmp,
                "nonexistent_service",
                "nonexistent_account",
            );
            let status = build_profile_status(&profile);

            assert_eq!(status.service, "nonexistent_service");
            assert_eq!(status.account, "nonexistent_account");
            assert!(!status.profile_exists);
            assert!(!status.has_storage_state);
            assert!(status.bootstrapped_at.is_none());
            assert!(status.bootstrap_method.is_none());

            let _ = std::fs::remove_dir_all(&tmp);
        }

        #[test]
        fn build_profile_status_with_profile_dir() {
            let tmp =
                std::env::temp_dir().join(format!("wa_auth_test_profile_{}", std::process::id()));
            let _ = std::fs::create_dir_all(&tmp);

            let profile = wa_core::browser::BrowserProfile::new(&tmp, "testservice", "testaccount");
            let _ = profile.ensure_dir();

            let status = build_profile_status(&profile);
            assert!(status.profile_exists);
            assert!(!status.has_storage_state);
            assert!(status.bootstrapped_at.is_none());

            let _ = std::fs::remove_dir_all(&tmp);
        }

        #[test]
        fn build_profile_status_with_metadata() {
            let tmp =
                std::env::temp_dir().join(format!("wa_auth_test_meta_{}", std::process::id()));
            let _ = std::fs::create_dir_all(&tmp);

            let profile = wa_core::browser::BrowserProfile::new(&tmp, "openai", "default");
            let _ = profile.ensure_dir();

            let mut metadata = wa_core::browser::ProfileMetadata::new("openai", "default");
            metadata.record_bootstrap(wa_core::browser::BootstrapMethod::Interactive);
            metadata.record_use();
            let _ = profile.write_metadata(&metadata);

            let status = build_profile_status(&profile);
            assert!(status.profile_exists);
            assert!(status.bootstrapped_at.is_some());
            assert_eq!(status.bootstrap_method.as_deref(), Some("interactive"));
            assert!(status.last_used_at.is_some());
            assert_eq!(status.automated_use_count, Some(1));

            let _ = std::fs::remove_dir_all(&tmp);
        }

        #[test]
        fn build_profile_status_with_storage_state() {
            let tmp =
                std::env::temp_dir().join(format!("wa_auth_test_storage_{}", std::process::id()));
            let _ = std::fs::create_dir_all(&tmp);

            let profile = wa_core::browser::BrowserProfile::new(&tmp, "openai", "default");
            let _ = profile.ensure_dir();
            let _ = profile.save_storage_state(b"{\"cookies\": []}");

            let status = build_profile_status(&profile);
            assert!(status.profile_exists);
            assert!(status.has_storage_state);

            let _ = std::fs::remove_dir_all(&tmp);
        }
    }

    // --- Version metadata tests ---

    #[test]
    fn version_short_is_non_empty_and_contains_semver() {
        let v = build_meta::short_version();
        assert!(!v.is_empty());
        // Must contain a semver-like pattern (X.Y.Z)
        assert!(
            v.contains('.'),
            "short version should contain semver dots: {v}"
        );
        // Must contain a commit hash in parens
        assert!(
            v.contains('(') && v.contains(')'),
            "short version should contain commit hash in parens: {v}"
        );
    }

    #[test]
    fn version_short_has_no_ansi_escapes() {
        let v = build_meta::short_version();
        assert!(
            !v.contains('\x1b'),
            "short version must not contain ANSI escapes: {v}"
        );
    }

    #[test]
    fn version_verbose_includes_all_fields() {
        let v = build_meta::verbose_version();
        assert!(
            v.contains("wa "),
            "verbose version should start with 'wa ': {v}"
        );
        assert!(
            v.contains("commit:"),
            "verbose version should contain commit field: {v}"
        );
        assert!(
            v.contains("built:"),
            "verbose version should contain built field: {v}"
        );
        assert!(
            v.contains("rustc:"),
            "verbose version should contain rustc field: {v}"
        );
        assert!(
            v.contains("target:"),
            "verbose version should contain target field: {v}"
        );
        assert!(
            v.contains("features:"),
            "verbose version should contain features field: {v}"
        );
    }

    #[test]
    fn version_verbose_has_no_ansi_escapes() {
        let v = build_meta::verbose_version();
        assert!(
            !v.contains('\x1b'),
            "verbose version must not contain ANSI escapes: {v}"
        );
    }

    #[test]
    fn version_verbose_field_ordering_is_stable() {
        let v = build_meta::verbose_version();
        let lines: Vec<&str> = v.lines().collect();
        // First line is the version header
        assert!(
            lines[0].starts_with("wa "),
            "first line should be version header"
        );
        // Fields must appear in a stable order
        let field_positions: Vec<_> = ["commit:", "built:", "rustc:", "target:", "features:"]
            .iter()
            .map(|field| {
                v.find(field)
                    .unwrap_or_else(|| panic!("missing field: {field}"))
            })
            .collect();
        // Each field must appear after the previous one
        for window in field_positions.windows(2) {
            assert!(window[0] < window[1], "fields must appear in stable order");
        }
    }

    //  Robot Workflow Command Tests (bd-qvbz) 

    #[test]
    fn robot_response_success_envelope_has_required_fields() {
        let data = RobotWorkflowListData {
            workflows: vec![],
            total: 0,
            enabled_count: Some(0),
        };
        let resp = RobotResponse::success(data, 42);
        let json = serde_json::to_value(&resp).unwrap();

        assert_eq!(json["ok"], true);
        assert!(json["data"].is_object());
        assert!(json["error"].is_null());
        assert!(json["error_code"].is_null());
        assert!(json["hint"].is_null());
        assert_eq!(json["elapsed_ms"], 42);
        assert!(json["version"].is_string());
        assert!(json["now"].is_number());
    }

    #[test]
    fn robot_response_error_envelope_has_required_fields() {
        let resp = RobotResponse::<RobotWorkflowAbortData>::error_with_code(
            "E_EXECUTION_NOT_FOUND",
            "Execution not found",
            Some("Use --active to list running workflows.".to_string()),
            99,
        );
        let json = serde_json::to_value(&resp).unwrap();

        assert_eq!(json["ok"], false);
        assert!(json["data"].is_null());
        assert_eq!(json["error"], "Execution not found");
        assert_eq!(json["error_code"], "E_EXECUTION_NOT_FOUND");
        assert_eq!(json["hint"], "Use --active to list running workflows.");
        assert_eq!(json["elapsed_ms"], 99);
        assert!(json["version"].is_string());
        assert!(json["now"].is_number());
    }

    #[test]
    fn robot_workflow_list_returns_all_four_workflows() {
        // Replicate the hardcoded list from the List handler to verify completeness.
        let workflows: Vec<RobotWorkflowInfo> = vec![
            RobotWorkflowInfo {
                name: "handle_compaction".to_string(),
                description: Some(
                    "Re-inject critical context after conversation compaction".to_string(),
                ),
                enabled: true,
                trigger_event_types: Some(vec!["compaction_warning".to_string()]),
                requires_pane: Some(true),
            },
            RobotWorkflowInfo {
                name: "handle_usage_limits".to_string(),
                description: Some("Handle API usage limit reached events".to_string()),
                enabled: true,
                trigger_event_types: Some(vec!["usage_limit".to_string()]),
                requires_pane: Some(true),
            },
            RobotWorkflowInfo {
                name: "handle_session_end".to_string(),
                description: Some(
                    "Capture and store structured session summary on agent session end".to_string(),
                ),
                enabled: true,
                trigger_event_types: Some(vec!["session_end".to_string()]),
                requires_pane: Some(true),
            },
            RobotWorkflowInfo {
                name: "handle_auth_required".to_string(),
                description: Some(
                    "Handle authentication prompts requiring user intervention or automated login"
                        .to_string(),
                ),
                enabled: true,
                trigger_event_types: Some(vec!["auth_required".to_string()]),
                requires_pane: Some(true),
            },
            RobotWorkflowInfo {
                name: "handle_claude_code_limits".to_string(),
                description: Some(
                    "Safe-pause on Claude Code usage/rate limits with recovery plan".to_string(),
                ),
                enabled: true,
                trigger_event_types: Some(vec![
                    "usage.warning".to_string(),
                    "usage.reached".to_string(),
                ]),
                requires_pane: Some(true),
            },
            RobotWorkflowInfo {
                name: "handle_gemini_quota".to_string(),
                description: Some(
                    "Safe-pause on Gemini quota/usage limits with recovery plan".to_string(),
                ),
                enabled: true,
                trigger_event_types: Some(vec![
                    "usage.warning".to_string(),
                    "usage.reached".to_string(),
                ]),
                requires_pane: Some(true),
            },
        ];

        assert_eq!(workflows.len(), 6, "must list exactly 6 workflows");
        let names: Vec<&str> = workflows.iter().map(|w| w.name.as_str()).collect();
        assert!(names.contains(&"handle_compaction"));
        assert!(names.contains(&"handle_usage_limits"));
        assert!(names.contains(&"handle_session_end"));
        assert!(names.contains(&"handle_auth_required"));
        assert!(names.contains(&"handle_claude_code_limits"));
        assert!(names.contains(&"handle_gemini_quota"));
        assert!(
            workflows.iter().all(|w| w.enabled),
            "all workflows must be enabled"
        );
    }

    #[test]
    fn robot_workflow_list_data_serialization_matches_schema() {
        let workflows = vec![RobotWorkflowInfo {
            name: "handle_compaction".to_string(),
            description: Some("Test workflow".to_string()),
            enabled: true,
            trigger_event_types: Some(vec!["compaction_warning".to_string()]),
            requires_pane: Some(true),
        }];
        let data = RobotWorkflowListData {
            workflows,
            total: 1,
            enabled_count: Some(1),
        };

        let json = serde_json::to_value(&data).unwrap();

        // Schema requires: workflows (array), total (integer)
        assert!(json["workflows"].is_array());
        assert_eq!(json["total"], 1);
        assert_eq!(json["enabled_count"], 1);

        let wf = &json["workflows"][0];
        assert_eq!(wf["name"], "handle_compaction");
        assert_eq!(wf["description"], "Test workflow");
        assert_eq!(wf["enabled"], true);
        assert_eq!(wf["trigger_event_types"][0], "compaction_warning");
        assert_eq!(wf["requires_pane"], true);
    }

    #[test]
    fn robot_workflow_abort_data_serializes_forced_field() {
        let data = RobotWorkflowAbortData {
            execution_id: "exec-123".to_string(),
            aborted: true,
            forced: true,
            workflow_name: Some("handle_compaction".to_string()),
            previous_status: Some("running".to_string()),
            reason: Some("test abort".to_string()),
            aborted_at: Some(1700000000000),
            error_reason: None,
        };

        let json = serde_json::to_value(&data).unwrap();

        // Schema required fields: execution_id, aborted, forced
        assert_eq!(json["execution_id"], "exec-123");
        assert_eq!(json["aborted"], true);
        assert_eq!(json["forced"], true);
        assert_eq!(json["workflow_name"], "handle_compaction");
        assert_eq!(json["previous_status"], "running");
        assert_eq!(json["reason"], "test abort");
        assert_eq!(json["aborted_at"], 1700000000000_u64);
        // error_reason is None  must be absent (skip_serializing_if)
        assert!(json.get("error_reason").is_none());
    }

    #[test]
    fn robot_workflow_abort_data_not_aborted_includes_error_reason() {
        let data = RobotWorkflowAbortData {
            execution_id: "exec-456".to_string(),
            aborted: false,
            forced: false,
            workflow_name: None,
            previous_status: None,
            reason: None,
            aborted_at: None,
            error_reason: Some("already_completed".to_string()),
        };

        let json = serde_json::to_value(&data).unwrap();

        assert_eq!(json["aborted"], false);
        assert_eq!(json["forced"], false);
        assert_eq!(json["error_reason"], "already_completed");
        // Optional fields should be absent when None
        assert!(json.get("workflow_name").is_none());
        assert!(json.get("previous_status").is_none());
        assert!(json.get("reason").is_none());
        assert!(json.get("aborted_at").is_none());
    }

    #[test]
    fn robot_workflow_status_data_serialization() {
        let data = RobotWorkflowStatusData {
            execution_id: "exec-789".to_string(),
            workflow_name: "handle_usage_limits".to_string(),
            pane_id: Some(42),
            trigger_event_id: Some(100),
            status: "running".to_string(),
            step_name: Some("rate_limit_check".to_string()),
            elapsed_ms: Some(1500),
            last_step_result: Some("success".to_string()),
            current_step: Some(2),
            total_steps: Some(5),
            wait_condition: None,
            context: None,
            result: None,
            error: None,
            started_at: Some(1700000000000),
            updated_at: None,
            completed_at: None,
            step_logs: None,
            action_plan: None,
        };

        let json = serde_json::to_value(&data).unwrap();

        // Schema required: execution_id, workflow_name, status
        assert_eq!(json["execution_id"], "exec-789");
        assert_eq!(json["workflow_name"], "handle_usage_limits");
        assert_eq!(json["status"], "running");
        assert_eq!(json["pane_id"], 42);
        assert_eq!(json["trigger_event_id"], 100);
        assert_eq!(json["step_name"], "rate_limit_check");
        assert_eq!(json["current_step"], 2);
        assert_eq!(json["total_steps"], 5);
        // completed_at is None  must be absent
        assert!(json.get("completed_at").is_none());
    }

    #[test]
    fn robot_workflow_status_list_data_serialization() {
        let data = RobotWorkflowStatusListData {
            executions: vec![],
            pane_filter: Some(42),
            active_only: Some(true),
            count: 0,
        };

        let json = serde_json::to_value(&data).unwrap();

        assert!(json["executions"].is_array());
        assert_eq!(json["executions"].as_array().unwrap().len(), 0);
        assert_eq!(json["pane_filter"], 42);
        assert_eq!(json["active_only"], true);
        assert_eq!(json["count"], 0);
    }

    #[test]
    fn robot_error_code_constants_are_stable() {
        // Error codes are part of the robot mode API contract and must not change.
        assert_eq!(ROBOT_ERR_INVALID_ARGS, "robot.invalid_args");
        assert_eq!(ROBOT_ERR_UNKNOWN_SUBCOMMAND, "robot.unknown_subcommand");
        assert_eq!(ROBOT_ERR_CONFIG, "robot.config_error");
        assert_eq!(ROBOT_ERR_FTS_QUERY, "robot.fts_query_error");
        assert_eq!(ROBOT_ERR_STORAGE, "robot.storage_error");
    }

    #[test]
    fn robot_workflow_abort_response_wraps_in_envelope() {
        let data = RobotWorkflowAbortData {
            execution_id: "exec-abc".to_string(),
            aborted: true,
            forced: false,
            workflow_name: Some("handle_session_end".to_string()),
            previous_status: Some("running".to_string()),
            reason: None,
            aborted_at: Some(1700000000000),
            error_reason: None,
        };
        let resp = RobotResponse::success(data, 55);
        let json = serde_json::to_value(&resp).unwrap();

        // Envelope structure
        assert_eq!(json["ok"], true);
        assert_eq!(json["elapsed_ms"], 55);

        // Data payload
        let d = &json["data"];
        assert_eq!(d["execution_id"], "exec-abc");
        assert_eq!(d["aborted"], true);
        assert_eq!(d["forced"], false);
        assert_eq!(d["workflow_name"], "handle_session_end");
    }

    #[test]
    fn robot_workflow_list_toon_roundtrip() {
        let workflows = vec![
            RobotWorkflowInfo {
                name: "handle_compaction".to_string(),
                description: Some("Test".to_string()),
                enabled: true,
                trigger_event_types: Some(vec!["compaction_warning".to_string()]),
                requires_pane: Some(true),
            },
            RobotWorkflowInfo {
                name: "handle_usage_limits".to_string(),
                description: Some("Test 2".to_string()),
                enabled: true,
                trigger_event_types: Some(vec!["usage_limit".to_string()]),
                requires_pane: Some(true),
            },
        ];
        let data = RobotWorkflowListData {
            workflows,
            total: 2,
            enabled_count: Some(2),
        };
        let resp = RobotResponse::success(data, 10);
        let json_value = serde_json::to_value(&resp).unwrap();

        // Encode to TOON and decode back
        let toon = toon_rust::encode(json_value.clone(), None);
        let decoded = toon_rust::try_decode(&toon, None).unwrap();
        let json_str = toon_rust::cli::json_stringify::json_stringify_lines(&decoded, 0).join("\n");
        let roundtripped: serde_json::Value = serde_json::from_str(&json_str).unwrap();

        // Verify key fields survive the roundtrip
        assert_eq!(roundtripped["ok"], json_value["ok"]);
        assert_eq!(
            roundtripped["data"]["total"].as_f64().unwrap() as usize,
            json_value["data"]["total"].as_u64().unwrap() as usize
        );
        let rt_workflows = roundtripped["data"]["workflows"].as_array().unwrap();
        assert_eq!(rt_workflows.len(), 2);
        assert_eq!(rt_workflows[0]["name"], "handle_compaction");
        assert_eq!(rt_workflows[1]["name"], "handle_usage_limits");
    }

    // ========================================================================
    // CLI Parsing Tests  workflow subcommands (bd-qvbz)
    // ========================================================================

    #[test]
    fn cli_workflow_run_parses_name_and_pane() {
        let cli = Cli::try_parse_from(["wa", "robot", "workflow", "run", "handle_compaction", "3"])
            .expect("workflow run should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Workflow {
                    command: RobotWorkflowCommands::Run { name, pane_id, .. },
                }) => {
                    assert_eq!(name, "handle_compaction");
                    assert_eq!(pane_id, 3);
                }
                _ => panic!("expected Workflow::Run"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn cli_workflow_run_rejects_missing_pane() {
        let result = Cli::try_parse_from(["wa", "robot", "workflow", "run", "handle_compaction"]);
        assert!(result.is_err(), "workflow run without pane_id should fail");
    }

    #[test]
    fn cli_workflow_run_dry_run_flag() {
        let cli = Cli::try_parse_from([
            "wa",
            "robot",
            "workflow",
            "run",
            "handle_compaction",
            "5",
            "--dry-run",
        ])
        .expect("workflow run --dry-run should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Workflow {
                    command: RobotWorkflowCommands::Run { dry_run, .. },
                }) => {
                    assert!(dry_run, "dry_run flag should be true");
                }
                _ => panic!("expected Workflow::Run"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn cli_workflow_list_parses() {
        let cli = Cli::try_parse_from(["wa", "robot", "workflow", "list"])
            .expect("workflow list should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Workflow {
                    command: RobotWorkflowCommands::List,
                }) => {}
                _ => panic!("expected Workflow::List"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn cli_workflow_status_by_execution_id() {
        let cli = Cli::try_parse_from(["wa", "robot", "workflow", "status", "wf-abc123"])
            .expect("workflow status should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Workflow {
                    command:
                        RobotWorkflowCommands::Status {
                            execution_id,
                            pane,
                            active,
                            ..
                        },
                }) => {
                    assert_eq!(execution_id.as_deref(), Some("wf-abc123"));
                    assert!(pane.is_none());
                    assert!(!active);
                }
                _ => panic!("expected Workflow::Status"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn cli_workflow_status_by_pane() {
        let cli = Cli::try_parse_from(["wa", "robot", "workflow", "status", "--pane", "7"])
            .expect("workflow status --pane should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Workflow {
                    command:
                        RobotWorkflowCommands::Status {
                            execution_id, pane, ..
                        },
                }) => {
                    assert!(execution_id.is_none());
                    assert_eq!(pane, Some(7));
                }
                _ => panic!("expected Workflow::Status"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn cli_workflow_status_active_flag() {
        let cli = Cli::try_parse_from(["wa", "robot", "workflow", "status", "--active"])
            .expect("workflow status --active should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Workflow {
                    command: RobotWorkflowCommands::Status { active, .. },
                }) => {
                    assert!(active);
                }
                _ => panic!("expected Workflow::Status"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn cli_workflow_abort_parses_execution_id() {
        let cli = Cli::try_parse_from(["wa", "robot", "workflow", "abort", "wf-xyz789"])
            .expect("workflow abort should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Workflow {
                    command:
                        RobotWorkflowCommands::Abort {
                            execution_id,
                            reason,
                            force,
                        },
                }) => {
                    assert_eq!(execution_id, "wf-xyz789");
                    assert!(reason.is_none());
                    assert!(!force);
                }
                _ => panic!("expected Workflow::Abort"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn cli_workflow_abort_with_reason_and_force() {
        let cli = Cli::try_parse_from([
            "wa",
            "robot",
            "workflow",
            "abort",
            "wf-xyz789",
            "--reason",
            "Manual intervention",
            "--force",
        ])
        .expect("workflow abort with reason and force should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Workflow {
                    command:
                        RobotWorkflowCommands::Abort {
                            execution_id,
                            reason,
                            force,
                        },
                }) => {
                    assert_eq!(execution_id, "wf-xyz789");
                    assert_eq!(reason.as_deref(), Some("Manual intervention"));
                    assert!(force);
                }
                _ => panic!("expected Workflow::Abort"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn cli_workflow_abort_rejects_missing_execution_id() {
        let result = Cli::try_parse_from(["wa", "robot", "workflow", "abort"]);
        assert!(
            result.is_err(),
            "workflow abort without execution_id should fail"
        );
    }

    #[test]
    fn cli_events_unhandled_flag() {
        let cli = Cli::try_parse_from(["wa", "robot", "events", "--unhandled"])
            .expect("events --unhandled should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Events { unhandled, .. }) => {
                    assert!(unhandled, "--unhandled flag should be true");
                }
                _ => panic!("expected Events"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn cli_events_unhandled_only_alias() {
        let cli = Cli::try_parse_from(["wa", "robot", "events", "--unhandled-only"])
            .expect("events --unhandled-only should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Robot { command, .. }) => match command {
                Some(RobotCommands::Events { unhandled, .. }) => {
                    assert!(
                        unhandled,
                        "--unhandled-only alias should set unhandled=true"
                    );
                }
                _ => panic!("expected Events"),
            },
            _ => panic!("expected Robot command"),
        }
    }

    #[test]
    fn cli_notify_test_parses() {
        let cli = Cli::try_parse_from(["wa", "notify", "test", "--channel", "desktop"])
            .expect("notify test should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Notify { command }) => match command {
                NotifyCommands::Test { channel, format } => {
                    assert_eq!(channel, "desktop");
                    assert_eq!(format, "auto");
                }
            },
            _ => panic!("expected Notify command"),
        }
    }

    // ========================================================================
    // Error code stability  workflow-specific codes (bd-qvbz)
    // ========================================================================

    #[test]
    fn robot_workflow_status_error_missing_params() {
        // When no execution_id, --pane, or --active is provided, the handler
        // should produce E_MISSING_ARGUMENT. Test the error envelope shape.
        let response = RobotResponse::<RobotWorkflowStatusData>::error_with_code(
            "E_MISSING_ARGUMENT",
            "Provide --execution-id, --pane, or --active".to_string(),
            Some("Use `wa robot workflow status --active` to list running workflows".to_string()),
            5,
        );
        let json = serde_json::to_value(&response).unwrap();
        assert_eq!(json["ok"], false);
        assert_eq!(json["error_code"], "E_MISSING_ARGUMENT");
        assert!(json["hint"].is_string());
    }

    #[test]
    fn robot_workflow_status_error_not_found() {
        let response = RobotResponse::<RobotWorkflowStatusData>::error_with_code(
            "E_EXECUTION_NOT_FOUND",
            "No workflow execution found with ID: wf-nonexistent".to_string(),
            Some("Use `wa robot workflow status --active` to list running workflows".to_string()),
            3,
        );
        let json = serde_json::to_value(&response).unwrap();
        assert_eq!(json["ok"], false);
        assert_eq!(json["error_code"], "E_EXECUTION_NOT_FOUND");
        assert!(json["error"].as_str().unwrap().contains("wf-nonexistent"));
    }

    // ========================================================================
    // Human workflow CLI parsing tests (wa-nu4.3.2.8)
    // ========================================================================

    #[test]
    fn human_workflow_list_parses() {
        let cli =
            Cli::try_parse_from(["wa", "workflow", "list"]).expect("workflow list should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Workflow {
                command: WorkflowCommands::List,
            }) => {}
            _ => panic!("expected Workflow::List"),
        }
    }

    #[test]
    fn human_workflow_run_parses_name_and_pane() {
        let cli =
            Cli::try_parse_from(["wa", "workflow", "run", "handle_compaction", "--pane", "5"])
                .expect("workflow run should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Workflow {
                command:
                    WorkflowCommands::Run {
                        name,
                        pane,
                        dry_run,
                    },
            }) => {
                assert_eq!(name, "handle_compaction");
                assert_eq!(pane, 5);
                assert!(!dry_run);
            }
            _ => panic!("expected Workflow::Run"),
        }
    }

    #[test]
    fn human_workflow_run_dry_run_flag() {
        let cli = Cli::try_parse_from([
            "wa",
            "workflow",
            "run",
            "handle_usage_limits",
            "--pane",
            "3",
            "--dry-run",
        ])
        .expect("workflow run --dry-run should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Workflow {
                command: WorkflowCommands::Run { dry_run, .. },
            }) => {
                assert!(dry_run, "--dry-run flag should be true");
            }
            _ => panic!("expected Workflow::Run"),
        }
    }

    #[test]
    fn human_workflow_run_rejects_missing_pane() {
        let result = Cli::try_parse_from(["wa", "workflow", "run", "handle_compaction"]);
        assert!(result.is_err(), "workflow run without --pane should fail");
    }

    #[test]
    fn human_workflow_status_parses_execution_id() {
        let cli =
            Cli::try_parse_from(["wa", "workflow", "status", "human-handle_compaction-123456"])
                .expect("workflow status should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Workflow {
                command:
                    WorkflowCommands::Status {
                        execution_id,
                        verbose,
                    },
            }) => {
                assert_eq!(execution_id, "human-handle_compaction-123456");
                assert_eq!(verbose, 0);
            }
            _ => panic!("expected Workflow::Status"),
        }
    }

    #[test]
    fn human_workflow_status_verbose_flag() {
        let cli = Cli::try_parse_from(["wa", "workflow", "status", "wf-abc", "-v"])
            .expect("workflow status -v should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Workflow {
                command: WorkflowCommands::Status { verbose, .. },
            }) => {
                assert_eq!(verbose, 1, "-v should set verbose=1");
            }
            _ => panic!("expected Workflow::Status"),
        }
    }

    #[test]
    fn human_workflow_status_double_verbose() {
        let cli = Cli::try_parse_from(["wa", "workflow", "status", "wf-abc", "-vv"])
            .expect("workflow status -vv should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Workflow {
                command: WorkflowCommands::Status { verbose, .. },
            }) => {
                assert_eq!(verbose, 2, "-vv should set verbose=2");
            }
            _ => panic!("expected Workflow::Status"),
        }
    }

    #[test]
    fn cli_search_parses_bookmark_filters() {
        let cli = Cli::try_parse_from([
            "wa",
            "search",
            "error",
            "--bookmark",
            "build",
            "--bookmark-tag",
            "prod",
        ])
        .expect("search bookmark filters should parse");

        match cli.command.map(|b| *b) {
            Some(Commands::Search {
                query,
                bookmark,
                bookmark_tag,
                ..
            }) => {
                assert_eq!(query.as_deref(), Some("error"));
                assert_eq!(bookmark.as_deref(), Some("build"));
                assert_eq!(bookmark_tag.as_deref(), Some("prod"));
            }
            _ => panic!("expected Search command"),
        }
    }

    #[test]
    fn cli_status_parses_bookmark_filters() {
        let cli = Cli::try_parse_from([
            "wa",
            "status",
            "--bookmark",
            "build",
            "--bookmark-tag",
            "prod",
        ])
        .expect("status bookmark filters should parse");

        match cli.command.map(|b| *b) {
            Some(Commands::Status {
                bookmark,
                bookmark_tag,
                ..
            }) => {
                assert_eq!(bookmark.as_deref(), Some("build"));
                assert_eq!(bookmark_tag.as_deref(), Some("prod"));
            }
            _ => panic!("expected Status command"),
        }
    }

    // ========================================================================
    // History CLI parsing tests (wa-5em.7)
    // ========================================================================

    #[test]
    fn cli_history_parses_filters() {
        let cli = Cli::try_parse_from([
            "wa",
            "history",
            "--pane",
            "3",
            "--limit",
            "25",
            "--workflow",
            "wf-123",
            "--undoable",
            "--since",
            "1 hour ago",
            "--until",
            "2026-01-18T12:00:00",
        ])
        .expect("history should parse");

        match cli.command.map(|b| *b) {
            Some(Commands::History {
                pane_id,
                limit,
                workflow,
                undoable,
                since,
                until,
                ..
            }) => {
                assert_eq!(pane_id, Some(3));
                assert_eq!(limit, 25);
                assert_eq!(workflow.as_deref(), Some("wf-123"));
                assert!(undoable);
                assert_eq!(since.as_deref(), Some("1 hour ago"));
                assert_eq!(until.as_deref(), Some("2026-01-18T12:00:00"));
            }
            _ => panic!("expected History command"),
        }
    }

    #[test]
    fn parse_history_time_relative() {
        let value = parse_relative_duration_ms("1 hour ago").expect("relative parse");
        assert_eq!(value, 3_600_000);
    }

    #[test]
    fn parse_history_time_iso_basic() {
        let parsed = parse_history_time_ms("2026-01-18T12:00:00").expect("parse ISO");
        assert!(parsed > 0);
    }

    // ========================================================================
    // Prepare/Commit CLI parsing tests
    // ========================================================================

    #[test]
    fn human_prepare_send_parses() {
        let cli = Cli::try_parse_from(["wa", "prepare", "send", "--pane", "7", "echo hi"])
            .expect("prepare send should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Prepare {
                command: PrepareCommands::Send { pane_id, text, .. },
            }) => {
                assert_eq!(pane_id, 7);
                assert_eq!(text, "echo hi");
            }
            Some(Commands::Prepare {
                command: PrepareCommands::Workflow { .. },
            }) => panic!("expected Prepare::Send"),
            _ => panic!("expected Prepare command"),
        }
    }

    #[test]
    fn human_prepare_workflow_run_parses() {
        let cli = Cli::try_parse_from([
            "wa",
            "prepare",
            "workflow",
            "run",
            "handle_compaction",
            "--pane",
            "4",
        ])
        .expect("prepare workflow run should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Prepare {
                command:
                    PrepareCommands::Workflow {
                        command: PrepareWorkflowCommands::Run { name, pane_id, .. },
                    },
            }) => {
                assert_eq!(name, "handle_compaction");
                assert_eq!(pane_id, 4);
            }
            Some(Commands::Prepare {
                command: PrepareCommands::Send { .. },
            }) => panic!("expected Prepare::Workflow"),
            _ => panic!("expected Prepare command"),
        }
    }

    #[test]
    fn human_commit_parses() {
        let cli = Cli::try_parse_from(["wa", "commit", "plan:abcd", "--text", "ls"])
            .expect("commit should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Commit { plan_id, text, .. }) => {
                assert_eq!(plan_id, "plan:abcd");
                assert_eq!(text.as_deref(), Some("ls"));
            }
            _ => panic!("expected Commit"),
        }
    }

    #[test]
    fn prepare_output_json_includes_plan_hash_and_plan() {
        let plan = build_prepare_send_plan("ws-test", 7, "echo hi", false, false, None, false, 30);
        let plan_hash = plan.compute_hash();
        let output = build_prepare_output(
            &plan,
            &plan_hash,
            1234,
            wa_core::policy::ActionKind::SendText.as_str(),
            Some(7),
            None,
            format!("wa commit {} --text <TEXT>", plan.plan_id),
        );
        let json = serde_json::to_string(&output).expect("serialize prepare output");
        let value: serde_json::Value = serde_json::from_str(&json).expect("parse prepare output");
        assert_eq!(
            value.get("plan_hash").and_then(|v| v.as_str()),
            Some(plan_hash.as_str())
        );
        assert!(value.get("plan").is_some());
    }

    #[test]
    fn commit_validation_rejects_missing_plan() {
        let err = require_prepared_plan(None).expect_err("missing plan should fail");
        assert_eq!(err, CommitValidationError::NotFound);
    }

    #[test]
    fn commit_validation_rejects_expired_plan() {
        let record = sample_prepared_plan_record(500);
        let err =
            validate_prepared_plan_record(&record, "ws-test", 1000).expect_err("expired plan");
        assert_eq!(err, CommitValidationError::Expired);
    }

    #[test]
    fn commit_validation_rejects_hash_mismatch() {
        let err =
            ensure_plan_hash("sha256:deadbeef", "sha256:feedface").expect_err("hash mismatch");
        assert_eq!(err, CommitValidationError::HashMismatch);
    }

    #[test]
    fn commit_validation_rejects_workspace_mismatch() {
        let record = sample_prepared_plan_record(1500);
        let err = validate_prepared_plan_record(&record, "other-workspace", 1000)
            .expect_err("workspace mismatch");
        assert_eq!(err, CommitValidationError::WorkspaceMismatch);
    }

    #[test]
    fn commit_validation_rejects_pane_mismatch() {
        let err = ensure_pane_uuid_matches(Some("pane-abc"), Some("pane-def"))
            .expect_err("pane mismatch");
        assert_eq!(err, CommitValidationError::PaneMismatch);
    }

    #[test]
    fn commit_validation_messages_include_codes_and_hints() {
        let (message, hint) =
            commit_validation_message(CommitValidationError::Expired, "plan:deadbeef");
        assert!(message.contains("E_PLAN_EXPIRED"));
        assert!(hint.unwrap().contains("Re-run `wa prepare"));
    }

    #[test]
    fn distributed_security_check_disabled_is_ok() {
        let config = wa_core::config::Config::default();
        let check = distributed_security_check(&config);
        assert_eq!(check.name, "distributed security");
        assert_eq!(check.status, DiagnosticStatus::Ok);
    }

    #[test]
    fn distributed_security_check_warns_on_allow_insecure() {
        let mut config = wa_core::config::Config::default();
        config.distributed.enabled = true;
        config.distributed.bind_addr = "0.0.0.0:4141".to_string();
        config.distributed.allow_insecure = true;
        config.distributed.token = Some("token".to_string());
        let check = distributed_security_check(&config);
        assert_eq!(check.status, DiagnosticStatus::Warning);
    }

    #[test]
    fn distributed_security_check_errors_on_missing_token() {
        let mut config = wa_core::config::Config::default();
        config.distributed.enabled = true;
        config.distributed.bind_addr = "127.0.0.1:4141".to_string();
        config.distributed.auth_mode = wa_core::config::DistributedAuthMode::Token;
        config.distributed.token = None;
        let check = distributed_security_check(&config);
        assert_eq!(check.status, DiagnosticStatus::Error);
    }

    // -------------------------------------------------------------------------
    // Saved Search Scheduler Tests (bd-3iar)
    // -------------------------------------------------------------------------

    fn secret_token() -> &'static str {
        // Long enough to trigger Redactor sk- pattern.
        "sk-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    }

    async fn wait_for_saved_search_error(
        storage: &StorageHandle,
        name: &str,
        timeout: std::time::Duration,
    ) -> wa_core::storage::SavedSearchRecord {
        let start = std::time::Instant::now();
        loop {
            assert!(
                start.elapsed() <= timeout,
                "timeout waiting for last_error to be set"
            );
            let record = storage
                .get_saved_search_by_name(name)
                .await
                .unwrap()
                .unwrap();
            if record.last_error.is_some() {
                return record;
            }
            tokio::time::sleep(std::time::Duration::from_millis(50)).await;
        }
    }

    #[tokio::test]
    async fn saved_search_scheduler_emits_alert_and_redacts_snippet() {
        use wa_core::events::Event;
        use wa_core::storage::{
            PaneRecord, SAVED_SEARCH_DEFAULT_LIMIT, SAVED_SEARCH_SINCE_MODE_LAST_RUN,
            SavedSearchRecord,
        };

        let (storage, db_path) = setup_storage("saved_search_scheduler_alert").await;
        let bus = Arc::new(wa_core::events::EventBus::new(256));
        let shutdown_flag = Arc::new(std::sync::atomic::AtomicBool::new(false));

        // Register pane 1 so the foreign key constraint is satisfied.
        let now = now_ms();
        storage
            .upsert_pane(PaneRecord {
                pane_id: 1,
                pane_uuid: None,
                domain: "local".to_string(),
                window_id: None,
                tab_id: None,
                title: None,
                cwd: None,
                tty_name: None,
                first_seen_at: now,
                last_seen_at: now,
                observed: true,
                ignore_reason: None,
                last_decision_at: None,
            })
            .await
            .unwrap();

        // Ensure there is content to match (and to redact).
        let content = format!("error: something happened {}", secret_token());
        storage.append_segment(1, &content, None).await.unwrap();

        let mut record = SavedSearchRecord::new(
            "errors".to_string(),
            "error".to_string(),
            None,
            SAVED_SEARCH_DEFAULT_LIMIT,
            SAVED_SEARCH_SINCE_MODE_LAST_RUN.to_string(),
            None,
        );
        record.enabled = true;
        record.schedule_interval_ms = Some(1_000);
        storage.insert_saved_search(record.clone()).await.unwrap();

        let scheduler_handle = tokio::spawn(run_saved_search_scheduler(
            storage.clone(),
            Arc::clone(&bus),
            Arc::clone(&shutdown_flag),
        ));

        let mut sub = bus.subscribe_detections();
        let event = tokio::time::timeout(std::time::Duration::from_secs(5), sub.recv())
            .await
            .expect("timeout waiting for saved_search.alert")
            .unwrap();

        let Event::PatternDetected { detection, .. } = event else {
            panic!("unexpected event variant");
        };

        assert_eq!(detection.rule_id, "wezterm.saved_search.alert");
        assert_eq!(detection.event_type, "saved_search.alert");

        let extracted = detection.extracted.as_object().unwrap();
        assert_eq!(
            extracted.get("search_name").and_then(|v| v.as_str()),
            Some("errors")
        );
        assert!(
            extracted
                .get("match_count")
                .and_then(|v| v.as_i64())
                .is_some_and(|n| n >= 1)
        );

        let snippet = extracted
            .get("snippet")
            .and_then(|v| v.as_str())
            .expect("expected snippet in extracted payload");
        assert!(snippet.contains("[REDACTED]"));
        assert!(!snippet.contains("sk-"));

        // Drain any queued events (avoid confusing the cooldown test below).
        while sub.try_recv().is_some() {}

        // Force the search to be due again quickly; the scheduler should run,
        // but the alert should be suppressed by per-search cooldown.
        let now = now_ms();
        let force_due_at = now - 10_000;
        storage
            .update_saved_search_run(&record.id, force_due_at, Some(1), None)
            .await
            .unwrap();

        // Give the scheduler a chance to tick and update last_run_at.
        tokio::time::sleep(std::time::Duration::from_millis(600)).await;
        let updated = storage
            .get_saved_search_by_name("errors")
            .await
            .unwrap()
            .unwrap();
        assert!(updated.last_run_at.is_some_and(|v| v >= force_due_at));

        // No second alert within the cooldown window.
        let second = tokio::time::timeout(std::time::Duration::from_secs(1), sub.recv()).await;
        assert!(
            second.is_err(),
            "expected cooldown to suppress second alert"
        );

        shutdown_flag.store(true, std::sync::atomic::Ordering::SeqCst);
        let _ = scheduler_handle.await;
        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn saved_search_scheduler_invalid_query_sets_last_error_and_backs_off() {
        use wa_core::storage::{
            SAVED_SEARCH_DEFAULT_LIMIT, SAVED_SEARCH_SINCE_MODE_LAST_RUN, SavedSearchRecord,
        };

        let (storage, db_path) = setup_storage("saved_search_scheduler_invalid").await;
        let bus = Arc::new(wa_core::events::EventBus::new(16));
        let shutdown_flag = Arc::new(std::sync::atomic::AtomicBool::new(false));

        let mut record = SavedSearchRecord::new(
            "invalid".to_string(),
            "\"unterminated".to_string(),
            None,
            SAVED_SEARCH_DEFAULT_LIMIT,
            SAVED_SEARCH_SINCE_MODE_LAST_RUN.to_string(),
            None,
        );
        record.enabled = true;
        record.schedule_interval_ms = Some(1_000);
        storage.insert_saved_search(record.clone()).await.unwrap();

        let scheduler_handle = tokio::spawn(run_saved_search_scheduler(
            storage.clone(),
            Arc::clone(&bus),
            Arc::clone(&shutdown_flag),
        ));

        let first =
            wait_for_saved_search_error(&storage, "invalid", std::time::Duration::from_secs(3))
                .await;
        let first_run_at = first
            .last_run_at
            .expect("expected last_run_at set on error");

        // Interval would make it due again quickly, but backoff should prevent
        // repeated executions for a short window.
        tokio::time::sleep(std::time::Duration::from_secs(2)).await;
        let second = storage
            .get_saved_search_by_name("invalid")
            .await
            .unwrap()
            .unwrap();
        assert_eq!(second.last_run_at, Some(first_run_at));
        assert!(second.last_error.is_some());

        shutdown_flag.store(true, std::sync::atomic::Ordering::SeqCst);
        let _ = scheduler_handle.await;
        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn saved_search_scheduler_respects_interval_when_not_due() {
        use wa_core::storage::{
            SAVED_SEARCH_DEFAULT_LIMIT, SAVED_SEARCH_SINCE_MODE_LAST_RUN, SavedSearchRecord,
        };

        let (storage, db_path) = setup_storage("saved_search_scheduler_interval").await;
        let bus = Arc::new(wa_core::events::EventBus::new(16));
        let shutdown_flag = Arc::new(std::sync::atomic::AtomicBool::new(false));

        let now = now_ms();
        let mut record = SavedSearchRecord::new(
            "not_due".to_string(),
            "error".to_string(),
            None,
            SAVED_SEARCH_DEFAULT_LIMIT,
            SAVED_SEARCH_SINCE_MODE_LAST_RUN.to_string(),
            None,
        );
        record.enabled = true;
        record.schedule_interval_ms = Some(60_000);
        record.last_run_at = Some(now);
        storage.insert_saved_search(record.clone()).await.unwrap();

        let scheduler_handle = tokio::spawn(run_saved_search_scheduler(
            storage.clone(),
            Arc::clone(&bus),
            Arc::clone(&shutdown_flag),
        ));

        tokio::time::sleep(std::time::Duration::from_millis(600)).await;
        let fetched = storage
            .get_saved_search_by_name("not_due")
            .await
            .unwrap()
            .unwrap();
        assert_eq!(fetched.last_run_at, Some(now));

        shutdown_flag.store(true, std::sync::atomic::Ordering::SeqCst);
        let _ = scheduler_handle.await;
        cleanup_storage(storage, &db_path).await;
    }

    //  parse_duration_to_ms tests 

    #[test]
    fn parse_duration_seconds() {
        assert_eq!(parse_duration_to_ms("30s"), Some(30_000));
    }

    #[test]
    fn parse_duration_minutes() {
        assert_eq!(parse_duration_to_ms("5m"), Some(300_000));
    }

    #[test]
    fn parse_duration_hours() {
        assert_eq!(parse_duration_to_ms("1h"), Some(3_600_000));
    }

    #[test]
    fn parse_duration_days() {
        assert_eq!(parse_duration_to_ms("7d"), Some(604_800_000));
    }

    #[test]
    fn parse_duration_weeks() {
        assert_eq!(parse_duration_to_ms("2w"), Some(1_209_600_000));
    }

    #[test]
    fn parse_duration_zero() {
        assert_eq!(parse_duration_to_ms("0h"), Some(0));
    }

    #[test]
    fn parse_duration_invalid_suffix() {
        assert_eq!(parse_duration_to_ms("5x"), None);
    }

    #[test]
    fn parse_duration_empty() {
        assert_eq!(parse_duration_to_ms(""), None);
    }

    #[test]
    fn parse_duration_no_number() {
        assert_eq!(parse_duration_to_ms("h"), None);
    }

    #[test]
    fn parse_duration_negative() {
        assert_eq!(parse_duration_to_ms("-1h"), None);
    }

    //  mute CLI storage round-trip tests 

    #[tokio::test]
    async fn mute_add_list_remove_roundtrip() {
        use wa_core::storage::EventMuteRecord;

        let (storage, db_path) = setup_storage("mute_roundtrip").await;
        let now = now_ms();

        // Initially no mutes
        let mutes = storage.list_active_mutes(now).await.unwrap();
        assert!(mutes.is_empty());

        // Add a mute
        let record = EventMuteRecord {
            identity_key: "evt:test_key_1".to_string(),
            scope: "workspace".to_string(),
            created_at: now,
            expires_at: Some(now + 3_600_000),
            created_by: Some("cli".to_string()),
            reason: Some("too noisy".to_string()),
        };
        storage.add_event_mute(record).await.unwrap();

        // List should show one mute
        let mutes = storage.list_active_mutes(now).await.unwrap();
        assert_eq!(mutes.len(), 1);
        assert_eq!(mutes[0].identity_key, "evt:test_key_1");
        assert_eq!(mutes[0].scope, "workspace");
        assert_eq!(mutes[0].reason.as_deref(), Some("too noisy"));

        // Remove the mute
        let removed = storage.remove_event_mute("evt:test_key_1").await.unwrap();
        assert!(removed);

        // List should be empty again
        let mutes = storage.list_active_mutes(now).await.unwrap();
        assert!(mutes.is_empty());

        // Removing again should return false
        let removed = storage.remove_event_mute("evt:test_key_1").await.unwrap();
        assert!(!removed);

        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn mute_permanent_no_expiry() {
        use wa_core::storage::EventMuteRecord;

        let (storage, db_path) = setup_storage("mute_permanent").await;
        let now = now_ms();

        let record = EventMuteRecord {
            identity_key: "evt:permanent".to_string(),
            scope: "global".to_string(),
            created_at: now,
            expires_at: None,
            created_by: Some("cli".to_string()),
            reason: None,
        };
        storage.add_event_mute(record).await.unwrap();

        // Should be listed even far in the future
        let far_future = now + 365 * 86_400_000;
        let mutes = storage.list_active_mutes(far_future).await.unwrap();
        assert_eq!(mutes.len(), 1);
        assert_eq!(mutes[0].identity_key, "evt:permanent");
        assert!(mutes[0].expires_at.is_none());

        cleanup_storage(storage, &db_path).await;
    }

    #[tokio::test]
    async fn mute_expired_not_listed() {
        use wa_core::storage::EventMuteRecord;

        let (storage, db_path) = setup_storage("mute_expired").await;
        let now = now_ms();

        let record = EventMuteRecord {
            identity_key: "evt:expired".to_string(),
            scope: "workspace".to_string(),
            created_at: now - 7_200_000,
            expires_at: Some(now - 3_600_000), // expired 1h ago
            created_by: Some("cli".to_string()),
            reason: None,
        };
        storage.add_event_mute(record).await.unwrap();

        let mutes = storage.list_active_mutes(now).await.unwrap();
        assert!(mutes.is_empty());

        cleanup_storage(storage, &db_path).await;
    }

    // ========================================================================
    // Analytics CLI parsing (wa-985.3)
    // ========================================================================

    #[test]
    fn cli_analytics_default_parses() {
        let cli =
            Cli::try_parse_from(["wa", "analytics"]).expect("analytics should parse with defaults");
        match cli.command.map(|b| *b) {
            Some(Commands::Analytics {
                command,
                period,
                format,
            }) => {
                assert!(command.is_none());
                assert_eq!(period, "7d");
                assert_eq!(format, "auto");
            }
            _ => panic!("expected Analytics command"),
        }
    }

    #[test]
    fn cli_analytics_daily_parses() {
        let cli = Cli::try_parse_from(["wa", "analytics", "daily"])
            .expect("analytics daily should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Analytics { command, .. }) => {
                assert!(matches!(command, Some(AnalyticsCommands::Daily)));
            }
            _ => panic!("expected Analytics command"),
        }
    }

    #[test]
    fn cli_analytics_by_agent_parses() {
        let cli = Cli::try_parse_from(["wa", "analytics", "by-agent"])
            .expect("analytics by-agent should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Analytics { command, .. }) => {
                assert!(matches!(command, Some(AnalyticsCommands::ByAgent)));
            }
            _ => panic!("expected Analytics command"),
        }
    }

    #[test]
    fn cli_analytics_export_csv_parses() {
        let cli = Cli::try_parse_from([
            "wa",
            "analytics",
            "export",
            "--format",
            "csv",
            "--output",
            "usage.csv",
        ])
        .expect("analytics export should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Analytics { command, .. }) => match command {
                Some(AnalyticsCommands::Export { format, output }) => {
                    assert_eq!(format, "csv");
                    assert_eq!(output.as_deref(), Some("usage.csv"));
                }
                _ => panic!("expected Export subcommand"),
            },
            _ => panic!("expected Analytics command"),
        }
    }

    #[test]
    fn cli_analytics_period_flag() {
        let cli = Cli::try_parse_from(["wa", "analytics", "--period", "30d"])
            .expect("analytics with period should parse");
        match cli.command.map(|b| *b) {
            Some(Commands::Analytics { period, .. }) => {
                assert_eq!(period, "30d");
            }
            _ => panic!("expected Analytics command"),
        }
    }

    #[test]
    fn parse_period_ms_various() {
        assert_eq!(parse_period_ms("1d"), 86_400_000);
        assert_eq!(parse_period_ms("7d"), 7 * 86_400_000);
        assert_eq!(parse_period_ms("30d"), 30 * 86_400_000);
        assert_eq!(parse_period_ms("90d"), 90 * 86_400_000);
        // Invalid falls back to 7d
        assert_eq!(parse_period_ms("xyz"), 7 * 86_400_000);
    }

    #[test]
    fn format_period_label_various() {
        assert_eq!(format_period_label("1d"), "Last 1 Day");
        assert_eq!(format_period_label("7d"), "Last 7 Days");
        assert_eq!(format_period_label("30d"), "Last 30 Days");
        assert_eq!(format_period_label("xyz"), "Last 7 Days");
    }

    // -----------------------------------------------------------------------
    // Doctor diagnostic tests (wa-nu4.3.4.8)
    // -----------------------------------------------------------------------

    // --- DiagnosticCheck construction ---

    #[test]
    fn diagnostic_check_ok_no_detail() {
        let check = DiagnosticCheck::ok("test-check");
        assert_eq!(check.name, "test-check");
        assert_eq!(check.status, DiagnosticStatus::Ok);
        assert!(check.detail.is_none());
        assert!(check.recommendation.is_none());
    }

    #[test]
    fn diagnostic_check_ok_with_detail() {
        let check = DiagnosticCheck::ok_with_detail("core loaded", "v0.1.0");
        assert_eq!(check.name, "core loaded");
        assert_eq!(check.status, DiagnosticStatus::Ok);
        assert_eq!(check.detail.as_deref(), Some("v0.1.0"));
        assert!(check.recommendation.is_none());
    }

    #[test]
    fn diagnostic_check_warning() {
        let check = DiagnosticCheck::warning(
            "database",
            "schema v1 (needs migration to v2)",
            "Run 'wa daemon start' to auto-migrate",
        );
        assert_eq!(check.status, DiagnosticStatus::Warning);
        assert!(check.detail.unwrap().contains("schema v1"));
        assert!(check.recommendation.unwrap().contains("auto-migrate"));
    }

    #[test]
    fn diagnostic_check_error() {
        let check = DiagnosticCheck::error(
            "database",
            "could not open: permission denied",
            "Check file permissions",
        );
        assert_eq!(check.status, DiagnosticStatus::Error);
        assert!(check.detail.unwrap().contains("permission denied"));
        assert!(check.recommendation.unwrap().contains("permissions"));
    }

    // --- DiagnosticStatus ---

    #[test]
    fn diagnostic_status_as_str() {
        assert_eq!(DiagnosticStatus::Ok.as_str(), "ok");
        assert_eq!(DiagnosticStatus::Warning.as_str(), "warning");
        assert_eq!(DiagnosticStatus::Error.as_str(), "error");
    }

    #[test]
    fn diagnostic_status_equality() {
        assert_eq!(DiagnosticStatus::Ok, DiagnosticStatus::Ok);
        assert_ne!(DiagnosticStatus::Ok, DiagnosticStatus::Warning);
        assert_ne!(DiagnosticStatus::Warning, DiagnosticStatus::Error);
    }

    // --- JSON output shape stability ---

    #[test]
    fn diagnostic_check_json_ok_shape() {
        let check = DiagnosticCheck::ok_with_detail("wa-core loaded", "v0.1.2");
        let json = check.to_json_value();
        assert_eq!(json["name"], "wa-core loaded");
        assert_eq!(json["status"], "ok");
        assert_eq!(json["detail"], "v0.1.2");
        // No recommendation for OK check
        assert!(json.get("recommendation").is_none());
    }

    #[test]
    fn diagnostic_check_json_warning_shape() {
        let check = DiagnosticCheck::warning(
            "daemon status",
            "stale lock (PID 12345 not running)",
            "Remove lock: rm /tmp/wa.lock",
        );
        let json = check.to_json_value();
        assert_eq!(json["name"], "daemon status");
        assert_eq!(json["status"], "warning");
        assert_eq!(json["detail"], "stale lock (PID 12345 not running)");
        assert_eq!(json["recommendation"], "Remove lock: rm /tmp/wa.lock");
    }

    #[test]
    fn diagnostic_check_json_error_shape() {
        let check = DiagnosticCheck::error(
            "database",
            "could not open: locked by another process",
            "Check if another wa instance is running",
        );
        let json = check.to_json_value();
        assert_eq!(json["name"], "database");
        assert_eq!(json["status"], "error");
        assert!(json["detail"].as_str().unwrap().contains("locked"));
        assert!(
            json["recommendation"]
                .as_str()
                .unwrap()
                .contains("another wa")
        );
    }

    #[test]
    fn diagnostic_check_json_ok_no_detail_shape() {
        let check = DiagnosticCheck::ok("features");
        let json = check.to_json_value();
        assert_eq!(json["name"], "features");
        assert_eq!(json["status"], "ok");
        // detail and recommendation should not be present
        assert!(json.get("detail").is_none());
        assert!(json.get("recommendation").is_none());
    }

    #[test]
    fn diagnostic_check_json_no_ansi_escapes() {
        // JSON output must never contain ANSI escape codes
        let checks = vec![
            DiagnosticCheck::ok("basic"),
            DiagnosticCheck::ok_with_detail("detailed", "with content"),
            DiagnosticCheck::warning("warn", "issue found", "fix suggestion"),
            DiagnosticCheck::error("err", "critical issue", "immediate action"),
        ];
        for check in &checks {
            let json = check.to_json_value();
            let json_str = serde_json::to_string(&json).unwrap();
            assert!(
                !json_str.contains('\x1b'),
                "JSON for '{}' contains ANSI escape",
                check.name
            );
            assert!(
                !json_str.contains("\\u001b"),
                "JSON for '{}' contains escaped ANSI",
                check.name
            );
        }
    }

    #[test]
    fn diagnostic_check_json_field_names_stable() {
        // Verify field names are consistent across all status types
        let ok = DiagnosticCheck::ok_with_detail("test", "detail").to_json_value();
        let warn = DiagnosticCheck::warning("test", "detail", "rec").to_json_value();
        let err = DiagnosticCheck::error("test", "detail", "rec").to_json_value();

        // All have name and status
        for json in [&ok, &warn, &err] {
            assert!(json.get("name").is_some(), "missing 'name' field");
            assert!(json.get("status").is_some(), "missing 'status' field");
        }

        // Warning and error have recommendation; ok does not
        assert!(ok.get("recommendation").is_none());
        assert!(warn.get("recommendation").is_some());
        assert!(err.get("recommendation").is_some());
    }

    // --- Overall doctor JSON envelope ---

    #[test]
    fn doctor_json_envelope_ok_when_no_errors() {
        let checks = [
            DiagnosticCheck::ok_with_detail("wa-core loaded", "v0.1.0"),
            DiagnosticCheck::ok_with_detail("workspace root", "/home/user/project"),
            DiagnosticCheck::warning("daemon status", "not running", "Start with wa watch"),
        ];

        let has_errors = checks.iter().any(|c| c.status == DiagnosticStatus::Error);
        let has_warnings = checks.iter().any(|c| c.status == DiagnosticStatus::Warning);

        let overall = if has_errors {
            "error"
        } else if has_warnings {
            "warning"
        } else {
            "ok"
        };

        let result = serde_json::json!({
            "ok": !has_errors,
            "status": overall,
            "version": "0.1.0",
            "checks": checks.iter().map(|c| c.to_json_value()).collect::<Vec<_>>(),
        });

        assert_eq!(result["ok"], true);
        assert_eq!(result["status"], "warning");
        assert_eq!(result["checks"].as_array().unwrap().len(), 3);
    }

    #[test]
    fn doctor_json_envelope_error_when_errors_present() {
        let checks = [
            DiagnosticCheck::ok_with_detail("wa-core loaded", "v0.1.0"),
            DiagnosticCheck::error("database", "corrupt", "Rebuild database"),
        ];

        let has_errors = checks.iter().any(|c| c.status == DiagnosticStatus::Error);
        let overall = if has_errors { "error" } else { "ok" };

        let result = serde_json::json!({
            "ok": !has_errors,
            "status": overall,
            "checks": checks.iter().map(|c| c.to_json_value()).collect::<Vec<_>>(),
        });

        assert_eq!(result["ok"], false);
        assert_eq!(result["status"], "error");
    }

    #[test]
    fn doctor_json_envelope_ok_when_all_pass() {
        let checks = [
            DiagnosticCheck::ok("a"),
            DiagnosticCheck::ok_with_detail("b", "detail"),
        ];

        let has_errors = checks.iter().any(|c| c.status == DiagnosticStatus::Error);
        let has_warnings = checks.iter().any(|c| c.status == DiagnosticStatus::Warning);

        let overall = if has_errors {
            "error"
        } else if has_warnings {
            "warning"
        } else {
            "ok"
        };

        assert_eq!(overall, "ok");
        assert!(!has_errors);
    }

    // --- is_loopback_bind_addr helper ---

    #[test]
    fn loopback_addr_detection() {
        assert!(is_loopback_bind_addr("127.0.0.1:8080"));
        assert!(is_loopback_bind_addr("localhost:8080"));
        assert!(is_loopback_bind_addr("127.0.0.1:0"));
        assert!(is_loopback_bind_addr("[::1]:8080"));
        assert!(!is_loopback_bind_addr("0.0.0.0:8080"));
        assert!(!is_loopback_bind_addr("192.168.1.1:8080"));
    }

    // --- Distributed security check fixture tests ---

    #[test]
    fn distributed_security_disabled_is_ok() {
        let config = wa_core::config::Config::default();
        // Default config has distributed.enabled = false
        let check = distributed_security_check(&config);
        assert_eq!(check.status, DiagnosticStatus::Ok);
        assert!(check.detail.unwrap().contains("disabled"));
    }

    // --- Secret redaction in diagnostic output ---

    #[test]
    fn diagnostic_detail_does_not_contain_raw_secrets() {
        // Simulate what doctor does: it shows config summaries, never raw tokens
        let check = DiagnosticCheck::ok_with_detail(
            "distributed security",
            "bind=127.0.0.1:9090, auth=token, tls=on, token=env:ok, allowlist=2",
        );
        let json = check.to_json_value();
        let json_str = serde_json::to_string(&json).unwrap();
        // Should not contain actual secret patterns
        assert!(!json_str.contains("sk-"));
        assert!(!json_str.contains("Bearer "));
        assert!(!json_str.contains("password="));
    }

    // --- Fixture-based: run_diagnostics with controlled workspace ---

    fn make_test_layout(temp: &std::path::Path) -> wa_core::config::WorkspaceLayout {
        let wa_dir = temp.join(".wa");
        wa_core::config::WorkspaceLayout {
            root: temp.to_path_buf(),
            wa_dir: wa_dir.clone(),
            db_path: wa_dir.join("wa.db"),
            lock_path: wa_dir.join("wa.lock"),
            ipc_socket_path: wa_dir.join("wa.sock"),
            logs_dir: wa_dir.join("logs"),
            log_path: wa_dir.join("logs/wa.log"),
            crash_dir: wa_dir.join("crashes"),
            diag_dir: wa_dir.join("diag"),
        }
    }

    #[tokio::test]
    async fn doctor_fixture_healthy_workspace() {
        let temp = unique_temp_dir("doctor_healthy");
        let layout = make_test_layout(&temp);
        std::fs::create_dir_all(&layout.logs_dir).unwrap();

        // Create a valid SQLite DB with correct schema version
        let storage = StorageHandle::new(&layout.db_path.to_string_lossy())
            .await
            .unwrap();
        let _ = storage.shutdown().await;
        let config = wa_core::config::Config::default();

        let checks = run_diagnostics(&[], &config, &layout);

        // Should have multiple checks
        assert!(
            checks.len() >= 5,
            "expected at least 5 checks, got {}",
            checks.len()
        );

        // Find specific checks by name
        let core_check = checks.iter().find(|c| c.name == "wa-core loaded");
        assert!(core_check.is_some());
        assert_eq!(core_check.unwrap().status, DiagnosticStatus::Ok);

        let ws_check = checks.iter().find(|c| c.name == "workspace root");
        assert!(ws_check.is_some());
        assert_eq!(ws_check.unwrap().status, DiagnosticStatus::Ok);

        let wa_dir_check = checks.iter().find(|c| c.name == ".wa directory");
        assert!(wa_dir_check.is_some());
        assert_eq!(wa_dir_check.unwrap().status, DiagnosticStatus::Ok);

        let db_check = checks.iter().find(|c| c.name == "database");
        assert!(db_check.is_some());
        assert_eq!(db_check.unwrap().status, DiagnosticStatus::Ok);
        let db_detail = db_check.unwrap().detail.as_deref().unwrap();
        assert!(
            db_detail.contains("schema v"),
            "DB detail should show schema version"
        );
        assert!(db_detail.contains("wal"), "DB detail should show WAL mode");

        let daemon_check = checks.iter().find(|c| c.name == "daemon status");
        assert!(daemon_check.is_some());
        // No lock file  not running
        assert_eq!(daemon_check.unwrap().status, DiagnosticStatus::Ok);
        assert!(
            daemon_check
                .unwrap()
                .detail
                .as_deref()
                .unwrap()
                .contains("not running")
        );

        let logs_check = checks.iter().find(|c| c.name == "logs directory");
        assert!(logs_check.is_some());
        assert_eq!(logs_check.unwrap().status, DiagnosticStatus::Ok);

        // Verify JSON shape
        let json_checks: Vec<serde_json::Value> =
            checks.iter().map(|c| c.to_json_value()).collect();
        for jc in &json_checks {
            assert!(jc.get("name").is_some());
            assert!(jc.get("status").is_some());
            let status = jc["status"].as_str().unwrap();
            assert!(
                ["ok", "warning", "error"].contains(&status),
                "invalid status: {status}"
            );
        }

        // No errors in healthy workspace (except WezTerm checks which depend on runtime)
        let wezterm_check_names = ["WezTerm CLI", "WezTerm connection"];
        let error_names: Vec<&str> = checks
            .iter()
            .filter(|c| c.status == DiagnosticStatus::Error)
            .filter(|c| !wezterm_check_names.contains(&c.name))
            .map(|c| c.name)
            .collect();
        assert!(
            error_names.is_empty(),
            "healthy workspace should have no non-WezTerm errors: {error_names:?}"
        );

        // Cleanup
        let _ = std::fs::remove_dir_all(&temp);
    }

    #[test]
    fn doctor_fixture_missing_wa_dir() {
        let temp = unique_temp_dir("doctor_no_wa");
        let layout = make_test_layout(&temp);
        let config = wa_core::config::Config::default();

        let checks = run_diagnostics(&[], &config, &layout);

        let wa_dir_check = checks.iter().find(|c| c.name == ".wa directory").unwrap();
        assert_eq!(wa_dir_check.status, DiagnosticStatus::Warning);
        assert!(
            wa_dir_check
                .detail
                .as_deref()
                .unwrap()
                .contains("does not exist")
        );

        let db_check = checks.iter().find(|c| c.name == "database").unwrap();
        assert_eq!(db_check.status, DiagnosticStatus::Warning);

        let _ = std::fs::remove_dir_all(&temp);
    }

    #[test]
    fn doctor_fixture_stale_lock_file() {
        let temp = unique_temp_dir("doctor_stale_lock");
        let layout = make_test_layout(&temp);
        std::fs::create_dir_all(&layout.wa_dir).unwrap();

        // Write a lock file with a PID that definitely doesn't exist
        std::fs::write(&layout.lock_path, "999999999").unwrap();

        let config = wa_core::config::Config::default();

        let checks = run_diagnostics(&[], &config, &layout);

        let daemon_check = checks.iter().find(|c| c.name == "daemon status").unwrap();
        assert_eq!(daemon_check.status, DiagnosticStatus::Warning);
        let detail = daemon_check.detail.as_deref().unwrap();
        assert!(
            detail.contains("stale") || detail.contains("not running"),
            "stale lock should be detected, got: {detail}"
        );

        let _ = std::fs::remove_dir_all(&temp);
    }

    #[test]
    fn doctor_fixture_feature_flags() {
        let temp = unique_temp_dir("doctor_features");
        let layout = make_test_layout(&temp);
        std::fs::create_dir_all(&layout.wa_dir).unwrap();

        let config = wa_core::config::Config::default();

        let checks = run_diagnostics(&[], &config, &layout);

        let features_check = checks.iter().find(|c| c.name == "features").unwrap();
        assert_eq!(features_check.status, DiagnosticStatus::Ok);
        // Features detail should be a string (either feature list or "default")
        let detail = features_check.detail.as_deref().unwrap();
        assert!(!detail.is_empty());
        // Should not contain secrets
        assert!(!detail.contains("sk-"));
        assert!(!detail.contains("Bearer"));

        let _ = std::fs::remove_dir_all(&temp);
    }

    #[test]
    fn doctor_json_output_all_checks_have_valid_status() {
        let temp = unique_temp_dir("doctor_valid_status");
        let layout = make_test_layout(&temp);
        std::fs::create_dir_all(&layout.wa_dir).unwrap();

        let config = wa_core::config::Config::default();

        let checks = run_diagnostics(&[], &config, &layout);

        // Verify every check can be serialized to valid JSON
        for check in &checks {
            let json = check.to_json_value();
            let status = json["status"].as_str().unwrap();
            assert!(
                ["ok", "warning", "error"].contains(&status),
                "check '{}' has invalid status: '{}'",
                check.name,
                status
            );
            // Name is always present and non-empty
            let name = json["name"].as_str().unwrap();
            assert!(!name.is_empty(), "check name must not be empty");
        }

        // Overall JSON envelope
        let has_errors = checks.iter().any(|c| c.status == DiagnosticStatus::Error);
        let has_warnings = checks.iter().any(|c| c.status == DiagnosticStatus::Warning);
        let overall = if has_errors {
            "error"
        } else if has_warnings {
            "warning"
        } else {
            "ok"
        };

        let envelope = serde_json::json!({
            "ok": !has_errors,
            "status": overall,
            "version": wa_core::VERSION,
            "checks": checks.iter().map(|c| c.to_json_value()).collect::<Vec<_>>(),
        });

        // Envelope has required fields
        assert!(envelope.get("ok").is_some());
        assert!(envelope.get("status").is_some());
        assert!(envelope.get("version").is_some());
        assert!(envelope.get("checks").is_some());

        // Full JSON roundtrip
        let json_str = serde_json::to_string_pretty(&envelope).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&json_str).unwrap();
        assert_eq!(parsed["ok"], envelope["ok"]);
        assert_eq!(parsed["status"], envelope["status"]);

        let _ = std::fs::remove_dir_all(&temp);
    }

    #[test]
    fn doctor_check_names_are_deterministic() {
        let temp = unique_temp_dir("doctor_deterministic");
        let layout = make_test_layout(&temp);
        std::fs::create_dir_all(&layout.wa_dir).unwrap();

        let config = wa_core::config::Config::default();

        let checks_1 = run_diagnostics(&[], &config, &layout);
        let checks_2 = run_diagnostics(&[], &config, &layout);

        // Same names in same order
        let names_1: Vec<&str> = checks_1.iter().map(|c| c.name).collect();
        let names_2: Vec<&str> = checks_2.iter().map(|c| c.name).collect();
        assert_eq!(names_1, names_2, "check names must be deterministic");

        // Same statuses
        let statuses_1: Vec<&str> = checks_1.iter().map(|c| c.status.as_str()).collect();
        let statuses_2: Vec<&str> = checks_2.iter().map(|c| c.status.as_str()).collect();
        assert_eq!(
            statuses_1, statuses_2,
            "check statuses must be deterministic"
        );

        let _ = std::fs::remove_dir_all(&temp);
    }
}
